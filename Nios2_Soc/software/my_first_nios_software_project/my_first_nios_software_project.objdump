
my_first_nios_software_project.elf:     file format elf32-littlenios2
my_first_nios_software_project.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x100002b4

Program Header:
    LOAD off    0x00001000 vaddr 0x00000000 paddr 0x00000000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001120 vaddr 0x10000120 paddr 0x10000120 align 2**12
         filesz 0x0000a760 memsz 0x0000aa40 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  00000000  00000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000194  10000120  10000120  00001120  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00008974  100002b4  100002b4  000012b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000c8  10008c28  10008c28  00009c28  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001b90  10008cf0  10008cf0  00009cf0  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000002e0  1000a880  1000a880  0000b880  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000026  00000000  00000000  0000b880  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 000009b0  00000000  00000000  0000b8a8  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00001453  00000000  00000000  0000c258  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0001e7a5  00000000  00000000  0000d6ab  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 000058be  00000000  00000000  0002be50  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000eb96  00000000  00000000  0003170e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001660  00000000  00000000  000402a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00001940  00000000  00000000  00041904  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0000471b  00000000  00000000  00043244  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000050  00000000  00000000  00047960  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000002d8  00000000  00000000  000479b0  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0004ab8a  2**0
                  CONTENTS, READONLY
 18 .cpu          00000003  00000000  00000000  0004ab8d  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0004ab90  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0004ab91  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  0004ab92  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  0004ab96  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  0004ab9a  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   0000001e  00000000  00000000  0004ab9e  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    0000001e  00000000  00000000  0004abbc  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   0000001e  00000000  00000000  0004abda  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 00000013  00000000  00000000  0004abf8  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000044  00000000  00000000  0004ac0b  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     000cf5b9  00000000  00000000  0004ac4f  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    d  .entry	00000000 .entry
10000120 l    d  .exceptions	00000000 .exceptions
100002b4 l    d  .text	00000000 .text
10008c28 l    d  .rodata	00000000 .rodata
10008cf0 l    d  .rwdata	00000000 .rwdata
1000a880 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
100002f8 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 hello_world.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 impure.c
10008cf0 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
10001c68 l     F .text	00000058 std
10001d74 l     F .text	00000008 __fp_lock
10001d7c l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 alt_close.c
10002d3c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
10002d9c l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
10002e9c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
10002fbc l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
1000310c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
10003338 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
1000a860 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
100035d4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
100096a0 l     O .rwdata	000000d8 ext_flash
10009778 l     O .rwdata	00001060 peripheral_subsystem_jtag_uart
1000a7d8 l     O .rwdata	00000030 ethernet_subsystem_sgdma_rx
1000a808 l     O .rwdata	00000030 ethernet_subsystem_sgdma_tx
10003704 l     F .text	00000038 alt_dev_reg
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
100037d8 l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
100045d8 l     F .text	0000007c alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
100056c4 l     F .text	00000228 altera_avalon_jtag_uart_irq
100058ec l     F .text	000000b0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
10006638 l     F .text	00000060 alt_get_errno
10006be0 l     F .text	000000c0 alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
10006d4c l     F .text	00000070 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
100070cc l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
10007624 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
10007760 l     F .text	000000dc alt_file_locked
100079c4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
10007fcc l     F .text	000000bc alt_write_word_amd
10007ea8 l     F .text	00000124 alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
10008280 l     F .text	0000018c alt_unlock_block_intel
1000840c l     F .text	000000dc alt_write_word_intel
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
10008a10 l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 alt_exit.c
10008bc4 l     F .text	00000040 alt_sim_halt
10002ae0 g     F .text	00000070 _isatty_r
1000316c g     F .text	0000006c alt_main
10000330 g     F .text	000000a0 _puts_r
10004098 g     F .text	00000048 alt_read_query_entry_32bit
1000a8d0 g     O .bss	00000100 alt_irq
10002b50 g     F .text	00000078 _lseek_r
10003810 g     F .text	000002c0 alt_flash_cfi_write
1000ab60 g       *ABS*	00000000 __alt_heap_start
100060a4 g     F .text	00000124 alt_avalon_sgdma_do_sync_transfer
1000271c g     F .text	00000068 __sseek
10001cd0 g     F .text	000000a4 __sinit
10001dd0 g     F .text	00000068 __sfmoreglue
100031f8 g     F .text	00000020 __malloc_unlock
100067f8 g     F .text	000003e8 alt_avalon_sgdma_construct_descriptor_burst
100011b8 g     F .text	000000e0 memmove
10001dc0 g     F .text	00000010 _cleanup
00000000  w      *UND*	00000000 __errno
10004224 g     F .text	00000048 alt_write_flash_command_32bit_device_16bit_mode
00000000 g     F .entry	00000000 __reset
1000630c g     F .text	00000070 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
10002a6c g     F .text	00000074 _fstat_r
10003d2c g     F .text	000002e8 alt_flash_program_block
1000a88c g     O .bss	00000004 errno
1000a894 g     O .bss	00000004 alt_argv
10012838 g       *ABS*	00000000 _gp
100086c0 g     F .text	00000030 usleep
10009520 g     O .rwdata	00000180 alt_fd_list
100071f4 g     F .text	00000094 alt_find_dev
10001118 g     F .text	000000a0 memcpy
10001db4 g     F .text	0000000c _cleanup_r
100076e8 g     F .text	00000078 alt_io_redirect
10008c28 g       *ABS*	00000000 __DTOR_END__
100003d0 g     F .text	00000014 puts
100063f0 g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
10005b04 g     F .text	00000224 altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
10002efc g     F .text	000000c0 isatty
1000a880 g     O .bss	00000004 __malloc_top_pad
10000458 g     F .text	0000049c __sfvwrite_r
10006518 g     F .text	00000058 alt_avalon_sgdma_stop
1000188c g     F .text	00000070 _sbrk_r
10008088 g     F .text	00000084 alt_program_intel
10002bc8 g     F .text	00000078 _read_r
10006fa0 g     F .text	00000078 alt_dcache_flush
1000a858 g     O .rwdata	00000004 alt_max_fd
10004014 g     F .text	00000040 alt_read_query_entry_8bit
10002948 g     F .text	00000110 _fclose_r
1000810c g     F .text	00000174 alt_erase_block_intel
10001c34 g     F .text	00000034 fflush
1000a884 g     O .bss	00000004 __malloc_max_sbrked_mem
1000301c g     F .text	000000f0 lseek
1000a83c g     O .rwdata	00000004 _global_impure_ptr
10001298 g     F .text	000005f4 _realloc_r
1000ab60 g       *ABS*	00000000 __bss_end
1000752c g     F .text	000000f8 alt_iic_isr_register
10005f68 g     F .text	0000013c alt_avalon_sgdma_do_async_transfer
10007afc g     F .text	0000010c alt_tick
10001d9c g     F .text	00000018 __fp_lock_all
100074e4 g     F .text	00000048 alt_ic_irq_enabled
10007a64 g     F .text	00000098 alt_alarm_stop
1000a89c g     O .bss	00000004 alt_irq_active
100001ec g     F .exceptions	000000c8 alt_irq_handler
100094f8 g     O .rwdata	00000028 alt_dev_null
1000452c g     F .text	000000ac alt_set_flash_algorithm_func
10006570 g     F .text	00000070 alt_avalon_sgdma_check_descriptor_status
100040e0 g     F .text	0000003c alt_write_flash_command_8bit_device_8bit_mode
1000a850 g     O .rwdata	00000008 alt_dev_list
100034b4 g     F .text	00000120 write
10006720 g     F .text	0000007c alt_avalon_sgdma_enable_desc_poll
10002dc8 g     F .text	000000d4 fstat
100053e0 g     F .text	000000dc alt_check_primary_table
10003b60 g     F .text	00000068 alt_flash_cfi_read
100042b4 g     F .text	00000034 alt_write_native_8bit
1000637c g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_stream_desc
10006474 g     F .text	00000050 alt_avalon_sgdma_register_callback
1000ab60 g       *ABS*	00000000 end
1000411c g     F .text	0000007c alt_write_flash_command_16bit_device_8bit_mode
10004654 g     F .text	000005e0 alt_read_cfi_table
10005604 g     F .text	000000c0 altera_avalon_jtag_uart_init
10008c24 g       *ABS*	00000000 __CTOR_LIST__
12000000 g       *ABS*	00000000 __alt_stack_pointer
1000679c g     F .text	0000005c alt_avalon_sgdma_disable_desc_poll
10006dbc g     F .text	00000090 alt_avalon_timer_sc_init
10005d28 g     F .text	00000240 altera_avalon_jtag_uart_write
100061c8 g     F .text	00000070 alt_avalon_sgdma_construct_mem_to_mem_desc
1000373c g     F .text	0000009c alt_flash_cfi_init
10001cc0 g     F .text	00000004 __sfp_lock_acquire
10001034 g     F .text	000000e4 memchr
100062b8 g     F .text	00000054 alt_avalon_sgdma_construct_stream_to_mem_desc
10002054 g     F .text	00000314 _free_r
10008a14 g     F .text	000001b0 __call_exitprocs
1000a844 g     O .rwdata	00000004 __malloc_sbrk_base
100002b4 g     F .text	00000048 _start
1000a8a0 g     O .bss	00000004 _alt_tick_rate
100065e0 g     F .text	00000058 alt_avalon_sgdma_open
1000a8a4 g     O .bss	00000004 _alt_nticks
10003218 g     F .text	00000120 read
10003668 g     F .text	0000009c alt_sys_init
100088dc g     F .text	00000134 __register_exitproc
10004054 g     F .text	00000044 alt_read_query_entry_16bit
10007a24 g     F .text	00000040 alt_remap_uncached
1000599c g     F .text	00000074 altera_avalon_jtag_uart_close
1000a8a8 g     O .bss	00000028 __malloc_current_mallinfo
1000434c g     F .text	000001e0 alt_set_flash_width_func
100054bc g     F .text	00000058 altera_avalon_jtag_uart_read_fd
10008608 g     F .text	000000b8 alt_get_fd
100086f0 g     F .text	0000012c alt_busy_sleep
100028d8 g     F .text	00000070 _close_r
10007c90 g     F .text	00000218 alt_erase_block_amd
10008868 g     F .text	00000074 memcmp
1000556c g     F .text	00000048 altera_avalon_jtag_uart_close_fd
1000ab60 g       *ABS*	00000000 __alt_stack_base
100055b4 g     F .text	00000050 altera_avalon_jtag_uart_ioctl_fd
100018fc g     F .text	0000013c __swsetup_r
10004c34 g     F .text	000007ac alt_read_cfi_width
10001e38 g     F .text	000000f0 __sfp
100090f0 g     O .rwdata	00000408 __malloc_av_
10001ccc g     F .text	00000004 __sinit_lock_release
10002800 g     F .text	00000060 __sread
100084e8 g     F .text	00000120 alt_find_file
10007018 g     F .text	000000b4 alt_dev_llist_insert
100031d8 g     F .text	00000020 __malloc_lock
100033f8 g     F .text	000000bc sbrk
100064c4 g     F .text	00000054 alt_avalon_sgdma_start
10001a38 g     F .text	000001fc _fflush_r
1000a86c g     O .rwdata	00000008 alt_flash_dev_list
100041e0 g     F .text	00000044 alt_write_flash_command_16bit_device_16bit_mode
1000a880 g       *ABS*	00000000 __bss_start
1000267c g     F .text	00000098 memset
100002fc g     F .text	00000034 main
1000a898 g     O .bss	00000004 alt_envp
0800c000 g       *ABS*	00000000 __alt_mem_ethernet_subsystem_descriptor_memory
1000a888 g     O .bss	00000004 __malloc_max_total_mem
10005514 g     F .text	00000058 altera_avalon_jtag_uart_write_fd
1000a864 g     O .rwdata	00000008 alt_sgdma_list
10002714 g     F .text	00000008 __sclose
12000000 g       *ABS*	00000000 __alt_heap_limit
10002a58 g     F .text	00000014 fclose
1000a9d0 g     O .bss	00000190 _atexit0
100008f4 g     F .text	00000740 _malloc_r
1000a85c g     O .rwdata	00000004 alt_errno
1000426c g     F .text	00000048 alt_write_flash_command_32bit_device_32bit_mode
10002430 g     F .text	000000b8 _fwalk
10003bc8 g     F .text	00000164 alt_write_value_to_flash
100042e8 g     F .text	00000034 alt_write_native_16bit
10001f28 g     F .text	0000012c _malloc_trim_r
10008c28 g       *ABS*	00000000 __CTOR_END__
10008c28 g       *ABS*	00000000 __DTOR_LIST__
10003634 g     F .text	00000034 alt_irq_init
10003398 g     F .text	00000060 alt_release_fd
1000881c g     F .text	00000014 atexit
10002860 g     F .text	00000078 _write_r
1000a838 g     O .rwdata	00000004 _impure_ptr
1000a890 g     O .bss	00000004 alt_argc
10007190 g     F .text	00000064 _do_dtors
10000120 g       .exceptions	00000000 alt_irq_entry
10001d84 g     F .text	00000018 __fp_unlock_all
1000a848 g     O .rwdata	00000008 alt_fs_list
10004198 g     F .text	00000048 alt_write_flash_command_32bit_device_8bit_mode
10007358 g     F .text	00000050 alt_ic_isr_register
1000a880 g       *ABS*	00000000 _edata
1000ab60 g       *ABS*	00000000 _end
10007288 g     F .text	0000007c alt_flash_open_dev
10005a10 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
10007444 g     F .text	000000a0 alt_ic_irq_disable
10006698 g     F .text	00000088 alt_avalon_sgdma_construct_descriptor
10002784 g     F .text	0000007c __swrite
1000a840 g     O .rwdata	00000004 __malloc_trim_threshold
10007c08 g     F .text	00000020 altera_nios2_qsys_irq_init
10008830 g     F .text	00000038 exit
10002368 g     F .text	000000c8 _fwalk_reent
10007304 g     F .text	00000054 alt_flash_close_dev
12000000 g       *ABS*	00000000 __alt_data_end
10000120 g     F .exceptions	00000000 alt_exception
10001cc4 g     F .text	00000004 __sfp_lock_release
10000000 g       *ABS*	00000000 __alt_mem_sdram
00000000 g       *ABS*	00000000 __alt_mem_ext_flash
10008c04 g     F .text	00000020 _exit
10006e4c g     F .text	00000154 alt_alarm_start
100024e8 g     F .text	00000194 __smakebuf_r
1000431c g     F .text	00000030 alt_write_native_32bit
100003e4 g     F .text	00000074 strlen
1000783c g     F .text	00000188 open
10003ad0 g     F .text	00000090 alt_flash_cfi_get_info
1000a874 g     O .rwdata	00000004 alt_priority_mask
100073a8 g     F .text	0000009c alt_ic_irq_enable
10006238 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
1000a878 g     O .rwdata	00000008 alt_alarm_list
1000712c g     F .text	00000064 _do_ctors
10002c40 g     F .text	000000fc close
10007c28 g     F .text	00000068 alt_program_amd
10006ca0 g     F .text	000000ac alt_avalon_sgdma_init
00000000  w      *UND*	00000000 free
10001cc8 g     F .text	00000004 __sinit_lock_acquire



Disassembly of section .exceptions:

10000120 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
10000120:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
10000124:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
10000128:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
1000012c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
10000130:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
10000134:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
10000138:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
1000013c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
10000140:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
10000144:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
10000148:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
1000014c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
10000150:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
10000154:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
10000158:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
1000015c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
10000160:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
10000164:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
10000168:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
1000016c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
10000170:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
10000174:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
10000178:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
1000017c:	10000326 	beq	r2,zero,1000018c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
10000180:	20000226 	beq	r4,zero,1000018c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
10000184:	00001ec0 	call	100001ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
10000188:	00000306 	br	10000198 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
1000018c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
10000190:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
10000194:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
10000198:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
1000019c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
100001a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
100001a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
100001a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
100001ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
100001b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
100001b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
100001b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
100001bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
100001c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
100001c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
100001c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
100001cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
100001d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
100001d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
100001d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
100001dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
100001e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
100001e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
100001e8:	ef80083a 	eret

100001ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
100001ec:	defff904 	addi	sp,sp,-28
100001f0:	dfc00615 	stw	ra,24(sp)
100001f4:	df000515 	stw	fp,20(sp)
100001f8:	df000504 	addi	fp,sp,20
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
100001fc:	0005313a 	rdctl	r2,ipending
10000200:	e0bffc15 	stw	r2,-16(fp)

  return active;
10000204:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
10000208:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
1000020c:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
10000210:	00800044 	movi	r2,1
10000214:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
10000218:	e0ffff17 	ldw	r3,-4(fp)
1000021c:	e0bffe17 	ldw	r2,-8(fp)
10000220:	1884703a 	and	r2,r3,r2
10000224:	1005003a 	cmpeq	r2,r2,zero
10000228:	1000161e 	bne	r2,zero,10000284 <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
1000022c:	e0bffd17 	ldw	r2,-12(fp)
10000230:	00c40074 	movhi	r3,4097
10000234:	18ea3404 	addi	r3,r3,-22320
10000238:	100490fa 	slli	r2,r2,3
1000023c:	10c5883a 	add	r2,r2,r3
10000240:	11400017 	ldw	r5,0(r2)
10000244:	e0bffd17 	ldw	r2,-12(fp)
10000248:	00c40074 	movhi	r3,4097
1000024c:	18ea3404 	addi	r3,r3,-22320
10000250:	100490fa 	slli	r2,r2,3
10000254:	10c5883a 	add	r2,r2,r3
10000258:	10800104 	addi	r2,r2,4
1000025c:	11000017 	ldw	r4,0(r2)
10000260:	283ee83a 	callr	r5
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
10000264:	0005313a 	rdctl	r2,ipending
10000268:	e0bffb15 	stw	r2,-20(fp)

  return active;
1000026c:	e0bffb17 	ldw	r2,-20(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
10000270:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
10000274:	e0bfff17 	ldw	r2,-4(fp)
10000278:	1004c03a 	cmpne	r2,r2,zero
1000027c:	103fe31e 	bne	r2,zero,1000020c <alt_irq_handler+0x20>
10000280:	00000706 	br	100002a0 <alt_irq_handler+0xb4>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
10000284:	e0bffe17 	ldw	r2,-8(fp)
10000288:	1085883a 	add	r2,r2,r2
1000028c:	e0bffe15 	stw	r2,-8(fp)
      i++;
10000290:	e0bffd17 	ldw	r2,-12(fp)
10000294:	10800044 	addi	r2,r2,1
10000298:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
1000029c:	003fde06 	br	10000218 <alt_irq_handler+0x2c>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
100002a0:	e037883a 	mov	sp,fp
100002a4:	dfc00117 	ldw	ra,4(sp)
100002a8:	df000017 	ldw	fp,0(sp)
100002ac:	dec00204 	addi	sp,sp,8
100002b0:	f800283a 	ret

Disassembly of section .text:

100002b4 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
100002b4:	00a00014 	movui	r2,32768
#endif

0:
    initd 0(r2)
100002b8:	10000033 	initd	0(r2)
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
100002bc:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
100002c0:	00bffd16 	blt	zero,r2,100002b8 <_start+0x4>
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
100002c4:	06c48034 	movhi	sp,4608
    ori sp, sp, %lo(__alt_stack_pointer)
100002c8:	dec00014 	ori	sp,sp,0

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
100002cc:	06840074 	movhi	gp,4097
    ori gp, gp, %lo(_gp)
100002d0:	d68a0e14 	ori	gp,gp,10296
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
100002d4:	00840034 	movhi	r2,4096
    ori r2, r2, %lo(__bss_start)
100002d8:	10aa2014 	ori	r2,r2,43136

    movhi r3, %hi(__bss_end)
100002dc:	00c40034 	movhi	r3,4096
    ori r3, r3, %lo(__bss_end)
100002e0:	18ead814 	ori	r3,r3,43872

    beq r2, r3, 1f
100002e4:	10c00326 	beq	r2,r3,100002f4 <_start+0x40>

0:
    stw zero, (r2)
100002e8:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
100002ec:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
100002f0:	10fffd36 	bltu	r2,r3,100002e8 <_start+0x34>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
100002f4:	000316c0 	call	1000316c <alt_main>

100002f8 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
100002f8:	003fff06 	br	100002f8 <alt_after_alt_main>

100002fc <main>:
 */

#include <stdio.h>

int main()
{
100002fc:	defffe04 	addi	sp,sp,-8
10000300:	dfc00115 	stw	ra,4(sp)
10000304:	df000015 	stw	fp,0(sp)
10000308:	d839883a 	mov	fp,sp
  printf("Hello from Nios II!\n");
1000030c:	01040074 	movhi	r4,4097
10000310:	21230a04 	addi	r4,r4,-29656
10000314:	00003d00 	call	100003d0 <puts>

  return 0;
10000318:	0005883a 	mov	r2,zero
}
1000031c:	e037883a 	mov	sp,fp
10000320:	dfc00117 	ldw	ra,4(sp)
10000324:	df000017 	ldw	fp,0(sp)
10000328:	dec00204 	addi	sp,sp,8
1000032c:	f800283a 	ret

10000330 <_puts_r>:
10000330:	defff604 	addi	sp,sp,-40
10000334:	dc400715 	stw	r17,28(sp)
10000338:	2023883a 	mov	r17,r4
1000033c:	2809883a 	mov	r4,r5
10000340:	dfc00915 	stw	ra,36(sp)
10000344:	dcc00815 	stw	r19,32(sp)
10000348:	2827883a 	mov	r19,r5
1000034c:	00003e40 	call	100003e4 <strlen>
10000350:	89400217 	ldw	r5,8(r17)
10000354:	00c40074 	movhi	r3,4097
10000358:	18e30f04 	addi	r3,r3,-29636
1000035c:	01c00044 	movi	r7,1
10000360:	12000044 	addi	r8,r2,1
10000364:	d8c00515 	stw	r3,20(sp)
10000368:	d9c00615 	stw	r7,24(sp)
1000036c:	d8c00304 	addi	r3,sp,12
10000370:	01c00084 	movi	r7,2
10000374:	8809883a 	mov	r4,r17
10000378:	d80d883a 	mov	r6,sp
1000037c:	d8c00015 	stw	r3,0(sp)
10000380:	dcc00315 	stw	r19,12(sp)
10000384:	da000215 	stw	r8,8(sp)
10000388:	d9c00115 	stw	r7,4(sp)
1000038c:	d8800415 	stw	r2,16(sp)
10000390:	00004580 	call	10000458 <__sfvwrite_r>
10000394:	00ffffc4 	movi	r3,-1
10000398:	10000626 	beq	r2,zero,100003b4 <_puts_r+0x84>
1000039c:	1805883a 	mov	r2,r3
100003a0:	dfc00917 	ldw	ra,36(sp)
100003a4:	dcc00817 	ldw	r19,32(sp)
100003a8:	dc400717 	ldw	r17,28(sp)
100003ac:	dec00a04 	addi	sp,sp,40
100003b0:	f800283a 	ret
100003b4:	00c00284 	movi	r3,10
100003b8:	1805883a 	mov	r2,r3
100003bc:	dfc00917 	ldw	ra,36(sp)
100003c0:	dcc00817 	ldw	r19,32(sp)
100003c4:	dc400717 	ldw	r17,28(sp)
100003c8:	dec00a04 	addi	sp,sp,40
100003cc:	f800283a 	ret

100003d0 <puts>:
100003d0:	00840074 	movhi	r2,4097
100003d4:	10aa0e04 	addi	r2,r2,-22472
100003d8:	200b883a 	mov	r5,r4
100003dc:	11000017 	ldw	r4,0(r2)
100003e0:	00003301 	jmpi	10000330 <_puts_r>

100003e4 <strlen>:
100003e4:	208000cc 	andi	r2,r4,3
100003e8:	2011883a 	mov	r8,r4
100003ec:	1000161e 	bne	r2,zero,10000448 <strlen+0x64>
100003f0:	20c00017 	ldw	r3,0(r4)
100003f4:	017fbff4 	movhi	r5,65279
100003f8:	297fbfc4 	addi	r5,r5,-257
100003fc:	01e02074 	movhi	r7,32897
10000400:	39e02004 	addi	r7,r7,-32640
10000404:	1945883a 	add	r2,r3,r5
10000408:	11c4703a 	and	r2,r2,r7
1000040c:	00c6303a 	nor	r3,zero,r3
10000410:	1886703a 	and	r3,r3,r2
10000414:	18000c1e 	bne	r3,zero,10000448 <strlen+0x64>
10000418:	280d883a 	mov	r6,r5
1000041c:	380b883a 	mov	r5,r7
10000420:	21000104 	addi	r4,r4,4
10000424:	20800017 	ldw	r2,0(r4)
10000428:	1187883a 	add	r3,r2,r6
1000042c:	1946703a 	and	r3,r3,r5
10000430:	0084303a 	nor	r2,zero,r2
10000434:	10c4703a 	and	r2,r2,r3
10000438:	103ff926 	beq	r2,zero,10000420 <strlen+0x3c>
1000043c:	20800007 	ldb	r2,0(r4)
10000440:	10000326 	beq	r2,zero,10000450 <strlen+0x6c>
10000444:	21000044 	addi	r4,r4,1
10000448:	20800007 	ldb	r2,0(r4)
1000044c:	103ffd1e 	bne	r2,zero,10000444 <strlen+0x60>
10000450:	2205c83a 	sub	r2,r4,r8
10000454:	f800283a 	ret

10000458 <__sfvwrite_r>:
10000458:	30800217 	ldw	r2,8(r6)
1000045c:	defff504 	addi	sp,sp,-44
10000460:	df000915 	stw	fp,36(sp)
10000464:	dd800715 	stw	r22,28(sp)
10000468:	dc800315 	stw	r18,12(sp)
1000046c:	dfc00a15 	stw	ra,40(sp)
10000470:	ddc00815 	stw	r23,32(sp)
10000474:	dd400615 	stw	r21,24(sp)
10000478:	dd000515 	stw	r20,20(sp)
1000047c:	dcc00415 	stw	r19,16(sp)
10000480:	dc400215 	stw	r17,8(sp)
10000484:	dc000115 	stw	r16,4(sp)
10000488:	302d883a 	mov	r22,r6
1000048c:	2039883a 	mov	fp,r4
10000490:	2825883a 	mov	r18,r5
10000494:	10001c26 	beq	r2,zero,10000508 <__sfvwrite_r+0xb0>
10000498:	29c0030b 	ldhu	r7,12(r5)
1000049c:	3880020c 	andi	r2,r7,8
100004a0:	10002726 	beq	r2,zero,10000540 <__sfvwrite_r+0xe8>
100004a4:	28800417 	ldw	r2,16(r5)
100004a8:	10002526 	beq	r2,zero,10000540 <__sfvwrite_r+0xe8>
100004ac:	3880008c 	andi	r2,r7,2
100004b0:	b5400017 	ldw	r21,0(r22)
100004b4:	10002826 	beq	r2,zero,10000558 <__sfvwrite_r+0x100>
100004b8:	0021883a 	mov	r16,zero
100004bc:	0023883a 	mov	r17,zero
100004c0:	880d883a 	mov	r6,r17
100004c4:	e009883a 	mov	r4,fp
100004c8:	00810004 	movi	r2,1024
100004cc:	80006e26 	beq	r16,zero,10000688 <__sfvwrite_r+0x230>
100004d0:	800f883a 	mov	r7,r16
100004d4:	91400717 	ldw	r5,28(r18)
100004d8:	1400012e 	bgeu	r2,r16,100004e0 <__sfvwrite_r+0x88>
100004dc:	100f883a 	mov	r7,r2
100004e0:	90c00917 	ldw	r3,36(r18)
100004e4:	183ee83a 	callr	r3
100004e8:	1007883a 	mov	r3,r2
100004ec:	80a1c83a 	sub	r16,r16,r2
100004f0:	88a3883a 	add	r17,r17,r2
100004f4:	00806d0e 	bge	zero,r2,100006ac <__sfvwrite_r+0x254>
100004f8:	b0800217 	ldw	r2,8(r22)
100004fc:	10c5c83a 	sub	r2,r2,r3
10000500:	b0800215 	stw	r2,8(r22)
10000504:	103fee1e 	bne	r2,zero,100004c0 <__sfvwrite_r+0x68>
10000508:	0009883a 	mov	r4,zero
1000050c:	2005883a 	mov	r2,r4
10000510:	dfc00a17 	ldw	ra,40(sp)
10000514:	df000917 	ldw	fp,36(sp)
10000518:	ddc00817 	ldw	r23,32(sp)
1000051c:	dd800717 	ldw	r22,28(sp)
10000520:	dd400617 	ldw	r21,24(sp)
10000524:	dd000517 	ldw	r20,20(sp)
10000528:	dcc00417 	ldw	r19,16(sp)
1000052c:	dc800317 	ldw	r18,12(sp)
10000530:	dc400217 	ldw	r17,8(sp)
10000534:	dc000117 	ldw	r16,4(sp)
10000538:	dec00b04 	addi	sp,sp,44
1000053c:	f800283a 	ret
10000540:	00018fc0 	call	100018fc <__swsetup_r>
10000544:	1000e41e 	bne	r2,zero,100008d8 <__sfvwrite_r+0x480>
10000548:	91c0030b 	ldhu	r7,12(r18)
1000054c:	b5400017 	ldw	r21,0(r22)
10000550:	3880008c 	andi	r2,r7,2
10000554:	103fd81e 	bne	r2,zero,100004b8 <__sfvwrite_r+0x60>
10000558:	3880004c 	andi	r2,r7,1
1000055c:	1005003a 	cmpeq	r2,r2,zero
10000560:	10005726 	beq	r2,zero,100006c0 <__sfvwrite_r+0x268>
10000564:	0029883a 	mov	r20,zero
10000568:	002f883a 	mov	r23,zero
1000056c:	a0004226 	beq	r20,zero,10000678 <__sfvwrite_r+0x220>
10000570:	3880800c 	andi	r2,r7,512
10000574:	94000217 	ldw	r16,8(r18)
10000578:	10008b26 	beq	r2,zero,100007a8 <__sfvwrite_r+0x350>
1000057c:	800d883a 	mov	r6,r16
10000580:	a400a536 	bltu	r20,r16,10000818 <__sfvwrite_r+0x3c0>
10000584:	3881200c 	andi	r2,r7,1152
10000588:	10002726 	beq	r2,zero,10000628 <__sfvwrite_r+0x1d0>
1000058c:	90800517 	ldw	r2,20(r18)
10000590:	92000417 	ldw	r8,16(r18)
10000594:	91400017 	ldw	r5,0(r18)
10000598:	1087883a 	add	r3,r2,r2
1000059c:	1887883a 	add	r3,r3,r2
100005a0:	1808d7fa 	srli	r4,r3,31
100005a4:	2a21c83a 	sub	r16,r5,r8
100005a8:	80800044 	addi	r2,r16,1
100005ac:	20c9883a 	add	r4,r4,r3
100005b0:	2027d07a 	srai	r19,r4,1
100005b4:	a085883a 	add	r2,r20,r2
100005b8:	980d883a 	mov	r6,r19
100005bc:	9880022e 	bgeu	r19,r2,100005c8 <__sfvwrite_r+0x170>
100005c0:	1027883a 	mov	r19,r2
100005c4:	100d883a 	mov	r6,r2
100005c8:	3881000c 	andi	r2,r7,1024
100005cc:	1000b826 	beq	r2,zero,100008b0 <__sfvwrite_r+0x458>
100005d0:	300b883a 	mov	r5,r6
100005d4:	e009883a 	mov	r4,fp
100005d8:	00008f40 	call	100008f4 <_malloc_r>
100005dc:	10003126 	beq	r2,zero,100006a4 <__sfvwrite_r+0x24c>
100005e0:	91400417 	ldw	r5,16(r18)
100005e4:	1009883a 	mov	r4,r2
100005e8:	800d883a 	mov	r6,r16
100005ec:	1023883a 	mov	r17,r2
100005f0:	00011180 	call	10001118 <memcpy>
100005f4:	90c0030b 	ldhu	r3,12(r18)
100005f8:	00beffc4 	movi	r2,-1025
100005fc:	1886703a 	and	r3,r3,r2
10000600:	18c02014 	ori	r3,r3,128
10000604:	90c0030d 	sth	r3,12(r18)
10000608:	9c07c83a 	sub	r3,r19,r16
1000060c:	8c05883a 	add	r2,r17,r16
10000610:	a00d883a 	mov	r6,r20
10000614:	a021883a 	mov	r16,r20
10000618:	90800015 	stw	r2,0(r18)
1000061c:	90c00215 	stw	r3,8(r18)
10000620:	94400415 	stw	r17,16(r18)
10000624:	94c00515 	stw	r19,20(r18)
10000628:	91000017 	ldw	r4,0(r18)
1000062c:	b80b883a 	mov	r5,r23
10000630:	a023883a 	mov	r17,r20
10000634:	00011b80 	call	100011b8 <memmove>
10000638:	90c00217 	ldw	r3,8(r18)
1000063c:	90800017 	ldw	r2,0(r18)
10000640:	a027883a 	mov	r19,r20
10000644:	1c07c83a 	sub	r3,r3,r16
10000648:	1405883a 	add	r2,r2,r16
1000064c:	90c00215 	stw	r3,8(r18)
10000650:	a021883a 	mov	r16,r20
10000654:	90800015 	stw	r2,0(r18)
10000658:	b0800217 	ldw	r2,8(r22)
1000065c:	1405c83a 	sub	r2,r2,r16
10000660:	b0800215 	stw	r2,8(r22)
10000664:	103fa826 	beq	r2,zero,10000508 <__sfvwrite_r+0xb0>
10000668:	a469c83a 	sub	r20,r20,r17
1000066c:	91c0030b 	ldhu	r7,12(r18)
10000670:	bcef883a 	add	r23,r23,r19
10000674:	a03fbe1e 	bne	r20,zero,10000570 <__sfvwrite_r+0x118>
10000678:	adc00017 	ldw	r23,0(r21)
1000067c:	ad000117 	ldw	r20,4(r21)
10000680:	ad400204 	addi	r21,r21,8
10000684:	003fb906 	br	1000056c <__sfvwrite_r+0x114>
10000688:	ac400017 	ldw	r17,0(r21)
1000068c:	ac000117 	ldw	r16,4(r21)
10000690:	ad400204 	addi	r21,r21,8
10000694:	003f8a06 	br	100004c0 <__sfvwrite_r+0x68>
10000698:	91400417 	ldw	r5,16(r18)
1000069c:	e009883a 	mov	r4,fp
100006a0:	00020540 	call	10002054 <_free_r>
100006a4:	00800304 	movi	r2,12
100006a8:	e0800015 	stw	r2,0(fp)
100006ac:	9080030b 	ldhu	r2,12(r18)
100006b0:	013fffc4 	movi	r4,-1
100006b4:	10801014 	ori	r2,r2,64
100006b8:	9080030d 	sth	r2,12(r18)
100006bc:	003f9306 	br	1000050c <__sfvwrite_r+0xb4>
100006c0:	0027883a 	mov	r19,zero
100006c4:	002f883a 	mov	r23,zero
100006c8:	d8000015 	stw	zero,0(sp)
100006cc:	0029883a 	mov	r20,zero
100006d0:	98001e26 	beq	r19,zero,1000074c <__sfvwrite_r+0x2f4>
100006d4:	d8c00017 	ldw	r3,0(sp)
100006d8:	1804c03a 	cmpne	r2,r3,zero
100006dc:	10005e26 	beq	r2,zero,10000858 <__sfvwrite_r+0x400>
100006e0:	9821883a 	mov	r16,r19
100006e4:	a4c0012e 	bgeu	r20,r19,100006ec <__sfvwrite_r+0x294>
100006e8:	a021883a 	mov	r16,r20
100006ec:	91000017 	ldw	r4,0(r18)
100006f0:	90800417 	ldw	r2,16(r18)
100006f4:	91800217 	ldw	r6,8(r18)
100006f8:	91c00517 	ldw	r7,20(r18)
100006fc:	1100022e 	bgeu	r2,r4,10000708 <__sfvwrite_r+0x2b0>
10000700:	31e3883a 	add	r17,r6,r7
10000704:	8c001616 	blt	r17,r16,10000760 <__sfvwrite_r+0x308>
10000708:	81c03816 	blt	r16,r7,100007ec <__sfvwrite_r+0x394>
1000070c:	90c00917 	ldw	r3,36(r18)
10000710:	91400717 	ldw	r5,28(r18)
10000714:	e009883a 	mov	r4,fp
10000718:	b80d883a 	mov	r6,r23
1000071c:	183ee83a 	callr	r3
10000720:	1023883a 	mov	r17,r2
10000724:	00bfe10e 	bge	zero,r2,100006ac <__sfvwrite_r+0x254>
10000728:	a469c83a 	sub	r20,r20,r17
1000072c:	a0001826 	beq	r20,zero,10000790 <__sfvwrite_r+0x338>
10000730:	b0800217 	ldw	r2,8(r22)
10000734:	1445c83a 	sub	r2,r2,r17
10000738:	b0800215 	stw	r2,8(r22)
1000073c:	103f7226 	beq	r2,zero,10000508 <__sfvwrite_r+0xb0>
10000740:	9c67c83a 	sub	r19,r19,r17
10000744:	bc6f883a 	add	r23,r23,r17
10000748:	983fe21e 	bne	r19,zero,100006d4 <__sfvwrite_r+0x27c>
1000074c:	adc00017 	ldw	r23,0(r21)
10000750:	acc00117 	ldw	r19,4(r21)
10000754:	ad400204 	addi	r21,r21,8
10000758:	d8000015 	stw	zero,0(sp)
1000075c:	003fdc06 	br	100006d0 <__sfvwrite_r+0x278>
10000760:	b80b883a 	mov	r5,r23
10000764:	880d883a 	mov	r6,r17
10000768:	00011b80 	call	100011b8 <memmove>
1000076c:	90c00017 	ldw	r3,0(r18)
10000770:	e009883a 	mov	r4,fp
10000774:	900b883a 	mov	r5,r18
10000778:	1c47883a 	add	r3,r3,r17
1000077c:	90c00015 	stw	r3,0(r18)
10000780:	0001a380 	call	10001a38 <_fflush_r>
10000784:	103fc91e 	bne	r2,zero,100006ac <__sfvwrite_r+0x254>
10000788:	a469c83a 	sub	r20,r20,r17
1000078c:	a03fe81e 	bne	r20,zero,10000730 <__sfvwrite_r+0x2d8>
10000790:	e009883a 	mov	r4,fp
10000794:	900b883a 	mov	r5,r18
10000798:	0001a380 	call	10001a38 <_fflush_r>
1000079c:	103fc31e 	bne	r2,zero,100006ac <__sfvwrite_r+0x254>
100007a0:	d8000015 	stw	zero,0(sp)
100007a4:	003fe206 	br	10000730 <__sfvwrite_r+0x2d8>
100007a8:	91000017 	ldw	r4,0(r18)
100007ac:	90800417 	ldw	r2,16(r18)
100007b0:	1100022e 	bgeu	r2,r4,100007bc <__sfvwrite_r+0x364>
100007b4:	8023883a 	mov	r17,r16
100007b8:	85003136 	bltu	r16,r20,10000880 <__sfvwrite_r+0x428>
100007bc:	91c00517 	ldw	r7,20(r18)
100007c0:	a1c01836 	bltu	r20,r7,10000824 <__sfvwrite_r+0x3cc>
100007c4:	90c00917 	ldw	r3,36(r18)
100007c8:	91400717 	ldw	r5,28(r18)
100007cc:	e009883a 	mov	r4,fp
100007d0:	b80d883a 	mov	r6,r23
100007d4:	183ee83a 	callr	r3
100007d8:	1021883a 	mov	r16,r2
100007dc:	00bfb30e 	bge	zero,r2,100006ac <__sfvwrite_r+0x254>
100007e0:	1023883a 	mov	r17,r2
100007e4:	1027883a 	mov	r19,r2
100007e8:	003f9b06 	br	10000658 <__sfvwrite_r+0x200>
100007ec:	b80b883a 	mov	r5,r23
100007f0:	800d883a 	mov	r6,r16
100007f4:	00011b80 	call	100011b8 <memmove>
100007f8:	90c00217 	ldw	r3,8(r18)
100007fc:	90800017 	ldw	r2,0(r18)
10000800:	8023883a 	mov	r17,r16
10000804:	1c07c83a 	sub	r3,r3,r16
10000808:	1405883a 	add	r2,r2,r16
1000080c:	90c00215 	stw	r3,8(r18)
10000810:	90800015 	stw	r2,0(r18)
10000814:	003fc406 	br	10000728 <__sfvwrite_r+0x2d0>
10000818:	a00d883a 	mov	r6,r20
1000081c:	a021883a 	mov	r16,r20
10000820:	003f8106 	br	10000628 <__sfvwrite_r+0x1d0>
10000824:	b80b883a 	mov	r5,r23
10000828:	a00d883a 	mov	r6,r20
1000082c:	00011b80 	call	100011b8 <memmove>
10000830:	90c00217 	ldw	r3,8(r18)
10000834:	90800017 	ldw	r2,0(r18)
10000838:	a021883a 	mov	r16,r20
1000083c:	1d07c83a 	sub	r3,r3,r20
10000840:	1505883a 	add	r2,r2,r20
10000844:	a023883a 	mov	r17,r20
10000848:	a027883a 	mov	r19,r20
1000084c:	90c00215 	stw	r3,8(r18)
10000850:	90800015 	stw	r2,0(r18)
10000854:	003f8006 	br	10000658 <__sfvwrite_r+0x200>
10000858:	b809883a 	mov	r4,r23
1000085c:	01400284 	movi	r5,10
10000860:	980d883a 	mov	r6,r19
10000864:	00010340 	call	10001034 <memchr>
10000868:	10001726 	beq	r2,zero,100008c8 <__sfvwrite_r+0x470>
1000086c:	15c5c83a 	sub	r2,r2,r23
10000870:	15000044 	addi	r20,r2,1
10000874:	00800044 	movi	r2,1
10000878:	d8800015 	stw	r2,0(sp)
1000087c:	003f9806 	br	100006e0 <__sfvwrite_r+0x288>
10000880:	b80b883a 	mov	r5,r23
10000884:	800d883a 	mov	r6,r16
10000888:	00011b80 	call	100011b8 <memmove>
1000088c:	90c00017 	ldw	r3,0(r18)
10000890:	e009883a 	mov	r4,fp
10000894:	900b883a 	mov	r5,r18
10000898:	1c07883a 	add	r3,r3,r16
1000089c:	90c00015 	stw	r3,0(r18)
100008a0:	8027883a 	mov	r19,r16
100008a4:	0001a380 	call	10001a38 <_fflush_r>
100008a8:	103f6b26 	beq	r2,zero,10000658 <__sfvwrite_r+0x200>
100008ac:	003f7f06 	br	100006ac <__sfvwrite_r+0x254>
100008b0:	400b883a 	mov	r5,r8
100008b4:	e009883a 	mov	r4,fp
100008b8:	00012980 	call	10001298 <_realloc_r>
100008bc:	103f7626 	beq	r2,zero,10000698 <__sfvwrite_r+0x240>
100008c0:	1023883a 	mov	r17,r2
100008c4:	003f5006 	br	10000608 <__sfvwrite_r+0x1b0>
100008c8:	00c00044 	movi	r3,1
100008cc:	9d000044 	addi	r20,r19,1
100008d0:	d8c00015 	stw	r3,0(sp)
100008d4:	003f8206 	br	100006e0 <__sfvwrite_r+0x288>
100008d8:	9080030b 	ldhu	r2,12(r18)
100008dc:	00c00244 	movi	r3,9
100008e0:	013fffc4 	movi	r4,-1
100008e4:	10801014 	ori	r2,r2,64
100008e8:	9080030d 	sth	r2,12(r18)
100008ec:	e0c00015 	stw	r3,0(fp)
100008f0:	003f0606 	br	1000050c <__sfvwrite_r+0xb4>

100008f4 <_malloc_r>:
100008f4:	defff604 	addi	sp,sp,-40
100008f8:	28c002c4 	addi	r3,r5,11
100008fc:	00800584 	movi	r2,22
10000900:	dc800215 	stw	r18,8(sp)
10000904:	dfc00915 	stw	ra,36(sp)
10000908:	df000815 	stw	fp,32(sp)
1000090c:	ddc00715 	stw	r23,28(sp)
10000910:	dd800615 	stw	r22,24(sp)
10000914:	dd400515 	stw	r21,20(sp)
10000918:	dd000415 	stw	r20,16(sp)
1000091c:	dcc00315 	stw	r19,12(sp)
10000920:	dc400115 	stw	r17,4(sp)
10000924:	dc000015 	stw	r16,0(sp)
10000928:	2025883a 	mov	r18,r4
1000092c:	10c01236 	bltu	r2,r3,10000978 <_malloc_r+0x84>
10000930:	04400404 	movi	r17,16
10000934:	8940142e 	bgeu	r17,r5,10000988 <_malloc_r+0x94>
10000938:	00800304 	movi	r2,12
1000093c:	0007883a 	mov	r3,zero
10000940:	90800015 	stw	r2,0(r18)
10000944:	1805883a 	mov	r2,r3
10000948:	dfc00917 	ldw	ra,36(sp)
1000094c:	df000817 	ldw	fp,32(sp)
10000950:	ddc00717 	ldw	r23,28(sp)
10000954:	dd800617 	ldw	r22,24(sp)
10000958:	dd400517 	ldw	r21,20(sp)
1000095c:	dd000417 	ldw	r20,16(sp)
10000960:	dcc00317 	ldw	r19,12(sp)
10000964:	dc800217 	ldw	r18,8(sp)
10000968:	dc400117 	ldw	r17,4(sp)
1000096c:	dc000017 	ldw	r16,0(sp)
10000970:	dec00a04 	addi	sp,sp,40
10000974:	f800283a 	ret
10000978:	00bffe04 	movi	r2,-8
1000097c:	18a2703a 	and	r17,r3,r2
10000980:	883fed16 	blt	r17,zero,10000938 <_malloc_r+0x44>
10000984:	897fec36 	bltu	r17,r5,10000938 <_malloc_r+0x44>
10000988:	9009883a 	mov	r4,r18
1000098c:	00031d80 	call	100031d8 <__malloc_lock>
10000990:	00807dc4 	movi	r2,503
10000994:	14402b2e 	bgeu	r2,r17,10000a44 <_malloc_r+0x150>
10000998:	8806d27a 	srli	r3,r17,9
1000099c:	18003f1e 	bne	r3,zero,10000a9c <_malloc_r+0x1a8>
100009a0:	880cd0fa 	srli	r6,r17,3
100009a4:	300490fa 	slli	r2,r6,3
100009a8:	02c40074 	movhi	r11,4097
100009ac:	5ae43c04 	addi	r11,r11,-28432
100009b0:	12cb883a 	add	r5,r2,r11
100009b4:	2c000317 	ldw	r16,12(r5)
100009b8:	580f883a 	mov	r7,r11
100009bc:	2c00041e 	bne	r5,r16,100009d0 <_malloc_r+0xdc>
100009c0:	00000a06 	br	100009ec <_malloc_r+0xf8>
100009c4:	1800860e 	bge	r3,zero,10000be0 <_malloc_r+0x2ec>
100009c8:	84000317 	ldw	r16,12(r16)
100009cc:	2c000726 	beq	r5,r16,100009ec <_malloc_r+0xf8>
100009d0:	80800117 	ldw	r2,4(r16)
100009d4:	00ffff04 	movi	r3,-4
100009d8:	10c8703a 	and	r4,r2,r3
100009dc:	2447c83a 	sub	r3,r4,r17
100009e0:	008003c4 	movi	r2,15
100009e4:	10fff70e 	bge	r2,r3,100009c4 <_malloc_r+0xd0>
100009e8:	31bfffc4 	addi	r6,r6,-1
100009ec:	32400044 	addi	r9,r6,1
100009f0:	02840074 	movhi	r10,4097
100009f4:	52a43e04 	addi	r10,r10,-28424
100009f8:	54000217 	ldw	r16,8(r10)
100009fc:	8280a026 	beq	r16,r10,10000c80 <_malloc_r+0x38c>
10000a00:	80800117 	ldw	r2,4(r16)
10000a04:	00ffff04 	movi	r3,-4
10000a08:	10ca703a 	and	r5,r2,r3
10000a0c:	2c4dc83a 	sub	r6,r5,r17
10000a10:	008003c4 	movi	r2,15
10000a14:	11808316 	blt	r2,r6,10000c24 <_malloc_r+0x330>
10000a18:	52800315 	stw	r10,12(r10)
10000a1c:	52800215 	stw	r10,8(r10)
10000a20:	30002916 	blt	r6,zero,10000ac8 <_malloc_r+0x1d4>
10000a24:	8147883a 	add	r3,r16,r5
10000a28:	18800117 	ldw	r2,4(r3)
10000a2c:	9009883a 	mov	r4,r18
10000a30:	10800054 	ori	r2,r2,1
10000a34:	18800115 	stw	r2,4(r3)
10000a38:	00031f80 	call	100031f8 <__malloc_unlock>
10000a3c:	80c00204 	addi	r3,r16,8
10000a40:	003fc006 	br	10000944 <_malloc_r+0x50>
10000a44:	02c40074 	movhi	r11,4097
10000a48:	5ae43c04 	addi	r11,r11,-28432
10000a4c:	8ac5883a 	add	r2,r17,r11
10000a50:	14000317 	ldw	r16,12(r2)
10000a54:	580f883a 	mov	r7,r11
10000a58:	8806d0fa 	srli	r3,r17,3
10000a5c:	14006c26 	beq	r2,r16,10000c10 <_malloc_r+0x31c>
10000a60:	80c00117 	ldw	r3,4(r16)
10000a64:	00bfff04 	movi	r2,-4
10000a68:	81800317 	ldw	r6,12(r16)
10000a6c:	1886703a 	and	r3,r3,r2
10000a70:	80c7883a 	add	r3,r16,r3
10000a74:	18800117 	ldw	r2,4(r3)
10000a78:	81400217 	ldw	r5,8(r16)
10000a7c:	9009883a 	mov	r4,r18
10000a80:	10800054 	ori	r2,r2,1
10000a84:	18800115 	stw	r2,4(r3)
10000a88:	31400215 	stw	r5,8(r6)
10000a8c:	29800315 	stw	r6,12(r5)
10000a90:	00031f80 	call	100031f8 <__malloc_unlock>
10000a94:	80c00204 	addi	r3,r16,8
10000a98:	003faa06 	br	10000944 <_malloc_r+0x50>
10000a9c:	00800104 	movi	r2,4
10000aa0:	10c0052e 	bgeu	r2,r3,10000ab8 <_malloc_r+0x1c4>
10000aa4:	00800504 	movi	r2,20
10000aa8:	10c07836 	bltu	r2,r3,10000c8c <_malloc_r+0x398>
10000aac:	198016c4 	addi	r6,r3,91
10000ab0:	300490fa 	slli	r2,r6,3
10000ab4:	003fbc06 	br	100009a8 <_malloc_r+0xb4>
10000ab8:	8804d1ba 	srli	r2,r17,6
10000abc:	11800e04 	addi	r6,r2,56
10000ac0:	300490fa 	slli	r2,r6,3
10000ac4:	003fb806 	br	100009a8 <_malloc_r+0xb4>
10000ac8:	00807fc4 	movi	r2,511
10000acc:	1140bb36 	bltu	r2,r5,10000dbc <_malloc_r+0x4c8>
10000ad0:	2806d0fa 	srli	r3,r5,3
10000ad4:	573ffe04 	addi	fp,r10,-8
10000ad8:	00800044 	movi	r2,1
10000adc:	180890fa 	slli	r4,r3,3
10000ae0:	1807d0ba 	srai	r3,r3,2
10000ae4:	e1c00117 	ldw	r7,4(fp)
10000ae8:	5909883a 	add	r4,r11,r4
10000aec:	21400217 	ldw	r5,8(r4)
10000af0:	10c4983a 	sll	r2,r2,r3
10000af4:	81000315 	stw	r4,12(r16)
10000af8:	81400215 	stw	r5,8(r16)
10000afc:	388eb03a 	or	r7,r7,r2
10000b00:	2c000315 	stw	r16,12(r5)
10000b04:	24000215 	stw	r16,8(r4)
10000b08:	e1c00115 	stw	r7,4(fp)
10000b0c:	4807883a 	mov	r3,r9
10000b10:	4800cd16 	blt	r9,zero,10000e48 <_malloc_r+0x554>
10000b14:	1807d0ba 	srai	r3,r3,2
10000b18:	00800044 	movi	r2,1
10000b1c:	10c8983a 	sll	r4,r2,r3
10000b20:	39004436 	bltu	r7,r4,10000c34 <_malloc_r+0x340>
10000b24:	21c4703a 	and	r2,r4,r7
10000b28:	10000a1e 	bne	r2,zero,10000b54 <_malloc_r+0x260>
10000b2c:	2109883a 	add	r4,r4,r4
10000b30:	00bfff04 	movi	r2,-4
10000b34:	4884703a 	and	r2,r9,r2
10000b38:	3906703a 	and	r3,r7,r4
10000b3c:	12400104 	addi	r9,r2,4
10000b40:	1800041e 	bne	r3,zero,10000b54 <_malloc_r+0x260>
10000b44:	2109883a 	add	r4,r4,r4
10000b48:	3904703a 	and	r2,r7,r4
10000b4c:	4a400104 	addi	r9,r9,4
10000b50:	103ffc26 	beq	r2,zero,10000b44 <_malloc_r+0x250>
10000b54:	480490fa 	slli	r2,r9,3
10000b58:	4819883a 	mov	r12,r9
10000b5c:	023fff04 	movi	r8,-4
10000b60:	589b883a 	add	r13,r11,r2
10000b64:	6807883a 	mov	r3,r13
10000b68:	014003c4 	movi	r5,15
10000b6c:	1c000317 	ldw	r16,12(r3)
10000b70:	1c00041e 	bne	r3,r16,10000b84 <_malloc_r+0x290>
10000b74:	0000a706 	br	10000e14 <_malloc_r+0x520>
10000b78:	3000ab0e 	bge	r6,zero,10000e28 <_malloc_r+0x534>
10000b7c:	84000317 	ldw	r16,12(r16)
10000b80:	1c00a426 	beq	r3,r16,10000e14 <_malloc_r+0x520>
10000b84:	80800117 	ldw	r2,4(r16)
10000b88:	1204703a 	and	r2,r2,r8
10000b8c:	144dc83a 	sub	r6,r2,r17
10000b90:	29bff90e 	bge	r5,r6,10000b78 <_malloc_r+0x284>
10000b94:	81000317 	ldw	r4,12(r16)
10000b98:	80c00217 	ldw	r3,8(r16)
10000b9c:	89400054 	ori	r5,r17,1
10000ba0:	8445883a 	add	r2,r16,r17
10000ba4:	20c00215 	stw	r3,8(r4)
10000ba8:	19000315 	stw	r4,12(r3)
10000bac:	81400115 	stw	r5,4(r16)
10000bb0:	1187883a 	add	r3,r2,r6
10000bb4:	31000054 	ori	r4,r6,1
10000bb8:	50800315 	stw	r2,12(r10)
10000bbc:	50800215 	stw	r2,8(r10)
10000bc0:	19800015 	stw	r6,0(r3)
10000bc4:	11000115 	stw	r4,4(r2)
10000bc8:	12800215 	stw	r10,8(r2)
10000bcc:	12800315 	stw	r10,12(r2)
10000bd0:	9009883a 	mov	r4,r18
10000bd4:	00031f80 	call	100031f8 <__malloc_unlock>
10000bd8:	80c00204 	addi	r3,r16,8
10000bdc:	003f5906 	br	10000944 <_malloc_r+0x50>
10000be0:	8109883a 	add	r4,r16,r4
10000be4:	20800117 	ldw	r2,4(r4)
10000be8:	80c00217 	ldw	r3,8(r16)
10000bec:	81400317 	ldw	r5,12(r16)
10000bf0:	10800054 	ori	r2,r2,1
10000bf4:	20800115 	stw	r2,4(r4)
10000bf8:	28c00215 	stw	r3,8(r5)
10000bfc:	19400315 	stw	r5,12(r3)
10000c00:	9009883a 	mov	r4,r18
10000c04:	00031f80 	call	100031f8 <__malloc_unlock>
10000c08:	80c00204 	addi	r3,r16,8
10000c0c:	003f4d06 	br	10000944 <_malloc_r+0x50>
10000c10:	80800204 	addi	r2,r16,8
10000c14:	14000317 	ldw	r16,12(r2)
10000c18:	143f911e 	bne	r2,r16,10000a60 <_malloc_r+0x16c>
10000c1c:	1a400084 	addi	r9,r3,2
10000c20:	003f7306 	br	100009f0 <_malloc_r+0xfc>
10000c24:	88c00054 	ori	r3,r17,1
10000c28:	8445883a 	add	r2,r16,r17
10000c2c:	80c00115 	stw	r3,4(r16)
10000c30:	003fdf06 	br	10000bb0 <_malloc_r+0x2bc>
10000c34:	e4000217 	ldw	r16,8(fp)
10000c38:	00bfff04 	movi	r2,-4
10000c3c:	80c00117 	ldw	r3,4(r16)
10000c40:	802d883a 	mov	r22,r16
10000c44:	18aa703a 	and	r21,r3,r2
10000c48:	ac401636 	bltu	r21,r17,10000ca4 <_malloc_r+0x3b0>
10000c4c:	ac49c83a 	sub	r4,r21,r17
10000c50:	008003c4 	movi	r2,15
10000c54:	1100130e 	bge	r2,r4,10000ca4 <_malloc_r+0x3b0>
10000c58:	88800054 	ori	r2,r17,1
10000c5c:	8447883a 	add	r3,r16,r17
10000c60:	80800115 	stw	r2,4(r16)
10000c64:	20800054 	ori	r2,r4,1
10000c68:	18800115 	stw	r2,4(r3)
10000c6c:	e0c00215 	stw	r3,8(fp)
10000c70:	9009883a 	mov	r4,r18
10000c74:	00031f80 	call	100031f8 <__malloc_unlock>
10000c78:	80c00204 	addi	r3,r16,8
10000c7c:	003f3106 	br	10000944 <_malloc_r+0x50>
10000c80:	39c00117 	ldw	r7,4(r7)
10000c84:	573ffe04 	addi	fp,r10,-8
10000c88:	003fa006 	br	10000b0c <_malloc_r+0x218>
10000c8c:	00801504 	movi	r2,84
10000c90:	10c06736 	bltu	r2,r3,10000e30 <_malloc_r+0x53c>
10000c94:	8804d33a 	srli	r2,r17,12
10000c98:	11801b84 	addi	r6,r2,110
10000c9c:	300490fa 	slli	r2,r6,3
10000ca0:	003f4106 	br	100009a8 <_malloc_r+0xb4>
10000ca4:	d0a01217 	ldw	r2,-32696(gp)
10000ca8:	d0e00317 	ldw	r3,-32756(gp)
10000cac:	053fffc4 	movi	r20,-1
10000cb0:	10800404 	addi	r2,r2,16
10000cb4:	88a7883a 	add	r19,r17,r2
10000cb8:	1d000326 	beq	r3,r20,10000cc8 <_malloc_r+0x3d4>
10000cbc:	98c3ffc4 	addi	r3,r19,4095
10000cc0:	00bc0004 	movi	r2,-4096
10000cc4:	18a6703a 	and	r19,r3,r2
10000cc8:	9009883a 	mov	r4,r18
10000ccc:	980b883a 	mov	r5,r19
10000cd0:	000188c0 	call	1000188c <_sbrk_r>
10000cd4:	1009883a 	mov	r4,r2
10000cd8:	15000426 	beq	r2,r20,10000cec <_malloc_r+0x3f8>
10000cdc:	854b883a 	add	r5,r16,r21
10000ce0:	1029883a 	mov	r20,r2
10000ce4:	11405a2e 	bgeu	r2,r5,10000e50 <_malloc_r+0x55c>
10000ce8:	87000c26 	beq	r16,fp,10000d1c <_malloc_r+0x428>
10000cec:	e4000217 	ldw	r16,8(fp)
10000cf0:	80c00117 	ldw	r3,4(r16)
10000cf4:	00bfff04 	movi	r2,-4
10000cf8:	1884703a 	and	r2,r3,r2
10000cfc:	14400336 	bltu	r2,r17,10000d0c <_malloc_r+0x418>
10000d00:	1449c83a 	sub	r4,r2,r17
10000d04:	008003c4 	movi	r2,15
10000d08:	113fd316 	blt	r2,r4,10000c58 <_malloc_r+0x364>
10000d0c:	9009883a 	mov	r4,r18
10000d10:	00031f80 	call	100031f8 <__malloc_unlock>
10000d14:	0007883a 	mov	r3,zero
10000d18:	003f0a06 	br	10000944 <_malloc_r+0x50>
10000d1c:	05c40074 	movhi	r23,4097
10000d20:	bdea2a04 	addi	r23,r23,-22360
10000d24:	b8800017 	ldw	r2,0(r23)
10000d28:	988d883a 	add	r6,r19,r2
10000d2c:	b9800015 	stw	r6,0(r23)
10000d30:	d0e00317 	ldw	r3,-32756(gp)
10000d34:	00bfffc4 	movi	r2,-1
10000d38:	18808e26 	beq	r3,r2,10000f74 <_malloc_r+0x680>
10000d3c:	2145c83a 	sub	r2,r4,r5
10000d40:	3085883a 	add	r2,r6,r2
10000d44:	b8800015 	stw	r2,0(r23)
10000d48:	20c001cc 	andi	r3,r4,7
10000d4c:	18005f1e 	bne	r3,zero,10000ecc <_malloc_r+0x5d8>
10000d50:	000b883a 	mov	r5,zero
10000d54:	a4c5883a 	add	r2,r20,r19
10000d58:	1083ffcc 	andi	r2,r2,4095
10000d5c:	00c40004 	movi	r3,4096
10000d60:	1887c83a 	sub	r3,r3,r2
10000d64:	28e7883a 	add	r19,r5,r3
10000d68:	9009883a 	mov	r4,r18
10000d6c:	980b883a 	mov	r5,r19
10000d70:	000188c0 	call	1000188c <_sbrk_r>
10000d74:	1007883a 	mov	r3,r2
10000d78:	00bfffc4 	movi	r2,-1
10000d7c:	18807a26 	beq	r3,r2,10000f68 <_malloc_r+0x674>
10000d80:	1d05c83a 	sub	r2,r3,r20
10000d84:	9885883a 	add	r2,r19,r2
10000d88:	10c00054 	ori	r3,r2,1
10000d8c:	b8800017 	ldw	r2,0(r23)
10000d90:	a021883a 	mov	r16,r20
10000d94:	a0c00115 	stw	r3,4(r20)
10000d98:	9885883a 	add	r2,r19,r2
10000d9c:	b8800015 	stw	r2,0(r23)
10000da0:	e5000215 	stw	r20,8(fp)
10000da4:	b7003626 	beq	r22,fp,10000e80 <_malloc_r+0x58c>
10000da8:	018003c4 	movi	r6,15
10000dac:	35404b36 	bltu	r6,r21,10000edc <_malloc_r+0x5e8>
10000db0:	00800044 	movi	r2,1
10000db4:	a0800115 	stw	r2,4(r20)
10000db8:	003fcd06 	br	10000cf0 <_malloc_r+0x3fc>
10000dbc:	2808d27a 	srli	r4,r5,9
10000dc0:	2000371e 	bne	r4,zero,10000ea0 <_malloc_r+0x5ac>
10000dc4:	2808d0fa 	srli	r4,r5,3
10000dc8:	200690fa 	slli	r3,r4,3
10000dcc:	1ad1883a 	add	r8,r3,r11
10000dd0:	41800217 	ldw	r6,8(r8)
10000dd4:	41805b26 	beq	r8,r6,10000f44 <_malloc_r+0x650>
10000dd8:	30800117 	ldw	r2,4(r6)
10000ddc:	00ffff04 	movi	r3,-4
10000de0:	10c4703a 	and	r2,r2,r3
10000de4:	2880022e 	bgeu	r5,r2,10000df0 <_malloc_r+0x4fc>
10000de8:	31800217 	ldw	r6,8(r6)
10000dec:	41bffa1e 	bne	r8,r6,10000dd8 <_malloc_r+0x4e4>
10000df0:	32000317 	ldw	r8,12(r6)
10000df4:	39c00117 	ldw	r7,4(r7)
10000df8:	82000315 	stw	r8,12(r16)
10000dfc:	81800215 	stw	r6,8(r16)
10000e00:	07040074 	movhi	fp,4097
10000e04:	e7243c04 	addi	fp,fp,-28432
10000e08:	34000315 	stw	r16,12(r6)
10000e0c:	44000215 	stw	r16,8(r8)
10000e10:	003f3e06 	br	10000b0c <_malloc_r+0x218>
10000e14:	63000044 	addi	r12,r12,1
10000e18:	608000cc 	andi	r2,r12,3
10000e1c:	10005d26 	beq	r2,zero,10000f94 <_malloc_r+0x6a0>
10000e20:	18c00204 	addi	r3,r3,8
10000e24:	003f5106 	br	10000b6c <_malloc_r+0x278>
10000e28:	8089883a 	add	r4,r16,r2
10000e2c:	003f6d06 	br	10000be4 <_malloc_r+0x2f0>
10000e30:	00805504 	movi	r2,340
10000e34:	10c02036 	bltu	r2,r3,10000eb8 <_malloc_r+0x5c4>
10000e38:	8804d3fa 	srli	r2,r17,15
10000e3c:	11801dc4 	addi	r6,r2,119
10000e40:	300490fa 	slli	r2,r6,3
10000e44:	003ed806 	br	100009a8 <_malloc_r+0xb4>
10000e48:	48c000c4 	addi	r3,r9,3
10000e4c:	003f3106 	br	10000b14 <_malloc_r+0x220>
10000e50:	05c40074 	movhi	r23,4097
10000e54:	bdea2a04 	addi	r23,r23,-22360
10000e58:	b8800017 	ldw	r2,0(r23)
10000e5c:	988d883a 	add	r6,r19,r2
10000e60:	b9800015 	stw	r6,0(r23)
10000e64:	293fb21e 	bne	r5,r4,10000d30 <_malloc_r+0x43c>
10000e68:	2083ffcc 	andi	r2,r4,4095
10000e6c:	103fb01e 	bne	r2,zero,10000d30 <_malloc_r+0x43c>
10000e70:	e4000217 	ldw	r16,8(fp)
10000e74:	9d45883a 	add	r2,r19,r21
10000e78:	10800054 	ori	r2,r2,1
10000e7c:	80800115 	stw	r2,4(r16)
10000e80:	b8c00017 	ldw	r3,0(r23)
10000e84:	d0a01317 	ldw	r2,-32692(gp)
10000e88:	10c0012e 	bgeu	r2,r3,10000e90 <_malloc_r+0x59c>
10000e8c:	d0e01315 	stw	r3,-32692(gp)
10000e90:	d0a01417 	ldw	r2,-32688(gp)
10000e94:	10ff962e 	bgeu	r2,r3,10000cf0 <_malloc_r+0x3fc>
10000e98:	d0e01415 	stw	r3,-32688(gp)
10000e9c:	003f9406 	br	10000cf0 <_malloc_r+0x3fc>
10000ea0:	00800104 	movi	r2,4
10000ea4:	11001e36 	bltu	r2,r4,10000f20 <_malloc_r+0x62c>
10000ea8:	2804d1ba 	srli	r2,r5,6
10000eac:	11000e04 	addi	r4,r2,56
10000eb0:	200690fa 	slli	r3,r4,3
10000eb4:	003fc506 	br	10000dcc <_malloc_r+0x4d8>
10000eb8:	00815504 	movi	r2,1364
10000ebc:	10c01d2e 	bgeu	r2,r3,10000f34 <_malloc_r+0x640>
10000ec0:	01801f84 	movi	r6,126
10000ec4:	0080fc04 	movi	r2,1008
10000ec8:	003eb706 	br	100009a8 <_malloc_r+0xb4>
10000ecc:	00800204 	movi	r2,8
10000ed0:	10cbc83a 	sub	r5,r2,r3
10000ed4:	2169883a 	add	r20,r4,r5
10000ed8:	003f9e06 	br	10000d54 <_malloc_r+0x460>
10000edc:	00bffe04 	movi	r2,-8
10000ee0:	a93ffd04 	addi	r4,r21,-12
10000ee4:	2088703a 	and	r4,r4,r2
10000ee8:	b10b883a 	add	r5,r22,r4
10000eec:	00c00144 	movi	r3,5
10000ef0:	28c00215 	stw	r3,8(r5)
10000ef4:	28c00115 	stw	r3,4(r5)
10000ef8:	b0800117 	ldw	r2,4(r22)
10000efc:	1080004c 	andi	r2,r2,1
10000f00:	2084b03a 	or	r2,r4,r2
10000f04:	b0800115 	stw	r2,4(r22)
10000f08:	313fdd2e 	bgeu	r6,r4,10000e80 <_malloc_r+0x58c>
10000f0c:	b1400204 	addi	r5,r22,8
10000f10:	9009883a 	mov	r4,r18
10000f14:	00020540 	call	10002054 <_free_r>
10000f18:	e4000217 	ldw	r16,8(fp)
10000f1c:	003fd806 	br	10000e80 <_malloc_r+0x58c>
10000f20:	00800504 	movi	r2,20
10000f24:	11001536 	bltu	r2,r4,10000f7c <_malloc_r+0x688>
10000f28:	210016c4 	addi	r4,r4,91
10000f2c:	200690fa 	slli	r3,r4,3
10000f30:	003fa606 	br	10000dcc <_malloc_r+0x4d8>
10000f34:	8804d4ba 	srli	r2,r17,18
10000f38:	11801f04 	addi	r6,r2,124
10000f3c:	300490fa 	slli	r2,r6,3
10000f40:	003e9906 	br	100009a8 <_malloc_r+0xb4>
10000f44:	2009d0ba 	srai	r4,r4,2
10000f48:	01440074 	movhi	r5,4097
10000f4c:	29643c04 	addi	r5,r5,-28432
10000f50:	00c00044 	movi	r3,1
10000f54:	28800117 	ldw	r2,4(r5)
10000f58:	1906983a 	sll	r3,r3,r4
10000f5c:	10c4b03a 	or	r2,r2,r3
10000f60:	28800115 	stw	r2,4(r5)
10000f64:	003fa306 	br	10000df4 <_malloc_r+0x500>
10000f68:	0027883a 	mov	r19,zero
10000f6c:	00c00044 	movi	r3,1
10000f70:	003f8606 	br	10000d8c <_malloc_r+0x498>
10000f74:	d1200315 	stw	r4,-32756(gp)
10000f78:	003f7306 	br	10000d48 <_malloc_r+0x454>
10000f7c:	00801504 	movi	r2,84
10000f80:	11001936 	bltu	r2,r4,10000fe8 <_malloc_r+0x6f4>
10000f84:	2804d33a 	srli	r2,r5,12
10000f88:	11001b84 	addi	r4,r2,110
10000f8c:	200690fa 	slli	r3,r4,3
10000f90:	003f8e06 	br	10000dcc <_malloc_r+0x4d8>
10000f94:	480b883a 	mov	r5,r9
10000f98:	6807883a 	mov	r3,r13
10000f9c:	288000cc 	andi	r2,r5,3
10000fa0:	18fffe04 	addi	r3,r3,-8
10000fa4:	297fffc4 	addi	r5,r5,-1
10000fa8:	10001526 	beq	r2,zero,10001000 <_malloc_r+0x70c>
10000fac:	18800217 	ldw	r2,8(r3)
10000fb0:	10fffa26 	beq	r2,r3,10000f9c <_malloc_r+0x6a8>
10000fb4:	2109883a 	add	r4,r4,r4
10000fb8:	393f1e36 	bltu	r7,r4,10000c34 <_malloc_r+0x340>
10000fbc:	203f1d26 	beq	r4,zero,10000c34 <_malloc_r+0x340>
10000fc0:	21c4703a 	and	r2,r4,r7
10000fc4:	10000226 	beq	r2,zero,10000fd0 <_malloc_r+0x6dc>
10000fc8:	6013883a 	mov	r9,r12
10000fcc:	003ee106 	br	10000b54 <_malloc_r+0x260>
10000fd0:	2109883a 	add	r4,r4,r4
10000fd4:	3904703a 	and	r2,r7,r4
10000fd8:	63000104 	addi	r12,r12,4
10000fdc:	103ffc26 	beq	r2,zero,10000fd0 <_malloc_r+0x6dc>
10000fe0:	6013883a 	mov	r9,r12
10000fe4:	003edb06 	br	10000b54 <_malloc_r+0x260>
10000fe8:	00805504 	movi	r2,340
10000fec:	11000836 	bltu	r2,r4,10001010 <_malloc_r+0x71c>
10000ff0:	2804d3fa 	srli	r2,r5,15
10000ff4:	11001dc4 	addi	r4,r2,119
10000ff8:	200690fa 	slli	r3,r4,3
10000ffc:	003f7306 	br	10000dcc <_malloc_r+0x4d8>
10001000:	0104303a 	nor	r2,zero,r4
10001004:	388e703a 	and	r7,r7,r2
10001008:	e1c00115 	stw	r7,4(fp)
1000100c:	003fe906 	br	10000fb4 <_malloc_r+0x6c0>
10001010:	00815504 	movi	r2,1364
10001014:	1100032e 	bgeu	r2,r4,10001024 <_malloc_r+0x730>
10001018:	01001f84 	movi	r4,126
1000101c:	00c0fc04 	movi	r3,1008
10001020:	003f6a06 	br	10000dcc <_malloc_r+0x4d8>
10001024:	2804d4ba 	srli	r2,r5,18
10001028:	11001f04 	addi	r4,r2,124
1000102c:	200690fa 	slli	r3,r4,3
10001030:	003f6606 	br	10000dcc <_malloc_r+0x4d8>

10001034 <memchr>:
10001034:	008000c4 	movi	r2,3
10001038:	29403fcc 	andi	r5,r5,255
1000103c:	2007883a 	mov	r3,r4
10001040:	1180022e 	bgeu	r2,r6,1000104c <memchr+0x18>
10001044:	2084703a 	and	r2,r4,r2
10001048:	10000b26 	beq	r2,zero,10001078 <memchr+0x44>
1000104c:	313fffc4 	addi	r4,r6,-1
10001050:	3000051e 	bne	r6,zero,10001068 <memchr+0x34>
10001054:	00002c06 	br	10001108 <memchr+0xd4>
10001058:	213fffc4 	addi	r4,r4,-1
1000105c:	00bfffc4 	movi	r2,-1
10001060:	18c00044 	addi	r3,r3,1
10001064:	20802826 	beq	r4,r2,10001108 <memchr+0xd4>
10001068:	18800003 	ldbu	r2,0(r3)
1000106c:	28bffa1e 	bne	r5,r2,10001058 <memchr+0x24>
10001070:	1805883a 	mov	r2,r3
10001074:	f800283a 	ret
10001078:	0011883a 	mov	r8,zero
1000107c:	0007883a 	mov	r3,zero
10001080:	01c00104 	movi	r7,4
10001084:	4004923a 	slli	r2,r8,8
10001088:	18c00044 	addi	r3,r3,1
1000108c:	1151883a 	add	r8,r2,r5
10001090:	19fffc1e 	bne	r3,r7,10001084 <memchr+0x50>
10001094:	02bfbff4 	movhi	r10,65279
10001098:	52bfbfc4 	addi	r10,r10,-257
1000109c:	02602074 	movhi	r9,32897
100010a0:	4a602004 	addi	r9,r9,-32640
100010a4:	02c000c4 	movi	r11,3
100010a8:	20800017 	ldw	r2,0(r4)
100010ac:	31bfff04 	addi	r6,r6,-4
100010b0:	200f883a 	mov	r7,r4
100010b4:	1204f03a 	xor	r2,r2,r8
100010b8:	1287883a 	add	r3,r2,r10
100010bc:	1a46703a 	and	r3,r3,r9
100010c0:	0084303a 	nor	r2,zero,r2
100010c4:	10c4703a 	and	r2,r2,r3
100010c8:	10000b26 	beq	r2,zero,100010f8 <memchr+0xc4>
100010cc:	20800003 	ldbu	r2,0(r4)
100010d0:	28800f26 	beq	r5,r2,10001110 <memchr+0xdc>
100010d4:	20800043 	ldbu	r2,1(r4)
100010d8:	21c00044 	addi	r7,r4,1
100010dc:	28800c26 	beq	r5,r2,10001110 <memchr+0xdc>
100010e0:	20800083 	ldbu	r2,2(r4)
100010e4:	21c00084 	addi	r7,r4,2
100010e8:	28800926 	beq	r5,r2,10001110 <memchr+0xdc>
100010ec:	208000c3 	ldbu	r2,3(r4)
100010f0:	21c000c4 	addi	r7,r4,3
100010f4:	28800626 	beq	r5,r2,10001110 <memchr+0xdc>
100010f8:	21000104 	addi	r4,r4,4
100010fc:	59bfea36 	bltu	r11,r6,100010a8 <memchr+0x74>
10001100:	2007883a 	mov	r3,r4
10001104:	003fd106 	br	1000104c <memchr+0x18>
10001108:	0005883a 	mov	r2,zero
1000110c:	f800283a 	ret
10001110:	3805883a 	mov	r2,r7
10001114:	f800283a 	ret

10001118 <memcpy>:
10001118:	01c003c4 	movi	r7,15
1000111c:	2007883a 	mov	r3,r4
10001120:	3980032e 	bgeu	r7,r6,10001130 <memcpy+0x18>
10001124:	2904b03a 	or	r2,r5,r4
10001128:	108000cc 	andi	r2,r2,3
1000112c:	10000926 	beq	r2,zero,10001154 <memcpy+0x3c>
10001130:	30000626 	beq	r6,zero,1000114c <memcpy+0x34>
10001134:	30cd883a 	add	r6,r6,r3
10001138:	28800003 	ldbu	r2,0(r5)
1000113c:	29400044 	addi	r5,r5,1
10001140:	18800005 	stb	r2,0(r3)
10001144:	18c00044 	addi	r3,r3,1
10001148:	30fffb1e 	bne	r6,r3,10001138 <memcpy+0x20>
1000114c:	2005883a 	mov	r2,r4
10001150:	f800283a 	ret
10001154:	3811883a 	mov	r8,r7
10001158:	200f883a 	mov	r7,r4
1000115c:	28c00017 	ldw	r3,0(r5)
10001160:	31bffc04 	addi	r6,r6,-16
10001164:	38c00015 	stw	r3,0(r7)
10001168:	28800117 	ldw	r2,4(r5)
1000116c:	38800115 	stw	r2,4(r7)
10001170:	28c00217 	ldw	r3,8(r5)
10001174:	38c00215 	stw	r3,8(r7)
10001178:	28800317 	ldw	r2,12(r5)
1000117c:	29400404 	addi	r5,r5,16
10001180:	38800315 	stw	r2,12(r7)
10001184:	39c00404 	addi	r7,r7,16
10001188:	41bff436 	bltu	r8,r6,1000115c <memcpy+0x44>
1000118c:	008000c4 	movi	r2,3
10001190:	1180072e 	bgeu	r2,r6,100011b0 <memcpy+0x98>
10001194:	1007883a 	mov	r3,r2
10001198:	28800017 	ldw	r2,0(r5)
1000119c:	31bfff04 	addi	r6,r6,-4
100011a0:	29400104 	addi	r5,r5,4
100011a4:	38800015 	stw	r2,0(r7)
100011a8:	39c00104 	addi	r7,r7,4
100011ac:	19bffa36 	bltu	r3,r6,10001198 <memcpy+0x80>
100011b0:	3807883a 	mov	r3,r7
100011b4:	003fde06 	br	10001130 <memcpy+0x18>

100011b8 <memmove>:
100011b8:	2807883a 	mov	r3,r5
100011bc:	2011883a 	mov	r8,r4
100011c0:	29000c2e 	bgeu	r5,r4,100011f4 <memmove+0x3c>
100011c4:	298f883a 	add	r7,r5,r6
100011c8:	21c00a2e 	bgeu	r4,r7,100011f4 <memmove+0x3c>
100011cc:	30000726 	beq	r6,zero,100011ec <memmove+0x34>
100011d0:	2187883a 	add	r3,r4,r6
100011d4:	198dc83a 	sub	r6,r3,r6
100011d8:	39ffffc4 	addi	r7,r7,-1
100011dc:	38800003 	ldbu	r2,0(r7)
100011e0:	18ffffc4 	addi	r3,r3,-1
100011e4:	18800005 	stb	r2,0(r3)
100011e8:	19bffb1e 	bne	r3,r6,100011d8 <memmove+0x20>
100011ec:	2005883a 	mov	r2,r4
100011f0:	f800283a 	ret
100011f4:	01c003c4 	movi	r7,15
100011f8:	39800a36 	bltu	r7,r6,10001224 <memmove+0x6c>
100011fc:	303ffb26 	beq	r6,zero,100011ec <memmove+0x34>
10001200:	400f883a 	mov	r7,r8
10001204:	320d883a 	add	r6,r6,r8
10001208:	28800003 	ldbu	r2,0(r5)
1000120c:	29400044 	addi	r5,r5,1
10001210:	38800005 	stb	r2,0(r7)
10001214:	39c00044 	addi	r7,r7,1
10001218:	39bffb1e 	bne	r7,r6,10001208 <memmove+0x50>
1000121c:	2005883a 	mov	r2,r4
10001220:	f800283a 	ret
10001224:	1904b03a 	or	r2,r3,r4
10001228:	108000cc 	andi	r2,r2,3
1000122c:	103ff31e 	bne	r2,zero,100011fc <memmove+0x44>
10001230:	3811883a 	mov	r8,r7
10001234:	180b883a 	mov	r5,r3
10001238:	200f883a 	mov	r7,r4
1000123c:	28c00017 	ldw	r3,0(r5)
10001240:	31bffc04 	addi	r6,r6,-16
10001244:	38c00015 	stw	r3,0(r7)
10001248:	28800117 	ldw	r2,4(r5)
1000124c:	38800115 	stw	r2,4(r7)
10001250:	28c00217 	ldw	r3,8(r5)
10001254:	38c00215 	stw	r3,8(r7)
10001258:	28800317 	ldw	r2,12(r5)
1000125c:	29400404 	addi	r5,r5,16
10001260:	38800315 	stw	r2,12(r7)
10001264:	39c00404 	addi	r7,r7,16
10001268:	41bff436 	bltu	r8,r6,1000123c <memmove+0x84>
1000126c:	008000c4 	movi	r2,3
10001270:	1180072e 	bgeu	r2,r6,10001290 <memmove+0xd8>
10001274:	1007883a 	mov	r3,r2
10001278:	28800017 	ldw	r2,0(r5)
1000127c:	31bfff04 	addi	r6,r6,-4
10001280:	29400104 	addi	r5,r5,4
10001284:	38800015 	stw	r2,0(r7)
10001288:	39c00104 	addi	r7,r7,4
1000128c:	19bffa36 	bltu	r3,r6,10001278 <memmove+0xc0>
10001290:	3811883a 	mov	r8,r7
10001294:	003fd906 	br	100011fc <memmove+0x44>

10001298 <_realloc_r>:
10001298:	defff404 	addi	sp,sp,-48
1000129c:	dd800815 	stw	r22,32(sp)
100012a0:	dc800415 	stw	r18,16(sp)
100012a4:	dc400315 	stw	r17,12(sp)
100012a8:	dfc00b15 	stw	ra,44(sp)
100012ac:	df000a15 	stw	fp,40(sp)
100012b0:	ddc00915 	stw	r23,36(sp)
100012b4:	dd400715 	stw	r21,28(sp)
100012b8:	dd000615 	stw	r20,24(sp)
100012bc:	dcc00515 	stw	r19,20(sp)
100012c0:	dc000215 	stw	r16,8(sp)
100012c4:	2825883a 	mov	r18,r5
100012c8:	3023883a 	mov	r17,r6
100012cc:	202d883a 	mov	r22,r4
100012d0:	2800c926 	beq	r5,zero,100015f8 <_realloc_r+0x360>
100012d4:	00031d80 	call	100031d8 <__malloc_lock>
100012d8:	943ffe04 	addi	r16,r18,-8
100012dc:	88c002c4 	addi	r3,r17,11
100012e0:	00800584 	movi	r2,22
100012e4:	82000117 	ldw	r8,4(r16)
100012e8:	10c01b2e 	bgeu	r2,r3,10001358 <_realloc_r+0xc0>
100012ec:	00bffe04 	movi	r2,-8
100012f0:	188e703a 	and	r7,r3,r2
100012f4:	3839883a 	mov	fp,r7
100012f8:	38001a16 	blt	r7,zero,10001364 <_realloc_r+0xcc>
100012fc:	e4401936 	bltu	fp,r17,10001364 <_realloc_r+0xcc>
10001300:	013fff04 	movi	r4,-4
10001304:	4126703a 	and	r19,r8,r4
10001308:	99c02616 	blt	r19,r7,100013a4 <_realloc_r+0x10c>
1000130c:	802b883a 	mov	r21,r16
10001310:	9829883a 	mov	r20,r19
10001314:	84000204 	addi	r16,r16,8
10001318:	a80f883a 	mov	r7,r21
1000131c:	a70dc83a 	sub	r6,r20,fp
10001320:	008003c4 	movi	r2,15
10001324:	1180c136 	bltu	r2,r6,1000162c <_realloc_r+0x394>
10001328:	38800117 	ldw	r2,4(r7)
1000132c:	a549883a 	add	r4,r20,r21
10001330:	1080004c 	andi	r2,r2,1
10001334:	a084b03a 	or	r2,r20,r2
10001338:	38800115 	stw	r2,4(r7)
1000133c:	20c00117 	ldw	r3,4(r4)
10001340:	18c00054 	ori	r3,r3,1
10001344:	20c00115 	stw	r3,4(r4)
10001348:	b009883a 	mov	r4,r22
1000134c:	00031f80 	call	100031f8 <__malloc_unlock>
10001350:	8023883a 	mov	r17,r16
10001354:	00000606 	br	10001370 <_realloc_r+0xd8>
10001358:	01c00404 	movi	r7,16
1000135c:	3839883a 	mov	fp,r7
10001360:	e47fe72e 	bgeu	fp,r17,10001300 <_realloc_r+0x68>
10001364:	00800304 	movi	r2,12
10001368:	0023883a 	mov	r17,zero
1000136c:	b0800015 	stw	r2,0(r22)
10001370:	8805883a 	mov	r2,r17
10001374:	dfc00b17 	ldw	ra,44(sp)
10001378:	df000a17 	ldw	fp,40(sp)
1000137c:	ddc00917 	ldw	r23,36(sp)
10001380:	dd800817 	ldw	r22,32(sp)
10001384:	dd400717 	ldw	r21,28(sp)
10001388:	dd000617 	ldw	r20,24(sp)
1000138c:	dcc00517 	ldw	r19,20(sp)
10001390:	dc800417 	ldw	r18,16(sp)
10001394:	dc400317 	ldw	r17,12(sp)
10001398:	dc000217 	ldw	r16,8(sp)
1000139c:	dec00c04 	addi	sp,sp,48
100013a0:	f800283a 	ret
100013a4:	00840074 	movhi	r2,4097
100013a8:	10a43c04 	addi	r2,r2,-28432
100013ac:	12400217 	ldw	r9,8(r2)
100013b0:	84cd883a 	add	r6,r16,r19
100013b4:	802b883a 	mov	r21,r16
100013b8:	3240b926 	beq	r6,r9,100016a0 <_realloc_r+0x408>
100013bc:	31400117 	ldw	r5,4(r6)
100013c0:	00bfff84 	movi	r2,-2
100013c4:	2884703a 	and	r2,r5,r2
100013c8:	1185883a 	add	r2,r2,r6
100013cc:	10c00117 	ldw	r3,4(r2)
100013d0:	18c0004c 	andi	r3,r3,1
100013d4:	1807003a 	cmpeq	r3,r3,zero
100013d8:	1800a326 	beq	r3,zero,10001668 <_realloc_r+0x3d0>
100013dc:	2908703a 	and	r4,r5,r4
100013e0:	9929883a 	add	r20,r19,r4
100013e4:	a1c0a30e 	bge	r20,r7,10001674 <_realloc_r+0x3dc>
100013e8:	4080004c 	andi	r2,r8,1
100013ec:	1000551e 	bne	r2,zero,10001544 <_realloc_r+0x2ac>
100013f0:	80800017 	ldw	r2,0(r16)
100013f4:	80afc83a 	sub	r23,r16,r2
100013f8:	b8c00117 	ldw	r3,4(r23)
100013fc:	00bfff04 	movi	r2,-4
10001400:	1884703a 	and	r2,r3,r2
10001404:	30002e26 	beq	r6,zero,100014c0 <_realloc_r+0x228>
10001408:	3240b926 	beq	r6,r9,100016f0 <_realloc_r+0x458>
1000140c:	98a9883a 	add	r20,r19,r2
10001410:	2509883a 	add	r4,r4,r20
10001414:	d9000015 	stw	r4,0(sp)
10001418:	21c02a16 	blt	r4,r7,100014c4 <_realloc_r+0x22c>
1000141c:	30800317 	ldw	r2,12(r6)
10001420:	30c00217 	ldw	r3,8(r6)
10001424:	01400904 	movi	r5,36
10001428:	99bfff04 	addi	r6,r19,-4
1000142c:	18800315 	stw	r2,12(r3)
10001430:	10c00215 	stw	r3,8(r2)
10001434:	b9000317 	ldw	r4,12(r23)
10001438:	b8800217 	ldw	r2,8(r23)
1000143c:	b82b883a 	mov	r21,r23
10001440:	bc000204 	addi	r16,r23,8
10001444:	20800215 	stw	r2,8(r4)
10001448:	11000315 	stw	r4,12(r2)
1000144c:	2980e436 	bltu	r5,r6,100017e0 <_realloc_r+0x548>
10001450:	008004c4 	movi	r2,19
10001454:	9009883a 	mov	r4,r18
10001458:	8011883a 	mov	r8,r16
1000145c:	11800f2e 	bgeu	r2,r6,1000149c <_realloc_r+0x204>
10001460:	90800017 	ldw	r2,0(r18)
10001464:	ba000404 	addi	r8,r23,16
10001468:	91000204 	addi	r4,r18,8
1000146c:	b8800215 	stw	r2,8(r23)
10001470:	90c00117 	ldw	r3,4(r18)
10001474:	008006c4 	movi	r2,27
10001478:	b8c00315 	stw	r3,12(r23)
1000147c:	1180072e 	bgeu	r2,r6,1000149c <_realloc_r+0x204>
10001480:	90c00217 	ldw	r3,8(r18)
10001484:	ba000604 	addi	r8,r23,24
10001488:	91000404 	addi	r4,r18,16
1000148c:	b8c00415 	stw	r3,16(r23)
10001490:	90800317 	ldw	r2,12(r18)
10001494:	b8800515 	stw	r2,20(r23)
10001498:	3140e726 	beq	r6,r5,10001838 <_realloc_r+0x5a0>
1000149c:	20800017 	ldw	r2,0(r4)
100014a0:	dd000017 	ldw	r20,0(sp)
100014a4:	b80f883a 	mov	r7,r23
100014a8:	40800015 	stw	r2,0(r8)
100014ac:	20c00117 	ldw	r3,4(r4)
100014b0:	40c00115 	stw	r3,4(r8)
100014b4:	20800217 	ldw	r2,8(r4)
100014b8:	40800215 	stw	r2,8(r8)
100014bc:	003f9706 	br	1000131c <_realloc_r+0x84>
100014c0:	98a9883a 	add	r20,r19,r2
100014c4:	a1c01f16 	blt	r20,r7,10001544 <_realloc_r+0x2ac>
100014c8:	b8c00317 	ldw	r3,12(r23)
100014cc:	b8800217 	ldw	r2,8(r23)
100014d0:	99bfff04 	addi	r6,r19,-4
100014d4:	01400904 	movi	r5,36
100014d8:	b82b883a 	mov	r21,r23
100014dc:	18800215 	stw	r2,8(r3)
100014e0:	10c00315 	stw	r3,12(r2)
100014e4:	bc000204 	addi	r16,r23,8
100014e8:	2980c336 	bltu	r5,r6,100017f8 <_realloc_r+0x560>
100014ec:	008004c4 	movi	r2,19
100014f0:	9009883a 	mov	r4,r18
100014f4:	8011883a 	mov	r8,r16
100014f8:	11800f2e 	bgeu	r2,r6,10001538 <_realloc_r+0x2a0>
100014fc:	90800017 	ldw	r2,0(r18)
10001500:	ba000404 	addi	r8,r23,16
10001504:	91000204 	addi	r4,r18,8
10001508:	b8800215 	stw	r2,8(r23)
1000150c:	90c00117 	ldw	r3,4(r18)
10001510:	008006c4 	movi	r2,27
10001514:	b8c00315 	stw	r3,12(r23)
10001518:	1180072e 	bgeu	r2,r6,10001538 <_realloc_r+0x2a0>
1000151c:	90c00217 	ldw	r3,8(r18)
10001520:	ba000604 	addi	r8,r23,24
10001524:	91000404 	addi	r4,r18,16
10001528:	b8c00415 	stw	r3,16(r23)
1000152c:	90800317 	ldw	r2,12(r18)
10001530:	b8800515 	stw	r2,20(r23)
10001534:	3140c726 	beq	r6,r5,10001854 <_realloc_r+0x5bc>
10001538:	20800017 	ldw	r2,0(r4)
1000153c:	b80f883a 	mov	r7,r23
10001540:	003fd906 	br	100014a8 <_realloc_r+0x210>
10001544:	880b883a 	mov	r5,r17
10001548:	b009883a 	mov	r4,r22
1000154c:	00008f40 	call	100008f4 <_malloc_r>
10001550:	1023883a 	mov	r17,r2
10001554:	10002526 	beq	r2,zero,100015ec <_realloc_r+0x354>
10001558:	80800117 	ldw	r2,4(r16)
1000155c:	00ffff84 	movi	r3,-2
10001560:	893ffe04 	addi	r4,r17,-8
10001564:	10c4703a 	and	r2,r2,r3
10001568:	8085883a 	add	r2,r16,r2
1000156c:	20809526 	beq	r4,r2,100017c4 <_realloc_r+0x52c>
10001570:	99bfff04 	addi	r6,r19,-4
10001574:	01c00904 	movi	r7,36
10001578:	39804536 	bltu	r7,r6,10001690 <_realloc_r+0x3f8>
1000157c:	008004c4 	movi	r2,19
10001580:	9009883a 	mov	r4,r18
10001584:	880b883a 	mov	r5,r17
10001588:	11800f2e 	bgeu	r2,r6,100015c8 <_realloc_r+0x330>
1000158c:	90800017 	ldw	r2,0(r18)
10001590:	89400204 	addi	r5,r17,8
10001594:	91000204 	addi	r4,r18,8
10001598:	88800015 	stw	r2,0(r17)
1000159c:	90c00117 	ldw	r3,4(r18)
100015a0:	008006c4 	movi	r2,27
100015a4:	88c00115 	stw	r3,4(r17)
100015a8:	1180072e 	bgeu	r2,r6,100015c8 <_realloc_r+0x330>
100015ac:	90c00217 	ldw	r3,8(r18)
100015b0:	89400404 	addi	r5,r17,16
100015b4:	91000404 	addi	r4,r18,16
100015b8:	88c00215 	stw	r3,8(r17)
100015bc:	90800317 	ldw	r2,12(r18)
100015c0:	88800315 	stw	r2,12(r17)
100015c4:	31c09126 	beq	r6,r7,1000180c <_realloc_r+0x574>
100015c8:	20800017 	ldw	r2,0(r4)
100015cc:	28800015 	stw	r2,0(r5)
100015d0:	20c00117 	ldw	r3,4(r4)
100015d4:	28c00115 	stw	r3,4(r5)
100015d8:	20800217 	ldw	r2,8(r4)
100015dc:	28800215 	stw	r2,8(r5)
100015e0:	900b883a 	mov	r5,r18
100015e4:	b009883a 	mov	r4,r22
100015e8:	00020540 	call	10002054 <_free_r>
100015ec:	b009883a 	mov	r4,r22
100015f0:	00031f80 	call	100031f8 <__malloc_unlock>
100015f4:	003f5e06 	br	10001370 <_realloc_r+0xd8>
100015f8:	300b883a 	mov	r5,r6
100015fc:	dfc00b17 	ldw	ra,44(sp)
10001600:	df000a17 	ldw	fp,40(sp)
10001604:	ddc00917 	ldw	r23,36(sp)
10001608:	dd800817 	ldw	r22,32(sp)
1000160c:	dd400717 	ldw	r21,28(sp)
10001610:	dd000617 	ldw	r20,24(sp)
10001614:	dcc00517 	ldw	r19,20(sp)
10001618:	dc800417 	ldw	r18,16(sp)
1000161c:	dc400317 	ldw	r17,12(sp)
10001620:	dc000217 	ldw	r16,8(sp)
10001624:	dec00c04 	addi	sp,sp,48
10001628:	00008f41 	jmpi	100008f4 <_malloc_r>
1000162c:	38800117 	ldw	r2,4(r7)
10001630:	e54b883a 	add	r5,fp,r21
10001634:	31000054 	ori	r4,r6,1
10001638:	1080004c 	andi	r2,r2,1
1000163c:	1704b03a 	or	r2,r2,fp
10001640:	38800115 	stw	r2,4(r7)
10001644:	29000115 	stw	r4,4(r5)
10001648:	2987883a 	add	r3,r5,r6
1000164c:	18800117 	ldw	r2,4(r3)
10001650:	29400204 	addi	r5,r5,8
10001654:	b009883a 	mov	r4,r22
10001658:	10800054 	ori	r2,r2,1
1000165c:	18800115 	stw	r2,4(r3)
10001660:	00020540 	call	10002054 <_free_r>
10001664:	003f3806 	br	10001348 <_realloc_r+0xb0>
10001668:	000d883a 	mov	r6,zero
1000166c:	0009883a 	mov	r4,zero
10001670:	003f5d06 	br	100013e8 <_realloc_r+0x150>
10001674:	30c00217 	ldw	r3,8(r6)
10001678:	30800317 	ldw	r2,12(r6)
1000167c:	800f883a 	mov	r7,r16
10001680:	84000204 	addi	r16,r16,8
10001684:	10c00215 	stw	r3,8(r2)
10001688:	18800315 	stw	r2,12(r3)
1000168c:	003f2306 	br	1000131c <_realloc_r+0x84>
10001690:	8809883a 	mov	r4,r17
10001694:	900b883a 	mov	r5,r18
10001698:	00011b80 	call	100011b8 <memmove>
1000169c:	003fd006 	br	100015e0 <_realloc_r+0x348>
100016a0:	30800117 	ldw	r2,4(r6)
100016a4:	e0c00404 	addi	r3,fp,16
100016a8:	1108703a 	and	r4,r2,r4
100016ac:	9905883a 	add	r2,r19,r4
100016b0:	10ff4d16 	blt	r2,r3,100013e8 <_realloc_r+0x150>
100016b4:	1705c83a 	sub	r2,r2,fp
100016b8:	870b883a 	add	r5,r16,fp
100016bc:	10800054 	ori	r2,r2,1
100016c0:	28800115 	stw	r2,4(r5)
100016c4:	80c00117 	ldw	r3,4(r16)
100016c8:	00840074 	movhi	r2,4097
100016cc:	10a43c04 	addi	r2,r2,-28432
100016d0:	b009883a 	mov	r4,r22
100016d4:	18c0004c 	andi	r3,r3,1
100016d8:	e0c6b03a 	or	r3,fp,r3
100016dc:	11400215 	stw	r5,8(r2)
100016e0:	80c00115 	stw	r3,4(r16)
100016e4:	00031f80 	call	100031f8 <__malloc_unlock>
100016e8:	84400204 	addi	r17,r16,8
100016ec:	003f2006 	br	10001370 <_realloc_r+0xd8>
100016f0:	98a9883a 	add	r20,r19,r2
100016f4:	2509883a 	add	r4,r4,r20
100016f8:	e0800404 	addi	r2,fp,16
100016fc:	d9000115 	stw	r4,4(sp)
10001700:	20bf7016 	blt	r4,r2,100014c4 <_realloc_r+0x22c>
10001704:	b8c00317 	ldw	r3,12(r23)
10001708:	b8800217 	ldw	r2,8(r23)
1000170c:	99bfff04 	addi	r6,r19,-4
10001710:	01400904 	movi	r5,36
10001714:	18800215 	stw	r2,8(r3)
10001718:	10c00315 	stw	r3,12(r2)
1000171c:	bc400204 	addi	r17,r23,8
10001720:	29804136 	bltu	r5,r6,10001828 <_realloc_r+0x590>
10001724:	008004c4 	movi	r2,19
10001728:	9009883a 	mov	r4,r18
1000172c:	880f883a 	mov	r7,r17
10001730:	11800f2e 	bgeu	r2,r6,10001770 <_realloc_r+0x4d8>
10001734:	90800017 	ldw	r2,0(r18)
10001738:	b9c00404 	addi	r7,r23,16
1000173c:	91000204 	addi	r4,r18,8
10001740:	b8800215 	stw	r2,8(r23)
10001744:	90c00117 	ldw	r3,4(r18)
10001748:	008006c4 	movi	r2,27
1000174c:	b8c00315 	stw	r3,12(r23)
10001750:	1180072e 	bgeu	r2,r6,10001770 <_realloc_r+0x4d8>
10001754:	90c00217 	ldw	r3,8(r18)
10001758:	b9c00604 	addi	r7,r23,24
1000175c:	91000404 	addi	r4,r18,16
10001760:	b8c00415 	stw	r3,16(r23)
10001764:	90800317 	ldw	r2,12(r18)
10001768:	b8800515 	stw	r2,20(r23)
1000176c:	31404026 	beq	r6,r5,10001870 <_realloc_r+0x5d8>
10001770:	20800017 	ldw	r2,0(r4)
10001774:	38800015 	stw	r2,0(r7)
10001778:	20c00117 	ldw	r3,4(r4)
1000177c:	38c00115 	stw	r3,4(r7)
10001780:	20800217 	ldw	r2,8(r4)
10001784:	38800215 	stw	r2,8(r7)
10001788:	d8c00117 	ldw	r3,4(sp)
1000178c:	bf0b883a 	add	r5,r23,fp
10001790:	b009883a 	mov	r4,r22
10001794:	1f05c83a 	sub	r2,r3,fp
10001798:	10800054 	ori	r2,r2,1
1000179c:	28800115 	stw	r2,4(r5)
100017a0:	b8c00117 	ldw	r3,4(r23)
100017a4:	00840074 	movhi	r2,4097
100017a8:	10a43c04 	addi	r2,r2,-28432
100017ac:	11400215 	stw	r5,8(r2)
100017b0:	18c0004c 	andi	r3,r3,1
100017b4:	e0c6b03a 	or	r3,fp,r3
100017b8:	b8c00115 	stw	r3,4(r23)
100017bc:	00031f80 	call	100031f8 <__malloc_unlock>
100017c0:	003eeb06 	br	10001370 <_realloc_r+0xd8>
100017c4:	20800117 	ldw	r2,4(r4)
100017c8:	00ffff04 	movi	r3,-4
100017cc:	800f883a 	mov	r7,r16
100017d0:	10c4703a 	and	r2,r2,r3
100017d4:	98a9883a 	add	r20,r19,r2
100017d8:	84000204 	addi	r16,r16,8
100017dc:	003ecf06 	br	1000131c <_realloc_r+0x84>
100017e0:	900b883a 	mov	r5,r18
100017e4:	8009883a 	mov	r4,r16
100017e8:	00011b80 	call	100011b8 <memmove>
100017ec:	dd000017 	ldw	r20,0(sp)
100017f0:	b80f883a 	mov	r7,r23
100017f4:	003ec906 	br	1000131c <_realloc_r+0x84>
100017f8:	900b883a 	mov	r5,r18
100017fc:	8009883a 	mov	r4,r16
10001800:	00011b80 	call	100011b8 <memmove>
10001804:	b80f883a 	mov	r7,r23
10001808:	003ec406 	br	1000131c <_realloc_r+0x84>
1000180c:	90c00417 	ldw	r3,16(r18)
10001810:	89400604 	addi	r5,r17,24
10001814:	91000604 	addi	r4,r18,24
10001818:	88c00415 	stw	r3,16(r17)
1000181c:	90800517 	ldw	r2,20(r18)
10001820:	88800515 	stw	r2,20(r17)
10001824:	003f6806 	br	100015c8 <_realloc_r+0x330>
10001828:	900b883a 	mov	r5,r18
1000182c:	8809883a 	mov	r4,r17
10001830:	00011b80 	call	100011b8 <memmove>
10001834:	003fd406 	br	10001788 <_realloc_r+0x4f0>
10001838:	90c00417 	ldw	r3,16(r18)
1000183c:	91000604 	addi	r4,r18,24
10001840:	ba000804 	addi	r8,r23,32
10001844:	b8c00615 	stw	r3,24(r23)
10001848:	90800517 	ldw	r2,20(r18)
1000184c:	b8800715 	stw	r2,28(r23)
10001850:	003f1206 	br	1000149c <_realloc_r+0x204>
10001854:	90c00417 	ldw	r3,16(r18)
10001858:	91000604 	addi	r4,r18,24
1000185c:	ba000804 	addi	r8,r23,32
10001860:	b8c00615 	stw	r3,24(r23)
10001864:	90800517 	ldw	r2,20(r18)
10001868:	b8800715 	stw	r2,28(r23)
1000186c:	003f3206 	br	10001538 <_realloc_r+0x2a0>
10001870:	90c00417 	ldw	r3,16(r18)
10001874:	91000604 	addi	r4,r18,24
10001878:	b9c00804 	addi	r7,r23,32
1000187c:	b8c00615 	stw	r3,24(r23)
10001880:	90800517 	ldw	r2,20(r18)
10001884:	b8800715 	stw	r2,28(r23)
10001888:	003fb906 	br	10001770 <_realloc_r+0x4d8>

1000188c <_sbrk_r>:
1000188c:	defffd04 	addi	sp,sp,-12
10001890:	dc000015 	stw	r16,0(sp)
10001894:	04040074 	movhi	r16,4097
10001898:	842a2304 	addi	r16,r16,-22388
1000189c:	dc400115 	stw	r17,4(sp)
100018a0:	80000015 	stw	zero,0(r16)
100018a4:	2023883a 	mov	r17,r4
100018a8:	2809883a 	mov	r4,r5
100018ac:	dfc00215 	stw	ra,8(sp)
100018b0:	00033f80 	call	100033f8 <sbrk>
100018b4:	1007883a 	mov	r3,r2
100018b8:	00bfffc4 	movi	r2,-1
100018bc:	18800626 	beq	r3,r2,100018d8 <_sbrk_r+0x4c>
100018c0:	1805883a 	mov	r2,r3
100018c4:	dfc00217 	ldw	ra,8(sp)
100018c8:	dc400117 	ldw	r17,4(sp)
100018cc:	dc000017 	ldw	r16,0(sp)
100018d0:	dec00304 	addi	sp,sp,12
100018d4:	f800283a 	ret
100018d8:	80800017 	ldw	r2,0(r16)
100018dc:	103ff826 	beq	r2,zero,100018c0 <_sbrk_r+0x34>
100018e0:	88800015 	stw	r2,0(r17)
100018e4:	1805883a 	mov	r2,r3
100018e8:	dfc00217 	ldw	ra,8(sp)
100018ec:	dc400117 	ldw	r17,4(sp)
100018f0:	dc000017 	ldw	r16,0(sp)
100018f4:	dec00304 	addi	sp,sp,12
100018f8:	f800283a 	ret

100018fc <__swsetup_r>:
100018fc:	00840074 	movhi	r2,4097
10001900:	10aa0e04 	addi	r2,r2,-22472
10001904:	10c00017 	ldw	r3,0(r2)
10001908:	defffd04 	addi	sp,sp,-12
1000190c:	dc400115 	stw	r17,4(sp)
10001910:	dc000015 	stw	r16,0(sp)
10001914:	dfc00215 	stw	ra,8(sp)
10001918:	2023883a 	mov	r17,r4
1000191c:	2821883a 	mov	r16,r5
10001920:	18000226 	beq	r3,zero,1000192c <__swsetup_r+0x30>
10001924:	18800e17 	ldw	r2,56(r3)
10001928:	10001f26 	beq	r2,zero,100019a8 <__swsetup_r+0xac>
1000192c:	8100030b 	ldhu	r4,12(r16)
10001930:	2080020c 	andi	r2,r4,8
10001934:	10002826 	beq	r2,zero,100019d8 <__swsetup_r+0xdc>
10001938:	81400417 	ldw	r5,16(r16)
1000193c:	28001d26 	beq	r5,zero,100019b4 <__swsetup_r+0xb8>
10001940:	2080004c 	andi	r2,r4,1
10001944:	1005003a 	cmpeq	r2,r2,zero
10001948:	10000b26 	beq	r2,zero,10001978 <__swsetup_r+0x7c>
1000194c:	2080008c 	andi	r2,r4,2
10001950:	10001226 	beq	r2,zero,1000199c <__swsetup_r+0xa0>
10001954:	0005883a 	mov	r2,zero
10001958:	80800215 	stw	r2,8(r16)
1000195c:	28000b26 	beq	r5,zero,1000198c <__swsetup_r+0x90>
10001960:	0005883a 	mov	r2,zero
10001964:	dfc00217 	ldw	ra,8(sp)
10001968:	dc400117 	ldw	r17,4(sp)
1000196c:	dc000017 	ldw	r16,0(sp)
10001970:	dec00304 	addi	sp,sp,12
10001974:	f800283a 	ret
10001978:	80800517 	ldw	r2,20(r16)
1000197c:	80000215 	stw	zero,8(r16)
10001980:	0085c83a 	sub	r2,zero,r2
10001984:	80800615 	stw	r2,24(r16)
10001988:	283ff51e 	bne	r5,zero,10001960 <__swsetup_r+0x64>
1000198c:	2080200c 	andi	r2,r4,128
10001990:	103ff326 	beq	r2,zero,10001960 <__swsetup_r+0x64>
10001994:	00bfffc4 	movi	r2,-1
10001998:	003ff206 	br	10001964 <__swsetup_r+0x68>
1000199c:	80800517 	ldw	r2,20(r16)
100019a0:	80800215 	stw	r2,8(r16)
100019a4:	003fed06 	br	1000195c <__swsetup_r+0x60>
100019a8:	1809883a 	mov	r4,r3
100019ac:	0001cd00 	call	10001cd0 <__sinit>
100019b0:	003fde06 	br	1000192c <__swsetup_r+0x30>
100019b4:	20c0a00c 	andi	r3,r4,640
100019b8:	00808004 	movi	r2,512
100019bc:	18bfe026 	beq	r3,r2,10001940 <__swsetup_r+0x44>
100019c0:	8809883a 	mov	r4,r17
100019c4:	800b883a 	mov	r5,r16
100019c8:	00024e80 	call	100024e8 <__smakebuf_r>
100019cc:	8100030b 	ldhu	r4,12(r16)
100019d0:	81400417 	ldw	r5,16(r16)
100019d4:	003fda06 	br	10001940 <__swsetup_r+0x44>
100019d8:	2080040c 	andi	r2,r4,16
100019dc:	103fed26 	beq	r2,zero,10001994 <__swsetup_r+0x98>
100019e0:	2080010c 	andi	r2,r4,4
100019e4:	10001226 	beq	r2,zero,10001a30 <__swsetup_r+0x134>
100019e8:	81400c17 	ldw	r5,48(r16)
100019ec:	28000526 	beq	r5,zero,10001a04 <__swsetup_r+0x108>
100019f0:	80801004 	addi	r2,r16,64
100019f4:	28800226 	beq	r5,r2,10001a00 <__swsetup_r+0x104>
100019f8:	8809883a 	mov	r4,r17
100019fc:	00020540 	call	10002054 <_free_r>
10001a00:	80000c15 	stw	zero,48(r16)
10001a04:	8080030b 	ldhu	r2,12(r16)
10001a08:	81400417 	ldw	r5,16(r16)
10001a0c:	80000115 	stw	zero,4(r16)
10001a10:	10bff6cc 	andi	r2,r2,65499
10001a14:	8080030d 	sth	r2,12(r16)
10001a18:	81400015 	stw	r5,0(r16)
10001a1c:	8080030b 	ldhu	r2,12(r16)
10001a20:	10800214 	ori	r2,r2,8
10001a24:	113fffcc 	andi	r4,r2,65535
10001a28:	8080030d 	sth	r2,12(r16)
10001a2c:	003fc306 	br	1000193c <__swsetup_r+0x40>
10001a30:	81400417 	ldw	r5,16(r16)
10001a34:	003ff906 	br	10001a1c <__swsetup_r+0x120>

10001a38 <_fflush_r>:
10001a38:	defffb04 	addi	sp,sp,-20
10001a3c:	dcc00315 	stw	r19,12(sp)
10001a40:	dc800215 	stw	r18,8(sp)
10001a44:	dfc00415 	stw	ra,16(sp)
10001a48:	dc400115 	stw	r17,4(sp)
10001a4c:	dc000015 	stw	r16,0(sp)
10001a50:	2027883a 	mov	r19,r4
10001a54:	2825883a 	mov	r18,r5
10001a58:	20000226 	beq	r4,zero,10001a64 <_fflush_r+0x2c>
10001a5c:	20800e17 	ldw	r2,56(r4)
10001a60:	10005626 	beq	r2,zero,10001bbc <_fflush_r+0x184>
10001a64:	9100030b 	ldhu	r4,12(r18)
10001a68:	20ffffcc 	andi	r3,r4,65535
10001a6c:	18e0001c 	xori	r3,r3,32768
10001a70:	18e00004 	addi	r3,r3,-32768
10001a74:	1880020c 	andi	r2,r3,8
10001a78:	1000261e 	bne	r2,zero,10001b14 <_fflush_r+0xdc>
10001a7c:	90c00117 	ldw	r3,4(r18)
10001a80:	20820014 	ori	r2,r4,2048
10001a84:	9080030d 	sth	r2,12(r18)
10001a88:	1009883a 	mov	r4,r2
10001a8c:	00c0400e 	bge	zero,r3,10001b90 <_fflush_r+0x158>
10001a90:	92000a17 	ldw	r8,40(r18)
10001a94:	40004026 	beq	r8,zero,10001b98 <_fflush_r+0x160>
10001a98:	2084000c 	andi	r2,r4,4096
10001a9c:	10005326 	beq	r2,zero,10001bec <_fflush_r+0x1b4>
10001aa0:	94001417 	ldw	r16,80(r18)
10001aa4:	9080030b 	ldhu	r2,12(r18)
10001aa8:	1080010c 	andi	r2,r2,4
10001aac:	1000481e 	bne	r2,zero,10001bd0 <_fflush_r+0x198>
10001ab0:	91400717 	ldw	r5,28(r18)
10001ab4:	9809883a 	mov	r4,r19
10001ab8:	800d883a 	mov	r6,r16
10001abc:	000f883a 	mov	r7,zero
10001ac0:	403ee83a 	callr	r8
10001ac4:	8080261e 	bne	r16,r2,10001b60 <_fflush_r+0x128>
10001ac8:	9080030b 	ldhu	r2,12(r18)
10001acc:	91000417 	ldw	r4,16(r18)
10001ad0:	90000115 	stw	zero,4(r18)
10001ad4:	10bdffcc 	andi	r2,r2,63487
10001ad8:	10ffffcc 	andi	r3,r2,65535
10001adc:	18c4000c 	andi	r3,r3,4096
10001ae0:	9080030d 	sth	r2,12(r18)
10001ae4:	91000015 	stw	r4,0(r18)
10001ae8:	18002b26 	beq	r3,zero,10001b98 <_fflush_r+0x160>
10001aec:	0007883a 	mov	r3,zero
10001af0:	1805883a 	mov	r2,r3
10001af4:	94001415 	stw	r16,80(r18)
10001af8:	dfc00417 	ldw	ra,16(sp)
10001afc:	dcc00317 	ldw	r19,12(sp)
10001b00:	dc800217 	ldw	r18,8(sp)
10001b04:	dc400117 	ldw	r17,4(sp)
10001b08:	dc000017 	ldw	r16,0(sp)
10001b0c:	dec00504 	addi	sp,sp,20
10001b10:	f800283a 	ret
10001b14:	94400417 	ldw	r17,16(r18)
10001b18:	88001f26 	beq	r17,zero,10001b98 <_fflush_r+0x160>
10001b1c:	90800017 	ldw	r2,0(r18)
10001b20:	18c000cc 	andi	r3,r3,3
10001b24:	94400015 	stw	r17,0(r18)
10001b28:	1461c83a 	sub	r16,r2,r17
10001b2c:	18002526 	beq	r3,zero,10001bc4 <_fflush_r+0x18c>
10001b30:	0005883a 	mov	r2,zero
10001b34:	90800215 	stw	r2,8(r18)
10001b38:	0400170e 	bge	zero,r16,10001b98 <_fflush_r+0x160>
10001b3c:	90c00917 	ldw	r3,36(r18)
10001b40:	91400717 	ldw	r5,28(r18)
10001b44:	880d883a 	mov	r6,r17
10001b48:	800f883a 	mov	r7,r16
10001b4c:	9809883a 	mov	r4,r19
10001b50:	183ee83a 	callr	r3
10001b54:	88a3883a 	add	r17,r17,r2
10001b58:	80a1c83a 	sub	r16,r16,r2
10001b5c:	00bff616 	blt	zero,r2,10001b38 <_fflush_r+0x100>
10001b60:	9080030b 	ldhu	r2,12(r18)
10001b64:	00ffffc4 	movi	r3,-1
10001b68:	10801014 	ori	r2,r2,64
10001b6c:	9080030d 	sth	r2,12(r18)
10001b70:	1805883a 	mov	r2,r3
10001b74:	dfc00417 	ldw	ra,16(sp)
10001b78:	dcc00317 	ldw	r19,12(sp)
10001b7c:	dc800217 	ldw	r18,8(sp)
10001b80:	dc400117 	ldw	r17,4(sp)
10001b84:	dc000017 	ldw	r16,0(sp)
10001b88:	dec00504 	addi	sp,sp,20
10001b8c:	f800283a 	ret
10001b90:	90800f17 	ldw	r2,60(r18)
10001b94:	00bfbe16 	blt	zero,r2,10001a90 <_fflush_r+0x58>
10001b98:	0007883a 	mov	r3,zero
10001b9c:	1805883a 	mov	r2,r3
10001ba0:	dfc00417 	ldw	ra,16(sp)
10001ba4:	dcc00317 	ldw	r19,12(sp)
10001ba8:	dc800217 	ldw	r18,8(sp)
10001bac:	dc400117 	ldw	r17,4(sp)
10001bb0:	dc000017 	ldw	r16,0(sp)
10001bb4:	dec00504 	addi	sp,sp,20
10001bb8:	f800283a 	ret
10001bbc:	0001cd00 	call	10001cd0 <__sinit>
10001bc0:	003fa806 	br	10001a64 <_fflush_r+0x2c>
10001bc4:	90800517 	ldw	r2,20(r18)
10001bc8:	90800215 	stw	r2,8(r18)
10001bcc:	003fda06 	br	10001b38 <_fflush_r+0x100>
10001bd0:	90800117 	ldw	r2,4(r18)
10001bd4:	90c00c17 	ldw	r3,48(r18)
10001bd8:	80a1c83a 	sub	r16,r16,r2
10001bdc:	183fb426 	beq	r3,zero,10001ab0 <_fflush_r+0x78>
10001be0:	90800f17 	ldw	r2,60(r18)
10001be4:	80a1c83a 	sub	r16,r16,r2
10001be8:	003fb106 	br	10001ab0 <_fflush_r+0x78>
10001bec:	91400717 	ldw	r5,28(r18)
10001bf0:	9809883a 	mov	r4,r19
10001bf4:	000d883a 	mov	r6,zero
10001bf8:	01c00044 	movi	r7,1
10001bfc:	403ee83a 	callr	r8
10001c00:	1021883a 	mov	r16,r2
10001c04:	00bfffc4 	movi	r2,-1
10001c08:	80800226 	beq	r16,r2,10001c14 <_fflush_r+0x1dc>
10001c0c:	92000a17 	ldw	r8,40(r18)
10001c10:	003fa406 	br	10001aa4 <_fflush_r+0x6c>
10001c14:	98c00017 	ldw	r3,0(r19)
10001c18:	00800744 	movi	r2,29
10001c1c:	18bfde26 	beq	r3,r2,10001b98 <_fflush_r+0x160>
10001c20:	9080030b 	ldhu	r2,12(r18)
10001c24:	8007883a 	mov	r3,r16
10001c28:	10801014 	ori	r2,r2,64
10001c2c:	9080030d 	sth	r2,12(r18)
10001c30:	003fcf06 	br	10001b70 <_fflush_r+0x138>

10001c34 <fflush>:
10001c34:	01440034 	movhi	r5,4096
10001c38:	29468e04 	addi	r5,r5,6712
10001c3c:	2007883a 	mov	r3,r4
10001c40:	20000526 	beq	r4,zero,10001c58 <fflush+0x24>
10001c44:	00840074 	movhi	r2,4097
10001c48:	10aa0e04 	addi	r2,r2,-22472
10001c4c:	11000017 	ldw	r4,0(r2)
10001c50:	180b883a 	mov	r5,r3
10001c54:	0001a381 	jmpi	10001a38 <_fflush_r>
10001c58:	00840074 	movhi	r2,4097
10001c5c:	10aa0f04 	addi	r2,r2,-22468
10001c60:	11000017 	ldw	r4,0(r2)
10001c64:	00023681 	jmpi	10002368 <_fwalk_reent>

10001c68 <std>:
10001c68:	00840034 	movhi	r2,4096
10001c6c:	1089c504 	addi	r2,r2,10004
10001c70:	20800b15 	stw	r2,44(r4)
10001c74:	00840034 	movhi	r2,4096
10001c78:	108a0004 	addi	r2,r2,10240
10001c7c:	20800815 	stw	r2,32(r4)
10001c80:	00c40034 	movhi	r3,4096
10001c84:	18c9e104 	addi	r3,r3,10116
10001c88:	00840034 	movhi	r2,4096
10001c8c:	1089c704 	addi	r2,r2,10012
10001c90:	2140030d 	sth	r5,12(r4)
10001c94:	2180038d 	sth	r6,14(r4)
10001c98:	20c00915 	stw	r3,36(r4)
10001c9c:	20800a15 	stw	r2,40(r4)
10001ca0:	20000015 	stw	zero,0(r4)
10001ca4:	20000115 	stw	zero,4(r4)
10001ca8:	20000215 	stw	zero,8(r4)
10001cac:	20000415 	stw	zero,16(r4)
10001cb0:	20000515 	stw	zero,20(r4)
10001cb4:	20000615 	stw	zero,24(r4)
10001cb8:	21000715 	stw	r4,28(r4)
10001cbc:	f800283a 	ret

10001cc0 <__sfp_lock_acquire>:
10001cc0:	f800283a 	ret

10001cc4 <__sfp_lock_release>:
10001cc4:	f800283a 	ret

10001cc8 <__sinit_lock_acquire>:
10001cc8:	f800283a 	ret

10001ccc <__sinit_lock_release>:
10001ccc:	f800283a 	ret

10001cd0 <__sinit>:
10001cd0:	20800e17 	ldw	r2,56(r4)
10001cd4:	defffd04 	addi	sp,sp,-12
10001cd8:	dc400115 	stw	r17,4(sp)
10001cdc:	dc000015 	stw	r16,0(sp)
10001ce0:	dfc00215 	stw	ra,8(sp)
10001ce4:	04400044 	movi	r17,1
10001ce8:	01400104 	movi	r5,4
10001cec:	000d883a 	mov	r6,zero
10001cf0:	2021883a 	mov	r16,r4
10001cf4:	2200bb04 	addi	r8,r4,748
10001cf8:	200f883a 	mov	r7,r4
10001cfc:	10000526 	beq	r2,zero,10001d14 <__sinit+0x44>
10001d00:	dfc00217 	ldw	ra,8(sp)
10001d04:	dc400117 	ldw	r17,4(sp)
10001d08:	dc000017 	ldw	r16,0(sp)
10001d0c:	dec00304 	addi	sp,sp,12
10001d10:	f800283a 	ret
10001d14:	21000117 	ldw	r4,4(r4)
10001d18:	00840034 	movhi	r2,4096
10001d1c:	10876d04 	addi	r2,r2,7604
10001d20:	00c000c4 	movi	r3,3
10001d24:	80800f15 	stw	r2,60(r16)
10001d28:	80c0b915 	stw	r3,740(r16)
10001d2c:	8200ba15 	stw	r8,744(r16)
10001d30:	84400e15 	stw	r17,56(r16)
10001d34:	8000b815 	stw	zero,736(r16)
10001d38:	0001c680 	call	10001c68 <std>
10001d3c:	81000217 	ldw	r4,8(r16)
10001d40:	880d883a 	mov	r6,r17
10001d44:	800f883a 	mov	r7,r16
10001d48:	01400284 	movi	r5,10
10001d4c:	0001c680 	call	10001c68 <std>
10001d50:	81000317 	ldw	r4,12(r16)
10001d54:	800f883a 	mov	r7,r16
10001d58:	01400484 	movi	r5,18
10001d5c:	01800084 	movi	r6,2
10001d60:	dfc00217 	ldw	ra,8(sp)
10001d64:	dc400117 	ldw	r17,4(sp)
10001d68:	dc000017 	ldw	r16,0(sp)
10001d6c:	dec00304 	addi	sp,sp,12
10001d70:	0001c681 	jmpi	10001c68 <std>

10001d74 <__fp_lock>:
10001d74:	0005883a 	mov	r2,zero
10001d78:	f800283a 	ret

10001d7c <__fp_unlock>:
10001d7c:	0005883a 	mov	r2,zero
10001d80:	f800283a 	ret

10001d84 <__fp_unlock_all>:
10001d84:	00840074 	movhi	r2,4097
10001d88:	10aa0e04 	addi	r2,r2,-22472
10001d8c:	11000017 	ldw	r4,0(r2)
10001d90:	01440034 	movhi	r5,4096
10001d94:	29475f04 	addi	r5,r5,7548
10001d98:	00024301 	jmpi	10002430 <_fwalk>

10001d9c <__fp_lock_all>:
10001d9c:	00840074 	movhi	r2,4097
10001da0:	10aa0e04 	addi	r2,r2,-22472
10001da4:	11000017 	ldw	r4,0(r2)
10001da8:	01440034 	movhi	r5,4096
10001dac:	29475d04 	addi	r5,r5,7540
10001db0:	00024301 	jmpi	10002430 <_fwalk>

10001db4 <_cleanup_r>:
10001db4:	01440034 	movhi	r5,4096
10001db8:	294a9604 	addi	r5,r5,10840
10001dbc:	00024301 	jmpi	10002430 <_fwalk>

10001dc0 <_cleanup>:
10001dc0:	00840074 	movhi	r2,4097
10001dc4:	10aa0f04 	addi	r2,r2,-22468
10001dc8:	11000017 	ldw	r4,0(r2)
10001dcc:	0001db41 	jmpi	10001db4 <_cleanup_r>

10001dd0 <__sfmoreglue>:
10001dd0:	defffc04 	addi	sp,sp,-16
10001dd4:	dc400115 	stw	r17,4(sp)
10001dd8:	2c401724 	muli	r17,r5,92
10001ddc:	dc800215 	stw	r18,8(sp)
10001de0:	2825883a 	mov	r18,r5
10001de4:	89400304 	addi	r5,r17,12
10001de8:	dc000015 	stw	r16,0(sp)
10001dec:	dfc00315 	stw	ra,12(sp)
10001df0:	00008f40 	call	100008f4 <_malloc_r>
10001df4:	0021883a 	mov	r16,zero
10001df8:	880d883a 	mov	r6,r17
10001dfc:	000b883a 	mov	r5,zero
10001e00:	10000626 	beq	r2,zero,10001e1c <__sfmoreglue+0x4c>
10001e04:	11000304 	addi	r4,r2,12
10001e08:	14800115 	stw	r18,4(r2)
10001e0c:	10000015 	stw	zero,0(r2)
10001e10:	11000215 	stw	r4,8(r2)
10001e14:	1021883a 	mov	r16,r2
10001e18:	000267c0 	call	1000267c <memset>
10001e1c:	8005883a 	mov	r2,r16
10001e20:	dfc00317 	ldw	ra,12(sp)
10001e24:	dc800217 	ldw	r18,8(sp)
10001e28:	dc400117 	ldw	r17,4(sp)
10001e2c:	dc000017 	ldw	r16,0(sp)
10001e30:	dec00404 	addi	sp,sp,16
10001e34:	f800283a 	ret

10001e38 <__sfp>:
10001e38:	defffd04 	addi	sp,sp,-12
10001e3c:	00840074 	movhi	r2,4097
10001e40:	10aa0f04 	addi	r2,r2,-22468
10001e44:	dc000015 	stw	r16,0(sp)
10001e48:	14000017 	ldw	r16,0(r2)
10001e4c:	dc400115 	stw	r17,4(sp)
10001e50:	dfc00215 	stw	ra,8(sp)
10001e54:	80800e17 	ldw	r2,56(r16)
10001e58:	2023883a 	mov	r17,r4
10001e5c:	10002626 	beq	r2,zero,10001ef8 <__sfp+0xc0>
10001e60:	8400b804 	addi	r16,r16,736
10001e64:	80800117 	ldw	r2,4(r16)
10001e68:	81000217 	ldw	r4,8(r16)
10001e6c:	10ffffc4 	addi	r3,r2,-1
10001e70:	18000916 	blt	r3,zero,10001e98 <__sfp+0x60>
10001e74:	2080030f 	ldh	r2,12(r4)
10001e78:	10000b26 	beq	r2,zero,10001ea8 <__sfp+0x70>
10001e7c:	017fffc4 	movi	r5,-1
10001e80:	00000206 	br	10001e8c <__sfp+0x54>
10001e84:	2080030f 	ldh	r2,12(r4)
10001e88:	10000726 	beq	r2,zero,10001ea8 <__sfp+0x70>
10001e8c:	18ffffc4 	addi	r3,r3,-1
10001e90:	21001704 	addi	r4,r4,92
10001e94:	197ffb1e 	bne	r3,r5,10001e84 <__sfp+0x4c>
10001e98:	80800017 	ldw	r2,0(r16)
10001e9c:	10001926 	beq	r2,zero,10001f04 <__sfp+0xcc>
10001ea0:	1021883a 	mov	r16,r2
10001ea4:	003fef06 	br	10001e64 <__sfp+0x2c>
10001ea8:	00bfffc4 	movi	r2,-1
10001eac:	00c00044 	movi	r3,1
10001eb0:	2080038d 	sth	r2,14(r4)
10001eb4:	20c0030d 	sth	r3,12(r4)
10001eb8:	20000015 	stw	zero,0(r4)
10001ebc:	20000215 	stw	zero,8(r4)
10001ec0:	20000115 	stw	zero,4(r4)
10001ec4:	20000415 	stw	zero,16(r4)
10001ec8:	20000515 	stw	zero,20(r4)
10001ecc:	20000615 	stw	zero,24(r4)
10001ed0:	20000c15 	stw	zero,48(r4)
10001ed4:	20000d15 	stw	zero,52(r4)
10001ed8:	20001115 	stw	zero,68(r4)
10001edc:	20001215 	stw	zero,72(r4)
10001ee0:	2005883a 	mov	r2,r4
10001ee4:	dfc00217 	ldw	ra,8(sp)
10001ee8:	dc400117 	ldw	r17,4(sp)
10001eec:	dc000017 	ldw	r16,0(sp)
10001ef0:	dec00304 	addi	sp,sp,12
10001ef4:	f800283a 	ret
10001ef8:	8009883a 	mov	r4,r16
10001efc:	0001cd00 	call	10001cd0 <__sinit>
10001f00:	003fd706 	br	10001e60 <__sfp+0x28>
10001f04:	8809883a 	mov	r4,r17
10001f08:	01400104 	movi	r5,4
10001f0c:	0001dd00 	call	10001dd0 <__sfmoreglue>
10001f10:	80800015 	stw	r2,0(r16)
10001f14:	103fe21e 	bne	r2,zero,10001ea0 <__sfp+0x68>
10001f18:	00800304 	movi	r2,12
10001f1c:	0009883a 	mov	r4,zero
10001f20:	88800015 	stw	r2,0(r17)
10001f24:	003fee06 	br	10001ee0 <__sfp+0xa8>

10001f28 <_malloc_trim_r>:
10001f28:	defffb04 	addi	sp,sp,-20
10001f2c:	dcc00315 	stw	r19,12(sp)
10001f30:	04c40074 	movhi	r19,4097
10001f34:	9ce43c04 	addi	r19,r19,-28432
10001f38:	dc800215 	stw	r18,8(sp)
10001f3c:	dc400115 	stw	r17,4(sp)
10001f40:	dc000015 	stw	r16,0(sp)
10001f44:	2823883a 	mov	r17,r5
10001f48:	2025883a 	mov	r18,r4
10001f4c:	dfc00415 	stw	ra,16(sp)
10001f50:	00031d80 	call	100031d8 <__malloc_lock>
10001f54:	98800217 	ldw	r2,8(r19)
10001f58:	9009883a 	mov	r4,r18
10001f5c:	000b883a 	mov	r5,zero
10001f60:	10c00117 	ldw	r3,4(r2)
10001f64:	00bfff04 	movi	r2,-4
10001f68:	18a0703a 	and	r16,r3,r2
10001f6c:	8463c83a 	sub	r17,r16,r17
10001f70:	8c43fbc4 	addi	r17,r17,4079
10001f74:	8822d33a 	srli	r17,r17,12
10001f78:	0083ffc4 	movi	r2,4095
10001f7c:	8c7fffc4 	addi	r17,r17,-1
10001f80:	8822933a 	slli	r17,r17,12
10001f84:	1440060e 	bge	r2,r17,10001fa0 <_malloc_trim_r+0x78>
10001f88:	000188c0 	call	1000188c <_sbrk_r>
10001f8c:	98c00217 	ldw	r3,8(r19)
10001f90:	9009883a 	mov	r4,r18
10001f94:	044bc83a 	sub	r5,zero,r17
10001f98:	80c7883a 	add	r3,r16,r3
10001f9c:	10c00926 	beq	r2,r3,10001fc4 <_malloc_trim_r+0x9c>
10001fa0:	00031f80 	call	100031f8 <__malloc_unlock>
10001fa4:	0005883a 	mov	r2,zero
10001fa8:	dfc00417 	ldw	ra,16(sp)
10001fac:	dcc00317 	ldw	r19,12(sp)
10001fb0:	dc800217 	ldw	r18,8(sp)
10001fb4:	dc400117 	ldw	r17,4(sp)
10001fb8:	dc000017 	ldw	r16,0(sp)
10001fbc:	dec00504 	addi	sp,sp,20
10001fc0:	f800283a 	ret
10001fc4:	9009883a 	mov	r4,r18
10001fc8:	000188c0 	call	1000188c <_sbrk_r>
10001fcc:	844dc83a 	sub	r6,r16,r17
10001fd0:	00ffffc4 	movi	r3,-1
10001fd4:	9009883a 	mov	r4,r18
10001fd8:	000b883a 	mov	r5,zero
10001fdc:	01c40074 	movhi	r7,4097
10001fe0:	39ea2a04 	addi	r7,r7,-22360
10001fe4:	31800054 	ori	r6,r6,1
10001fe8:	10c00926 	beq	r2,r3,10002010 <_malloc_trim_r+0xe8>
10001fec:	38800017 	ldw	r2,0(r7)
10001ff0:	98c00217 	ldw	r3,8(r19)
10001ff4:	9009883a 	mov	r4,r18
10001ff8:	1445c83a 	sub	r2,r2,r17
10001ffc:	38800015 	stw	r2,0(r7)
10002000:	19800115 	stw	r6,4(r3)
10002004:	00031f80 	call	100031f8 <__malloc_unlock>
10002008:	00800044 	movi	r2,1
1000200c:	003fe606 	br	10001fa8 <_malloc_trim_r+0x80>
10002010:	000188c0 	call	1000188c <_sbrk_r>
10002014:	99800217 	ldw	r6,8(r19)
10002018:	100f883a 	mov	r7,r2
1000201c:	9009883a 	mov	r4,r18
10002020:	1187c83a 	sub	r3,r2,r6
10002024:	008003c4 	movi	r2,15
10002028:	19400054 	ori	r5,r3,1
1000202c:	10ffdc0e 	bge	r2,r3,10001fa0 <_malloc_trim_r+0x78>
10002030:	00840074 	movhi	r2,4097
10002034:	10aa1104 	addi	r2,r2,-22460
10002038:	10c00017 	ldw	r3,0(r2)
1000203c:	00840074 	movhi	r2,4097
10002040:	10aa2a04 	addi	r2,r2,-22360
10002044:	31400115 	stw	r5,4(r6)
10002048:	38c7c83a 	sub	r3,r7,r3
1000204c:	10c00015 	stw	r3,0(r2)
10002050:	003fd306 	br	10001fa0 <_malloc_trim_r+0x78>

10002054 <_free_r>:
10002054:	defffd04 	addi	sp,sp,-12
10002058:	dc400115 	stw	r17,4(sp)
1000205c:	dc000015 	stw	r16,0(sp)
10002060:	dfc00215 	stw	ra,8(sp)
10002064:	2821883a 	mov	r16,r5
10002068:	2023883a 	mov	r17,r4
1000206c:	28005a26 	beq	r5,zero,100021d8 <_free_r+0x184>
10002070:	00031d80 	call	100031d8 <__malloc_lock>
10002074:	823ffe04 	addi	r8,r16,-8
10002078:	41400117 	ldw	r5,4(r8)
1000207c:	00bfff84 	movi	r2,-2
10002080:	02840074 	movhi	r10,4097
10002084:	52a43c04 	addi	r10,r10,-28432
10002088:	288e703a 	and	r7,r5,r2
1000208c:	41cd883a 	add	r6,r8,r7
10002090:	30c00117 	ldw	r3,4(r6)
10002094:	51000217 	ldw	r4,8(r10)
10002098:	00bfff04 	movi	r2,-4
1000209c:	1892703a 	and	r9,r3,r2
100020a0:	5017883a 	mov	r11,r10
100020a4:	31006726 	beq	r6,r4,10002244 <_free_r+0x1f0>
100020a8:	2880004c 	andi	r2,r5,1
100020ac:	1005003a 	cmpeq	r2,r2,zero
100020b0:	32400115 	stw	r9,4(r6)
100020b4:	10001a1e 	bne	r2,zero,10002120 <_free_r+0xcc>
100020b8:	000b883a 	mov	r5,zero
100020bc:	3247883a 	add	r3,r6,r9
100020c0:	18800117 	ldw	r2,4(r3)
100020c4:	1080004c 	andi	r2,r2,1
100020c8:	1000231e 	bne	r2,zero,10002158 <_free_r+0x104>
100020cc:	280ac03a 	cmpne	r5,r5,zero
100020d0:	3a4f883a 	add	r7,r7,r9
100020d4:	2800451e 	bne	r5,zero,100021ec <_free_r+0x198>
100020d8:	31000217 	ldw	r4,8(r6)
100020dc:	00840074 	movhi	r2,4097
100020e0:	10a43e04 	addi	r2,r2,-28424
100020e4:	20807b26 	beq	r4,r2,100022d4 <_free_r+0x280>
100020e8:	30800317 	ldw	r2,12(r6)
100020ec:	3a07883a 	add	r3,r7,r8
100020f0:	19c00015 	stw	r7,0(r3)
100020f4:	11000215 	stw	r4,8(r2)
100020f8:	20800315 	stw	r2,12(r4)
100020fc:	38800054 	ori	r2,r7,1
10002100:	40800115 	stw	r2,4(r8)
10002104:	28001a26 	beq	r5,zero,10002170 <_free_r+0x11c>
10002108:	8809883a 	mov	r4,r17
1000210c:	dfc00217 	ldw	ra,8(sp)
10002110:	dc400117 	ldw	r17,4(sp)
10002114:	dc000017 	ldw	r16,0(sp)
10002118:	dec00304 	addi	sp,sp,12
1000211c:	00031f81 	jmpi	100031f8 <__malloc_unlock>
10002120:	80bffe17 	ldw	r2,-8(r16)
10002124:	50c00204 	addi	r3,r10,8
10002128:	4091c83a 	sub	r8,r8,r2
1000212c:	41000217 	ldw	r4,8(r8)
10002130:	388f883a 	add	r7,r7,r2
10002134:	20c06126 	beq	r4,r3,100022bc <_free_r+0x268>
10002138:	40800317 	ldw	r2,12(r8)
1000213c:	3247883a 	add	r3,r6,r9
10002140:	000b883a 	mov	r5,zero
10002144:	11000215 	stw	r4,8(r2)
10002148:	20800315 	stw	r2,12(r4)
1000214c:	18800117 	ldw	r2,4(r3)
10002150:	1080004c 	andi	r2,r2,1
10002154:	103fdd26 	beq	r2,zero,100020cc <_free_r+0x78>
10002158:	38800054 	ori	r2,r7,1
1000215c:	3a07883a 	add	r3,r7,r8
10002160:	280ac03a 	cmpne	r5,r5,zero
10002164:	40800115 	stw	r2,4(r8)
10002168:	19c00015 	stw	r7,0(r3)
1000216c:	283fe61e 	bne	r5,zero,10002108 <_free_r+0xb4>
10002170:	00807fc4 	movi	r2,511
10002174:	11c01f2e 	bgeu	r2,r7,100021f4 <_free_r+0x1a0>
10002178:	3806d27a 	srli	r3,r7,9
1000217c:	1800481e 	bne	r3,zero,100022a0 <_free_r+0x24c>
10002180:	3804d0fa 	srli	r2,r7,3
10002184:	100690fa 	slli	r3,r2,3
10002188:	1acd883a 	add	r6,r3,r11
1000218c:	31400217 	ldw	r5,8(r6)
10002190:	31405926 	beq	r6,r5,100022f8 <_free_r+0x2a4>
10002194:	28800117 	ldw	r2,4(r5)
10002198:	00ffff04 	movi	r3,-4
1000219c:	10c4703a 	and	r2,r2,r3
100021a0:	3880022e 	bgeu	r7,r2,100021ac <_free_r+0x158>
100021a4:	29400217 	ldw	r5,8(r5)
100021a8:	317ffa1e 	bne	r6,r5,10002194 <_free_r+0x140>
100021ac:	29800317 	ldw	r6,12(r5)
100021b0:	41800315 	stw	r6,12(r8)
100021b4:	41400215 	stw	r5,8(r8)
100021b8:	8809883a 	mov	r4,r17
100021bc:	2a000315 	stw	r8,12(r5)
100021c0:	32000215 	stw	r8,8(r6)
100021c4:	dfc00217 	ldw	ra,8(sp)
100021c8:	dc400117 	ldw	r17,4(sp)
100021cc:	dc000017 	ldw	r16,0(sp)
100021d0:	dec00304 	addi	sp,sp,12
100021d4:	00031f81 	jmpi	100031f8 <__malloc_unlock>
100021d8:	dfc00217 	ldw	ra,8(sp)
100021dc:	dc400117 	ldw	r17,4(sp)
100021e0:	dc000017 	ldw	r16,0(sp)
100021e4:	dec00304 	addi	sp,sp,12
100021e8:	f800283a 	ret
100021ec:	31000217 	ldw	r4,8(r6)
100021f0:	003fbd06 	br	100020e8 <_free_r+0x94>
100021f4:	3806d0fa 	srli	r3,r7,3
100021f8:	00800044 	movi	r2,1
100021fc:	51400117 	ldw	r5,4(r10)
10002200:	180890fa 	slli	r4,r3,3
10002204:	1807d0ba 	srai	r3,r3,2
10002208:	22c9883a 	add	r4,r4,r11
1000220c:	21800217 	ldw	r6,8(r4)
10002210:	10c4983a 	sll	r2,r2,r3
10002214:	41000315 	stw	r4,12(r8)
10002218:	41800215 	stw	r6,8(r8)
1000221c:	288ab03a 	or	r5,r5,r2
10002220:	22000215 	stw	r8,8(r4)
10002224:	8809883a 	mov	r4,r17
10002228:	51400115 	stw	r5,4(r10)
1000222c:	32000315 	stw	r8,12(r6)
10002230:	dfc00217 	ldw	ra,8(sp)
10002234:	dc400117 	ldw	r17,4(sp)
10002238:	dc000017 	ldw	r16,0(sp)
1000223c:	dec00304 	addi	sp,sp,12
10002240:	00031f81 	jmpi	100031f8 <__malloc_unlock>
10002244:	2880004c 	andi	r2,r5,1
10002248:	3a4d883a 	add	r6,r7,r9
1000224c:	1000071e 	bne	r2,zero,1000226c <_free_r+0x218>
10002250:	80bffe17 	ldw	r2,-8(r16)
10002254:	4091c83a 	sub	r8,r8,r2
10002258:	41000317 	ldw	r4,12(r8)
1000225c:	40c00217 	ldw	r3,8(r8)
10002260:	308d883a 	add	r6,r6,r2
10002264:	20c00215 	stw	r3,8(r4)
10002268:	19000315 	stw	r4,12(r3)
1000226c:	00840074 	movhi	r2,4097
10002270:	10aa1004 	addi	r2,r2,-22464
10002274:	11000017 	ldw	r4,0(r2)
10002278:	30c00054 	ori	r3,r6,1
1000227c:	52000215 	stw	r8,8(r10)
10002280:	40c00115 	stw	r3,4(r8)
10002284:	313fa036 	bltu	r6,r4,10002108 <_free_r+0xb4>
10002288:	00840074 	movhi	r2,4097
1000228c:	10aa2004 	addi	r2,r2,-22400
10002290:	11400017 	ldw	r5,0(r2)
10002294:	8809883a 	mov	r4,r17
10002298:	0001f280 	call	10001f28 <_malloc_trim_r>
1000229c:	003f9a06 	br	10002108 <_free_r+0xb4>
100022a0:	00800104 	movi	r2,4
100022a4:	10c0072e 	bgeu	r2,r3,100022c4 <_free_r+0x270>
100022a8:	00800504 	movi	r2,20
100022ac:	10c01936 	bltu	r2,r3,10002314 <_free_r+0x2c0>
100022b0:	188016c4 	addi	r2,r3,91
100022b4:	100690fa 	slli	r3,r2,3
100022b8:	003fb306 	br	10002188 <_free_r+0x134>
100022bc:	01400044 	movi	r5,1
100022c0:	003f7e06 	br	100020bc <_free_r+0x68>
100022c4:	3804d1ba 	srli	r2,r7,6
100022c8:	10800e04 	addi	r2,r2,56
100022cc:	100690fa 	slli	r3,r2,3
100022d0:	003fad06 	br	10002188 <_free_r+0x134>
100022d4:	22000315 	stw	r8,12(r4)
100022d8:	22000215 	stw	r8,8(r4)
100022dc:	3a05883a 	add	r2,r7,r8
100022e0:	38c00054 	ori	r3,r7,1
100022e4:	11c00015 	stw	r7,0(r2)
100022e8:	41000215 	stw	r4,8(r8)
100022ec:	40c00115 	stw	r3,4(r8)
100022f0:	41000315 	stw	r4,12(r8)
100022f4:	003f8406 	br	10002108 <_free_r+0xb4>
100022f8:	1005d0ba 	srai	r2,r2,2
100022fc:	00c00044 	movi	r3,1
10002300:	51000117 	ldw	r4,4(r10)
10002304:	1886983a 	sll	r3,r3,r2
10002308:	20c8b03a 	or	r4,r4,r3
1000230c:	51000115 	stw	r4,4(r10)
10002310:	003fa706 	br	100021b0 <_free_r+0x15c>
10002314:	00801504 	movi	r2,84
10002318:	10c00436 	bltu	r2,r3,1000232c <_free_r+0x2d8>
1000231c:	3804d33a 	srli	r2,r7,12
10002320:	10801b84 	addi	r2,r2,110
10002324:	100690fa 	slli	r3,r2,3
10002328:	003f9706 	br	10002188 <_free_r+0x134>
1000232c:	00805504 	movi	r2,340
10002330:	10c00436 	bltu	r2,r3,10002344 <_free_r+0x2f0>
10002334:	3804d3fa 	srli	r2,r7,15
10002338:	10801dc4 	addi	r2,r2,119
1000233c:	100690fa 	slli	r3,r2,3
10002340:	003f9106 	br	10002188 <_free_r+0x134>
10002344:	00815504 	movi	r2,1364
10002348:	10c0032e 	bgeu	r2,r3,10002358 <_free_r+0x304>
1000234c:	00801f84 	movi	r2,126
10002350:	00c0fc04 	movi	r3,1008
10002354:	003f8c06 	br	10002188 <_free_r+0x134>
10002358:	3804d4ba 	srli	r2,r7,18
1000235c:	10801f04 	addi	r2,r2,124
10002360:	100690fa 	slli	r3,r2,3
10002364:	003f8806 	br	10002188 <_free_r+0x134>

10002368 <_fwalk_reent>:
10002368:	defff704 	addi	sp,sp,-36
1000236c:	dcc00315 	stw	r19,12(sp)
10002370:	24c0b804 	addi	r19,r4,736
10002374:	dd800615 	stw	r22,24(sp)
10002378:	dd400515 	stw	r21,20(sp)
1000237c:	dfc00815 	stw	ra,32(sp)
10002380:	ddc00715 	stw	r23,28(sp)
10002384:	dd000415 	stw	r20,16(sp)
10002388:	dc800215 	stw	r18,8(sp)
1000238c:	dc400115 	stw	r17,4(sp)
10002390:	dc000015 	stw	r16,0(sp)
10002394:	202b883a 	mov	r21,r4
10002398:	282d883a 	mov	r22,r5
1000239c:	0001cc00 	call	10001cc0 <__sfp_lock_acquire>
100023a0:	98002126 	beq	r19,zero,10002428 <_fwalk_reent+0xc0>
100023a4:	002f883a 	mov	r23,zero
100023a8:	9c800117 	ldw	r18,4(r19)
100023ac:	9c000217 	ldw	r16,8(r19)
100023b0:	90bfffc4 	addi	r2,r18,-1
100023b4:	10000d16 	blt	r2,zero,100023ec <_fwalk_reent+0x84>
100023b8:	0023883a 	mov	r17,zero
100023bc:	053fffc4 	movi	r20,-1
100023c0:	8080030f 	ldh	r2,12(r16)
100023c4:	8c400044 	addi	r17,r17,1
100023c8:	10000626 	beq	r2,zero,100023e4 <_fwalk_reent+0x7c>
100023cc:	8080038f 	ldh	r2,14(r16)
100023d0:	800b883a 	mov	r5,r16
100023d4:	a809883a 	mov	r4,r21
100023d8:	15000226 	beq	r2,r20,100023e4 <_fwalk_reent+0x7c>
100023dc:	b03ee83a 	callr	r22
100023e0:	b8aeb03a 	or	r23,r23,r2
100023e4:	84001704 	addi	r16,r16,92
100023e8:	947ff51e 	bne	r18,r17,100023c0 <_fwalk_reent+0x58>
100023ec:	9cc00017 	ldw	r19,0(r19)
100023f0:	983fed1e 	bne	r19,zero,100023a8 <_fwalk_reent+0x40>
100023f4:	0001cc40 	call	10001cc4 <__sfp_lock_release>
100023f8:	b805883a 	mov	r2,r23
100023fc:	dfc00817 	ldw	ra,32(sp)
10002400:	ddc00717 	ldw	r23,28(sp)
10002404:	dd800617 	ldw	r22,24(sp)
10002408:	dd400517 	ldw	r21,20(sp)
1000240c:	dd000417 	ldw	r20,16(sp)
10002410:	dcc00317 	ldw	r19,12(sp)
10002414:	dc800217 	ldw	r18,8(sp)
10002418:	dc400117 	ldw	r17,4(sp)
1000241c:	dc000017 	ldw	r16,0(sp)
10002420:	dec00904 	addi	sp,sp,36
10002424:	f800283a 	ret
10002428:	002f883a 	mov	r23,zero
1000242c:	003ff106 	br	100023f4 <_fwalk_reent+0x8c>

10002430 <_fwalk>:
10002430:	defff804 	addi	sp,sp,-32
10002434:	dcc00315 	stw	r19,12(sp)
10002438:	24c0b804 	addi	r19,r4,736
1000243c:	dd400515 	stw	r21,20(sp)
10002440:	dfc00715 	stw	ra,28(sp)
10002444:	dd800615 	stw	r22,24(sp)
10002448:	dd000415 	stw	r20,16(sp)
1000244c:	dc800215 	stw	r18,8(sp)
10002450:	dc400115 	stw	r17,4(sp)
10002454:	dc000015 	stw	r16,0(sp)
10002458:	282b883a 	mov	r21,r5
1000245c:	0001cc00 	call	10001cc0 <__sfp_lock_acquire>
10002460:	98001f26 	beq	r19,zero,100024e0 <_fwalk+0xb0>
10002464:	002d883a 	mov	r22,zero
10002468:	9c800117 	ldw	r18,4(r19)
1000246c:	9c000217 	ldw	r16,8(r19)
10002470:	90bfffc4 	addi	r2,r18,-1
10002474:	10000c16 	blt	r2,zero,100024a8 <_fwalk+0x78>
10002478:	0023883a 	mov	r17,zero
1000247c:	053fffc4 	movi	r20,-1
10002480:	8080030f 	ldh	r2,12(r16)
10002484:	8c400044 	addi	r17,r17,1
10002488:	10000526 	beq	r2,zero,100024a0 <_fwalk+0x70>
1000248c:	8080038f 	ldh	r2,14(r16)
10002490:	8009883a 	mov	r4,r16
10002494:	15000226 	beq	r2,r20,100024a0 <_fwalk+0x70>
10002498:	a83ee83a 	callr	r21
1000249c:	b0acb03a 	or	r22,r22,r2
100024a0:	84001704 	addi	r16,r16,92
100024a4:	947ff61e 	bne	r18,r17,10002480 <_fwalk+0x50>
100024a8:	9cc00017 	ldw	r19,0(r19)
100024ac:	983fee1e 	bne	r19,zero,10002468 <_fwalk+0x38>
100024b0:	0001cc40 	call	10001cc4 <__sfp_lock_release>
100024b4:	b005883a 	mov	r2,r22
100024b8:	dfc00717 	ldw	ra,28(sp)
100024bc:	dd800617 	ldw	r22,24(sp)
100024c0:	dd400517 	ldw	r21,20(sp)
100024c4:	dd000417 	ldw	r20,16(sp)
100024c8:	dcc00317 	ldw	r19,12(sp)
100024cc:	dc800217 	ldw	r18,8(sp)
100024d0:	dc400117 	ldw	r17,4(sp)
100024d4:	dc000017 	ldw	r16,0(sp)
100024d8:	dec00804 	addi	sp,sp,32
100024dc:	f800283a 	ret
100024e0:	002d883a 	mov	r22,zero
100024e4:	003ff206 	br	100024b0 <_fwalk+0x80>

100024e8 <__smakebuf_r>:
100024e8:	2880030b 	ldhu	r2,12(r5)
100024ec:	deffed04 	addi	sp,sp,-76
100024f0:	dc401015 	stw	r17,64(sp)
100024f4:	1080008c 	andi	r2,r2,2
100024f8:	dc000f15 	stw	r16,60(sp)
100024fc:	dfc01215 	stw	ra,72(sp)
10002500:	dc801115 	stw	r18,68(sp)
10002504:	2821883a 	mov	r16,r5
10002508:	2023883a 	mov	r17,r4
1000250c:	10000b26 	beq	r2,zero,1000253c <__smakebuf_r+0x54>
10002510:	28c010c4 	addi	r3,r5,67
10002514:	00800044 	movi	r2,1
10002518:	28800515 	stw	r2,20(r5)
1000251c:	28c00415 	stw	r3,16(r5)
10002520:	28c00015 	stw	r3,0(r5)
10002524:	dfc01217 	ldw	ra,72(sp)
10002528:	dc801117 	ldw	r18,68(sp)
1000252c:	dc401017 	ldw	r17,64(sp)
10002530:	dc000f17 	ldw	r16,60(sp)
10002534:	dec01304 	addi	sp,sp,76
10002538:	f800283a 	ret
1000253c:	2940038f 	ldh	r5,14(r5)
10002540:	28002116 	blt	r5,zero,100025c8 <__smakebuf_r+0xe0>
10002544:	d80d883a 	mov	r6,sp
10002548:	0002a6c0 	call	10002a6c <_fstat_r>
1000254c:	10001e16 	blt	r2,zero,100025c8 <__smakebuf_r+0xe0>
10002550:	d8800117 	ldw	r2,4(sp)
10002554:	00e00014 	movui	r3,32768
10002558:	113c000c 	andi	r4,r2,61440
1000255c:	20c03126 	beq	r4,r3,10002624 <__smakebuf_r+0x13c>
10002560:	8080030b 	ldhu	r2,12(r16)
10002564:	00c80004 	movi	r3,8192
10002568:	10820014 	ori	r2,r2,2048
1000256c:	8080030d 	sth	r2,12(r16)
10002570:	20c01e26 	beq	r4,r3,100025ec <__smakebuf_r+0x104>
10002574:	04810004 	movi	r18,1024
10002578:	8809883a 	mov	r4,r17
1000257c:	900b883a 	mov	r5,r18
10002580:	00008f40 	call	100008f4 <_malloc_r>
10002584:	1009883a 	mov	r4,r2
10002588:	10003126 	beq	r2,zero,10002650 <__smakebuf_r+0x168>
1000258c:	80c0030b 	ldhu	r3,12(r16)
10002590:	00840034 	movhi	r2,4096
10002594:	10876d04 	addi	r2,r2,7604
10002598:	88800f15 	stw	r2,60(r17)
1000259c:	18c02014 	ori	r3,r3,128
100025a0:	84800515 	stw	r18,20(r16)
100025a4:	80c0030d 	sth	r3,12(r16)
100025a8:	81000415 	stw	r4,16(r16)
100025ac:	81000015 	stw	r4,0(r16)
100025b0:	dfc01217 	ldw	ra,72(sp)
100025b4:	dc801117 	ldw	r18,68(sp)
100025b8:	dc401017 	ldw	r17,64(sp)
100025bc:	dc000f17 	ldw	r16,60(sp)
100025c0:	dec01304 	addi	sp,sp,76
100025c4:	f800283a 	ret
100025c8:	80c0030b 	ldhu	r3,12(r16)
100025cc:	1880200c 	andi	r2,r3,128
100025d0:	10000426 	beq	r2,zero,100025e4 <__smakebuf_r+0xfc>
100025d4:	04801004 	movi	r18,64
100025d8:	18820014 	ori	r2,r3,2048
100025dc:	8080030d 	sth	r2,12(r16)
100025e0:	003fe506 	br	10002578 <__smakebuf_r+0x90>
100025e4:	04810004 	movi	r18,1024
100025e8:	003ffb06 	br	100025d8 <__smakebuf_r+0xf0>
100025ec:	8140038f 	ldh	r5,14(r16)
100025f0:	8809883a 	mov	r4,r17
100025f4:	0002ae00 	call	10002ae0 <_isatty_r>
100025f8:	103fde26 	beq	r2,zero,10002574 <__smakebuf_r+0x8c>
100025fc:	8080030b 	ldhu	r2,12(r16)
10002600:	80c010c4 	addi	r3,r16,67
10002604:	04810004 	movi	r18,1024
10002608:	10800054 	ori	r2,r2,1
1000260c:	8080030d 	sth	r2,12(r16)
10002610:	00800044 	movi	r2,1
10002614:	80c00415 	stw	r3,16(r16)
10002618:	80800515 	stw	r2,20(r16)
1000261c:	80c00015 	stw	r3,0(r16)
10002620:	003fd506 	br	10002578 <__smakebuf_r+0x90>
10002624:	80c00a17 	ldw	r3,40(r16)
10002628:	00840034 	movhi	r2,4096
1000262c:	1089c704 	addi	r2,r2,10012
10002630:	18bfcb1e 	bne	r3,r2,10002560 <__smakebuf_r+0x78>
10002634:	8080030b 	ldhu	r2,12(r16)
10002638:	00c10004 	movi	r3,1024
1000263c:	1825883a 	mov	r18,r3
10002640:	10c4b03a 	or	r2,r2,r3
10002644:	8080030d 	sth	r2,12(r16)
10002648:	80c01315 	stw	r3,76(r16)
1000264c:	003fca06 	br	10002578 <__smakebuf_r+0x90>
10002650:	8100030b 	ldhu	r4,12(r16)
10002654:	2080800c 	andi	r2,r4,512
10002658:	103fb21e 	bne	r2,zero,10002524 <__smakebuf_r+0x3c>
1000265c:	80c010c4 	addi	r3,r16,67
10002660:	21000094 	ori	r4,r4,2
10002664:	00800044 	movi	r2,1
10002668:	80800515 	stw	r2,20(r16)
1000266c:	8100030d 	sth	r4,12(r16)
10002670:	80c00415 	stw	r3,16(r16)
10002674:	80c00015 	stw	r3,0(r16)
10002678:	003faa06 	br	10002524 <__smakebuf_r+0x3c>

1000267c <memset>:
1000267c:	008000c4 	movi	r2,3
10002680:	29403fcc 	andi	r5,r5,255
10002684:	2007883a 	mov	r3,r4
10002688:	1180022e 	bgeu	r2,r6,10002694 <memset+0x18>
1000268c:	2084703a 	and	r2,r4,r2
10002690:	10000826 	beq	r2,zero,100026b4 <memset+0x38>
10002694:	30000526 	beq	r6,zero,100026ac <memset+0x30>
10002698:	2805883a 	mov	r2,r5
1000269c:	30cd883a 	add	r6,r6,r3
100026a0:	18800005 	stb	r2,0(r3)
100026a4:	18c00044 	addi	r3,r3,1
100026a8:	19bffd1e 	bne	r3,r6,100026a0 <memset+0x24>
100026ac:	2005883a 	mov	r2,r4
100026b0:	f800283a 	ret
100026b4:	2804923a 	slli	r2,r5,8
100026b8:	020003c4 	movi	r8,15
100026bc:	200f883a 	mov	r7,r4
100026c0:	2884b03a 	or	r2,r5,r2
100026c4:	1006943a 	slli	r3,r2,16
100026c8:	10c6b03a 	or	r3,r2,r3
100026cc:	41800a2e 	bgeu	r8,r6,100026f8 <memset+0x7c>
100026d0:	4005883a 	mov	r2,r8
100026d4:	31bffc04 	addi	r6,r6,-16
100026d8:	38c00015 	stw	r3,0(r7)
100026dc:	38c00115 	stw	r3,4(r7)
100026e0:	38c00215 	stw	r3,8(r7)
100026e4:	38c00315 	stw	r3,12(r7)
100026e8:	39c00404 	addi	r7,r7,16
100026ec:	11bff936 	bltu	r2,r6,100026d4 <memset+0x58>
100026f0:	008000c4 	movi	r2,3
100026f4:	1180052e 	bgeu	r2,r6,1000270c <memset+0x90>
100026f8:	31bfff04 	addi	r6,r6,-4
100026fc:	008000c4 	movi	r2,3
10002700:	38c00015 	stw	r3,0(r7)
10002704:	39c00104 	addi	r7,r7,4
10002708:	11bffb36 	bltu	r2,r6,100026f8 <memset+0x7c>
1000270c:	3807883a 	mov	r3,r7
10002710:	003fe006 	br	10002694 <memset+0x18>

10002714 <__sclose>:
10002714:	2940038f 	ldh	r5,14(r5)
10002718:	00028d81 	jmpi	100028d8 <_close_r>

1000271c <__sseek>:
1000271c:	defffe04 	addi	sp,sp,-8
10002720:	dc000015 	stw	r16,0(sp)
10002724:	2821883a 	mov	r16,r5
10002728:	2940038f 	ldh	r5,14(r5)
1000272c:	dfc00115 	stw	ra,4(sp)
10002730:	0002b500 	call	10002b50 <_lseek_r>
10002734:	1007883a 	mov	r3,r2
10002738:	00bfffc4 	movi	r2,-1
1000273c:	18800926 	beq	r3,r2,10002764 <__sseek+0x48>
10002740:	8080030b 	ldhu	r2,12(r16)
10002744:	80c01415 	stw	r3,80(r16)
10002748:	10840014 	ori	r2,r2,4096
1000274c:	8080030d 	sth	r2,12(r16)
10002750:	1805883a 	mov	r2,r3
10002754:	dfc00117 	ldw	ra,4(sp)
10002758:	dc000017 	ldw	r16,0(sp)
1000275c:	dec00204 	addi	sp,sp,8
10002760:	f800283a 	ret
10002764:	8080030b 	ldhu	r2,12(r16)
10002768:	10bbffcc 	andi	r2,r2,61439
1000276c:	8080030d 	sth	r2,12(r16)
10002770:	1805883a 	mov	r2,r3
10002774:	dfc00117 	ldw	ra,4(sp)
10002778:	dc000017 	ldw	r16,0(sp)
1000277c:	dec00204 	addi	sp,sp,8
10002780:	f800283a 	ret

10002784 <__swrite>:
10002784:	2880030b 	ldhu	r2,12(r5)
10002788:	defffb04 	addi	sp,sp,-20
1000278c:	dcc00315 	stw	r19,12(sp)
10002790:	1080400c 	andi	r2,r2,256
10002794:	dc800215 	stw	r18,8(sp)
10002798:	dc400115 	stw	r17,4(sp)
1000279c:	dc000015 	stw	r16,0(sp)
100027a0:	3027883a 	mov	r19,r6
100027a4:	3825883a 	mov	r18,r7
100027a8:	dfc00415 	stw	ra,16(sp)
100027ac:	2821883a 	mov	r16,r5
100027b0:	000d883a 	mov	r6,zero
100027b4:	01c00084 	movi	r7,2
100027b8:	2023883a 	mov	r17,r4
100027bc:	10000226 	beq	r2,zero,100027c8 <__swrite+0x44>
100027c0:	2940038f 	ldh	r5,14(r5)
100027c4:	0002b500 	call	10002b50 <_lseek_r>
100027c8:	8080030b 	ldhu	r2,12(r16)
100027cc:	8140038f 	ldh	r5,14(r16)
100027d0:	8809883a 	mov	r4,r17
100027d4:	10bbffcc 	andi	r2,r2,61439
100027d8:	980d883a 	mov	r6,r19
100027dc:	900f883a 	mov	r7,r18
100027e0:	8080030d 	sth	r2,12(r16)
100027e4:	dfc00417 	ldw	ra,16(sp)
100027e8:	dcc00317 	ldw	r19,12(sp)
100027ec:	dc800217 	ldw	r18,8(sp)
100027f0:	dc400117 	ldw	r17,4(sp)
100027f4:	dc000017 	ldw	r16,0(sp)
100027f8:	dec00504 	addi	sp,sp,20
100027fc:	00028601 	jmpi	10002860 <_write_r>

10002800 <__sread>:
10002800:	defffe04 	addi	sp,sp,-8
10002804:	dc000015 	stw	r16,0(sp)
10002808:	2821883a 	mov	r16,r5
1000280c:	2940038f 	ldh	r5,14(r5)
10002810:	dfc00115 	stw	ra,4(sp)
10002814:	0002bc80 	call	10002bc8 <_read_r>
10002818:	1007883a 	mov	r3,r2
1000281c:	10000816 	blt	r2,zero,10002840 <__sread+0x40>
10002820:	80801417 	ldw	r2,80(r16)
10002824:	10c5883a 	add	r2,r2,r3
10002828:	80801415 	stw	r2,80(r16)
1000282c:	1805883a 	mov	r2,r3
10002830:	dfc00117 	ldw	ra,4(sp)
10002834:	dc000017 	ldw	r16,0(sp)
10002838:	dec00204 	addi	sp,sp,8
1000283c:	f800283a 	ret
10002840:	8080030b 	ldhu	r2,12(r16)
10002844:	10bbffcc 	andi	r2,r2,61439
10002848:	8080030d 	sth	r2,12(r16)
1000284c:	1805883a 	mov	r2,r3
10002850:	dfc00117 	ldw	ra,4(sp)
10002854:	dc000017 	ldw	r16,0(sp)
10002858:	dec00204 	addi	sp,sp,8
1000285c:	f800283a 	ret

10002860 <_write_r>:
10002860:	defffd04 	addi	sp,sp,-12
10002864:	dc000015 	stw	r16,0(sp)
10002868:	04040074 	movhi	r16,4097
1000286c:	842a2304 	addi	r16,r16,-22388
10002870:	dc400115 	stw	r17,4(sp)
10002874:	80000015 	stw	zero,0(r16)
10002878:	2023883a 	mov	r17,r4
1000287c:	2809883a 	mov	r4,r5
10002880:	300b883a 	mov	r5,r6
10002884:	380d883a 	mov	r6,r7
10002888:	dfc00215 	stw	ra,8(sp)
1000288c:	00034b40 	call	100034b4 <write>
10002890:	1007883a 	mov	r3,r2
10002894:	00bfffc4 	movi	r2,-1
10002898:	18800626 	beq	r3,r2,100028b4 <_write_r+0x54>
1000289c:	1805883a 	mov	r2,r3
100028a0:	dfc00217 	ldw	ra,8(sp)
100028a4:	dc400117 	ldw	r17,4(sp)
100028a8:	dc000017 	ldw	r16,0(sp)
100028ac:	dec00304 	addi	sp,sp,12
100028b0:	f800283a 	ret
100028b4:	80800017 	ldw	r2,0(r16)
100028b8:	103ff826 	beq	r2,zero,1000289c <_write_r+0x3c>
100028bc:	88800015 	stw	r2,0(r17)
100028c0:	1805883a 	mov	r2,r3
100028c4:	dfc00217 	ldw	ra,8(sp)
100028c8:	dc400117 	ldw	r17,4(sp)
100028cc:	dc000017 	ldw	r16,0(sp)
100028d0:	dec00304 	addi	sp,sp,12
100028d4:	f800283a 	ret

100028d8 <_close_r>:
100028d8:	defffd04 	addi	sp,sp,-12
100028dc:	dc000015 	stw	r16,0(sp)
100028e0:	04040074 	movhi	r16,4097
100028e4:	842a2304 	addi	r16,r16,-22388
100028e8:	dc400115 	stw	r17,4(sp)
100028ec:	80000015 	stw	zero,0(r16)
100028f0:	2023883a 	mov	r17,r4
100028f4:	2809883a 	mov	r4,r5
100028f8:	dfc00215 	stw	ra,8(sp)
100028fc:	0002c400 	call	10002c40 <close>
10002900:	1007883a 	mov	r3,r2
10002904:	00bfffc4 	movi	r2,-1
10002908:	18800626 	beq	r3,r2,10002924 <_close_r+0x4c>
1000290c:	1805883a 	mov	r2,r3
10002910:	dfc00217 	ldw	ra,8(sp)
10002914:	dc400117 	ldw	r17,4(sp)
10002918:	dc000017 	ldw	r16,0(sp)
1000291c:	dec00304 	addi	sp,sp,12
10002920:	f800283a 	ret
10002924:	80800017 	ldw	r2,0(r16)
10002928:	103ff826 	beq	r2,zero,1000290c <_close_r+0x34>
1000292c:	88800015 	stw	r2,0(r17)
10002930:	1805883a 	mov	r2,r3
10002934:	dfc00217 	ldw	ra,8(sp)
10002938:	dc400117 	ldw	r17,4(sp)
1000293c:	dc000017 	ldw	r16,0(sp)
10002940:	dec00304 	addi	sp,sp,12
10002944:	f800283a 	ret

10002948 <_fclose_r>:
10002948:	defffc04 	addi	sp,sp,-16
1000294c:	dc400115 	stw	r17,4(sp)
10002950:	dc000015 	stw	r16,0(sp)
10002954:	dfc00315 	stw	ra,12(sp)
10002958:	dc800215 	stw	r18,8(sp)
1000295c:	2821883a 	mov	r16,r5
10002960:	2023883a 	mov	r17,r4
10002964:	28002926 	beq	r5,zero,10002a0c <_fclose_r+0xc4>
10002968:	0001cc00 	call	10001cc0 <__sfp_lock_acquire>
1000296c:	88000226 	beq	r17,zero,10002978 <_fclose_r+0x30>
10002970:	88800e17 	ldw	r2,56(r17)
10002974:	10002d26 	beq	r2,zero,10002a2c <_fclose_r+0xe4>
10002978:	8080030f 	ldh	r2,12(r16)
1000297c:	10002226 	beq	r2,zero,10002a08 <_fclose_r+0xc0>
10002980:	8809883a 	mov	r4,r17
10002984:	800b883a 	mov	r5,r16
10002988:	0001a380 	call	10001a38 <_fflush_r>
1000298c:	1025883a 	mov	r18,r2
10002990:	80800b17 	ldw	r2,44(r16)
10002994:	10000426 	beq	r2,zero,100029a8 <_fclose_r+0x60>
10002998:	81400717 	ldw	r5,28(r16)
1000299c:	8809883a 	mov	r4,r17
100029a0:	103ee83a 	callr	r2
100029a4:	10002a16 	blt	r2,zero,10002a50 <_fclose_r+0x108>
100029a8:	8080030b 	ldhu	r2,12(r16)
100029ac:	1080200c 	andi	r2,r2,128
100029b0:	1000231e 	bne	r2,zero,10002a40 <_fclose_r+0xf8>
100029b4:	81400c17 	ldw	r5,48(r16)
100029b8:	28000526 	beq	r5,zero,100029d0 <_fclose_r+0x88>
100029bc:	80801004 	addi	r2,r16,64
100029c0:	28800226 	beq	r5,r2,100029cc <_fclose_r+0x84>
100029c4:	8809883a 	mov	r4,r17
100029c8:	00020540 	call	10002054 <_free_r>
100029cc:	80000c15 	stw	zero,48(r16)
100029d0:	81401117 	ldw	r5,68(r16)
100029d4:	28000326 	beq	r5,zero,100029e4 <_fclose_r+0x9c>
100029d8:	8809883a 	mov	r4,r17
100029dc:	00020540 	call	10002054 <_free_r>
100029e0:	80001115 	stw	zero,68(r16)
100029e4:	8000030d 	sth	zero,12(r16)
100029e8:	0001cc40 	call	10001cc4 <__sfp_lock_release>
100029ec:	9005883a 	mov	r2,r18
100029f0:	dfc00317 	ldw	ra,12(sp)
100029f4:	dc800217 	ldw	r18,8(sp)
100029f8:	dc400117 	ldw	r17,4(sp)
100029fc:	dc000017 	ldw	r16,0(sp)
10002a00:	dec00404 	addi	sp,sp,16
10002a04:	f800283a 	ret
10002a08:	0001cc40 	call	10001cc4 <__sfp_lock_release>
10002a0c:	0025883a 	mov	r18,zero
10002a10:	9005883a 	mov	r2,r18
10002a14:	dfc00317 	ldw	ra,12(sp)
10002a18:	dc800217 	ldw	r18,8(sp)
10002a1c:	dc400117 	ldw	r17,4(sp)
10002a20:	dc000017 	ldw	r16,0(sp)
10002a24:	dec00404 	addi	sp,sp,16
10002a28:	f800283a 	ret
10002a2c:	8809883a 	mov	r4,r17
10002a30:	0001cd00 	call	10001cd0 <__sinit>
10002a34:	8080030f 	ldh	r2,12(r16)
10002a38:	103fd11e 	bne	r2,zero,10002980 <_fclose_r+0x38>
10002a3c:	003ff206 	br	10002a08 <_fclose_r+0xc0>
10002a40:	81400417 	ldw	r5,16(r16)
10002a44:	8809883a 	mov	r4,r17
10002a48:	00020540 	call	10002054 <_free_r>
10002a4c:	003fd906 	br	100029b4 <_fclose_r+0x6c>
10002a50:	04bfffc4 	movi	r18,-1
10002a54:	003fd406 	br	100029a8 <_fclose_r+0x60>

10002a58 <fclose>:
10002a58:	00840074 	movhi	r2,4097
10002a5c:	10aa0e04 	addi	r2,r2,-22472
10002a60:	200b883a 	mov	r5,r4
10002a64:	11000017 	ldw	r4,0(r2)
10002a68:	00029481 	jmpi	10002948 <_fclose_r>

10002a6c <_fstat_r>:
10002a6c:	defffd04 	addi	sp,sp,-12
10002a70:	dc000015 	stw	r16,0(sp)
10002a74:	04040074 	movhi	r16,4097
10002a78:	842a2304 	addi	r16,r16,-22388
10002a7c:	dc400115 	stw	r17,4(sp)
10002a80:	80000015 	stw	zero,0(r16)
10002a84:	2023883a 	mov	r17,r4
10002a88:	2809883a 	mov	r4,r5
10002a8c:	300b883a 	mov	r5,r6
10002a90:	dfc00215 	stw	ra,8(sp)
10002a94:	0002dc80 	call	10002dc8 <fstat>
10002a98:	1007883a 	mov	r3,r2
10002a9c:	00bfffc4 	movi	r2,-1
10002aa0:	18800626 	beq	r3,r2,10002abc <_fstat_r+0x50>
10002aa4:	1805883a 	mov	r2,r3
10002aa8:	dfc00217 	ldw	ra,8(sp)
10002aac:	dc400117 	ldw	r17,4(sp)
10002ab0:	dc000017 	ldw	r16,0(sp)
10002ab4:	dec00304 	addi	sp,sp,12
10002ab8:	f800283a 	ret
10002abc:	80800017 	ldw	r2,0(r16)
10002ac0:	103ff826 	beq	r2,zero,10002aa4 <_fstat_r+0x38>
10002ac4:	88800015 	stw	r2,0(r17)
10002ac8:	1805883a 	mov	r2,r3
10002acc:	dfc00217 	ldw	ra,8(sp)
10002ad0:	dc400117 	ldw	r17,4(sp)
10002ad4:	dc000017 	ldw	r16,0(sp)
10002ad8:	dec00304 	addi	sp,sp,12
10002adc:	f800283a 	ret

10002ae0 <_isatty_r>:
10002ae0:	defffd04 	addi	sp,sp,-12
10002ae4:	dc000015 	stw	r16,0(sp)
10002ae8:	04040074 	movhi	r16,4097
10002aec:	842a2304 	addi	r16,r16,-22388
10002af0:	dc400115 	stw	r17,4(sp)
10002af4:	80000015 	stw	zero,0(r16)
10002af8:	2023883a 	mov	r17,r4
10002afc:	2809883a 	mov	r4,r5
10002b00:	dfc00215 	stw	ra,8(sp)
10002b04:	0002efc0 	call	10002efc <isatty>
10002b08:	1007883a 	mov	r3,r2
10002b0c:	00bfffc4 	movi	r2,-1
10002b10:	18800626 	beq	r3,r2,10002b2c <_isatty_r+0x4c>
10002b14:	1805883a 	mov	r2,r3
10002b18:	dfc00217 	ldw	ra,8(sp)
10002b1c:	dc400117 	ldw	r17,4(sp)
10002b20:	dc000017 	ldw	r16,0(sp)
10002b24:	dec00304 	addi	sp,sp,12
10002b28:	f800283a 	ret
10002b2c:	80800017 	ldw	r2,0(r16)
10002b30:	103ff826 	beq	r2,zero,10002b14 <_isatty_r+0x34>
10002b34:	88800015 	stw	r2,0(r17)
10002b38:	1805883a 	mov	r2,r3
10002b3c:	dfc00217 	ldw	ra,8(sp)
10002b40:	dc400117 	ldw	r17,4(sp)
10002b44:	dc000017 	ldw	r16,0(sp)
10002b48:	dec00304 	addi	sp,sp,12
10002b4c:	f800283a 	ret

10002b50 <_lseek_r>:
10002b50:	defffd04 	addi	sp,sp,-12
10002b54:	dc000015 	stw	r16,0(sp)
10002b58:	04040074 	movhi	r16,4097
10002b5c:	842a2304 	addi	r16,r16,-22388
10002b60:	dc400115 	stw	r17,4(sp)
10002b64:	80000015 	stw	zero,0(r16)
10002b68:	2023883a 	mov	r17,r4
10002b6c:	2809883a 	mov	r4,r5
10002b70:	300b883a 	mov	r5,r6
10002b74:	380d883a 	mov	r6,r7
10002b78:	dfc00215 	stw	ra,8(sp)
10002b7c:	000301c0 	call	1000301c <lseek>
10002b80:	1007883a 	mov	r3,r2
10002b84:	00bfffc4 	movi	r2,-1
10002b88:	18800626 	beq	r3,r2,10002ba4 <_lseek_r+0x54>
10002b8c:	1805883a 	mov	r2,r3
10002b90:	dfc00217 	ldw	ra,8(sp)
10002b94:	dc400117 	ldw	r17,4(sp)
10002b98:	dc000017 	ldw	r16,0(sp)
10002b9c:	dec00304 	addi	sp,sp,12
10002ba0:	f800283a 	ret
10002ba4:	80800017 	ldw	r2,0(r16)
10002ba8:	103ff826 	beq	r2,zero,10002b8c <_lseek_r+0x3c>
10002bac:	88800015 	stw	r2,0(r17)
10002bb0:	1805883a 	mov	r2,r3
10002bb4:	dfc00217 	ldw	ra,8(sp)
10002bb8:	dc400117 	ldw	r17,4(sp)
10002bbc:	dc000017 	ldw	r16,0(sp)
10002bc0:	dec00304 	addi	sp,sp,12
10002bc4:	f800283a 	ret

10002bc8 <_read_r>:
10002bc8:	defffd04 	addi	sp,sp,-12
10002bcc:	dc000015 	stw	r16,0(sp)
10002bd0:	04040074 	movhi	r16,4097
10002bd4:	842a2304 	addi	r16,r16,-22388
10002bd8:	dc400115 	stw	r17,4(sp)
10002bdc:	80000015 	stw	zero,0(r16)
10002be0:	2023883a 	mov	r17,r4
10002be4:	2809883a 	mov	r4,r5
10002be8:	300b883a 	mov	r5,r6
10002bec:	380d883a 	mov	r6,r7
10002bf0:	dfc00215 	stw	ra,8(sp)
10002bf4:	00032180 	call	10003218 <read>
10002bf8:	1007883a 	mov	r3,r2
10002bfc:	00bfffc4 	movi	r2,-1
10002c00:	18800626 	beq	r3,r2,10002c1c <_read_r+0x54>
10002c04:	1805883a 	mov	r2,r3
10002c08:	dfc00217 	ldw	ra,8(sp)
10002c0c:	dc400117 	ldw	r17,4(sp)
10002c10:	dc000017 	ldw	r16,0(sp)
10002c14:	dec00304 	addi	sp,sp,12
10002c18:	f800283a 	ret
10002c1c:	80800017 	ldw	r2,0(r16)
10002c20:	103ff826 	beq	r2,zero,10002c04 <_read_r+0x3c>
10002c24:	88800015 	stw	r2,0(r17)
10002c28:	1805883a 	mov	r2,r3
10002c2c:	dfc00217 	ldw	ra,8(sp)
10002c30:	dc400117 	ldw	r17,4(sp)
10002c34:	dc000017 	ldw	r16,0(sp)
10002c38:	dec00304 	addi	sp,sp,12
10002c3c:	f800283a 	ret

10002c40 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
10002c40:	defff804 	addi	sp,sp,-32
10002c44:	dfc00715 	stw	ra,28(sp)
10002c48:	df000615 	stw	fp,24(sp)
10002c4c:	df000604 	addi	fp,sp,24
10002c50:	e13ffc15 	stw	r4,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
10002c54:	e0bffc17 	ldw	r2,-16(fp)
10002c58:	1004803a 	cmplt	r2,r2,zero
10002c5c:	1000081e 	bne	r2,zero,10002c80 <close+0x40>
10002c60:	e0bffc17 	ldw	r2,-16(fp)
10002c64:	10800324 	muli	r2,r2,12
10002c68:	1007883a 	mov	r3,r2
10002c6c:	00840074 	movhi	r2,4097
10002c70:	10a54804 	addi	r2,r2,-27360
10002c74:	1887883a 	add	r3,r3,r2
10002c78:	e0ffff15 	stw	r3,-4(fp)
10002c7c:	00000106 	br	10002c84 <close+0x44>
10002c80:	e03fff15 	stw	zero,-4(fp)
10002c84:	e0bfff17 	ldw	r2,-4(fp)
10002c88:	e0bffb15 	stw	r2,-20(fp)

  if (fd)
10002c8c:	e0bffb17 	ldw	r2,-20(fp)
10002c90:	1005003a 	cmpeq	r2,r2,zero
10002c94:	10001d1e 	bne	r2,zero,10002d0c <close+0xcc>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
10002c98:	e0bffb17 	ldw	r2,-20(fp)
10002c9c:	10800017 	ldw	r2,0(r2)
10002ca0:	10800417 	ldw	r2,16(r2)
10002ca4:	1005003a 	cmpeq	r2,r2,zero
10002ca8:	1000071e 	bne	r2,zero,10002cc8 <close+0x88>
10002cac:	e0bffb17 	ldw	r2,-20(fp)
10002cb0:	10800017 	ldw	r2,0(r2)
10002cb4:	10800417 	ldw	r2,16(r2)
10002cb8:	e13ffb17 	ldw	r4,-20(fp)
10002cbc:	103ee83a 	callr	r2
10002cc0:	e0bffe15 	stw	r2,-8(fp)
10002cc4:	00000106 	br	10002ccc <close+0x8c>
10002cc8:	e03ffe15 	stw	zero,-8(fp)
10002ccc:	e0bffe17 	ldw	r2,-8(fp)
10002cd0:	e0bffa15 	stw	r2,-24(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
10002cd4:	e13ffc17 	ldw	r4,-16(fp)
10002cd8:	00033980 	call	10003398 <alt_release_fd>
    if (rval < 0)
10002cdc:	e0bffa17 	ldw	r2,-24(fp)
10002ce0:	1004403a 	cmpge	r2,r2,zero
10002ce4:	1000071e 	bne	r2,zero,10002d04 <close+0xc4>
    {
      ALT_ERRNO = -rval;
10002ce8:	0002d3c0 	call	10002d3c <alt_get_errno>
10002cec:	e0fffa17 	ldw	r3,-24(fp)
10002cf0:	00c7c83a 	sub	r3,zero,r3
10002cf4:	10c00015 	stw	r3,0(r2)
      return -1;
10002cf8:	00bfffc4 	movi	r2,-1
10002cfc:	e0bffd15 	stw	r2,-12(fp)
10002d00:	00000806 	br	10002d24 <close+0xe4>
    }
    return 0;
10002d04:	e03ffd15 	stw	zero,-12(fp)
10002d08:	00000606 	br	10002d24 <close+0xe4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
10002d0c:	0002d3c0 	call	10002d3c <alt_get_errno>
10002d10:	1007883a 	mov	r3,r2
10002d14:	00801444 	movi	r2,81
10002d18:	18800015 	stw	r2,0(r3)
    return -1;
10002d1c:	00bfffc4 	movi	r2,-1
10002d20:	e0bffd15 	stw	r2,-12(fp)
10002d24:	e0bffd17 	ldw	r2,-12(fp)
  }
}
10002d28:	e037883a 	mov	sp,fp
10002d2c:	dfc00117 	ldw	ra,4(sp)
10002d30:	df000017 	ldw	fp,0(sp)
10002d34:	dec00204 	addi	sp,sp,8
10002d38:	f800283a 	ret

10002d3c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
10002d3c:	defffd04 	addi	sp,sp,-12
10002d40:	dfc00215 	stw	ra,8(sp)
10002d44:	df000115 	stw	fp,4(sp)
10002d48:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
10002d4c:	00840074 	movhi	r2,4097
10002d50:	10aa1704 	addi	r2,r2,-22436
10002d54:	10800017 	ldw	r2,0(r2)
10002d58:	1005003a 	cmpeq	r2,r2,zero
10002d5c:	1000061e 	bne	r2,zero,10002d78 <alt_get_errno+0x3c>
10002d60:	00840074 	movhi	r2,4097
10002d64:	10aa1704 	addi	r2,r2,-22436
10002d68:	10800017 	ldw	r2,0(r2)
10002d6c:	103ee83a 	callr	r2
10002d70:	e0bfff15 	stw	r2,-4(fp)
10002d74:	00000306 	br	10002d84 <alt_get_errno+0x48>
10002d78:	00840074 	movhi	r2,4097
10002d7c:	10aa2304 	addi	r2,r2,-22388
10002d80:	e0bfff15 	stw	r2,-4(fp)
10002d84:	e0bfff17 	ldw	r2,-4(fp)
}
10002d88:	e037883a 	mov	sp,fp
10002d8c:	dfc00117 	ldw	ra,4(sp)
10002d90:	df000017 	ldw	fp,0(sp)
10002d94:	dec00204 	addi	sp,sp,8
10002d98:	f800283a 	ret

10002d9c <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
10002d9c:	defffc04 	addi	sp,sp,-16
10002da0:	df000315 	stw	fp,12(sp)
10002da4:	df000304 	addi	fp,sp,12
10002da8:	e13ffd15 	stw	r4,-12(fp)
10002dac:	e17ffe15 	stw	r5,-8(fp)
10002db0:	e1bfff15 	stw	r6,-4(fp)
  return len;
10002db4:	e0bfff17 	ldw	r2,-4(fp)
}
10002db8:	e037883a 	mov	sp,fp
10002dbc:	df000017 	ldw	fp,0(sp)
10002dc0:	dec00104 	addi	sp,sp,4
10002dc4:	f800283a 	ret

10002dc8 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
10002dc8:	defff904 	addi	sp,sp,-28
10002dcc:	dfc00615 	stw	ra,24(sp)
10002dd0:	df000515 	stw	fp,20(sp)
10002dd4:	df000504 	addi	fp,sp,20
10002dd8:	e13ffc15 	stw	r4,-16(fp)
10002ddc:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
10002de0:	e0bffc17 	ldw	r2,-16(fp)
10002de4:	1004803a 	cmplt	r2,r2,zero
10002de8:	1000081e 	bne	r2,zero,10002e0c <fstat+0x44>
10002dec:	e0bffc17 	ldw	r2,-16(fp)
10002df0:	10800324 	muli	r2,r2,12
10002df4:	1007883a 	mov	r3,r2
10002df8:	00840074 	movhi	r2,4097
10002dfc:	10a54804 	addi	r2,r2,-27360
10002e00:	1887883a 	add	r3,r3,r2
10002e04:	e0ffff15 	stw	r3,-4(fp)
10002e08:	00000106 	br	10002e10 <fstat+0x48>
10002e0c:	e03fff15 	stw	zero,-4(fp)
10002e10:	e0bfff17 	ldw	r2,-4(fp)
10002e14:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
10002e18:	e0bffb17 	ldw	r2,-20(fp)
10002e1c:	1005003a 	cmpeq	r2,r2,zero
10002e20:	1000121e 	bne	r2,zero,10002e6c <fstat+0xa4>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
10002e24:	e0bffb17 	ldw	r2,-20(fp)
10002e28:	10800017 	ldw	r2,0(r2)
10002e2c:	10800817 	ldw	r2,32(r2)
10002e30:	1005003a 	cmpeq	r2,r2,zero
10002e34:	1000081e 	bne	r2,zero,10002e58 <fstat+0x90>
    {
      return fd->dev->fstat(fd, st);
10002e38:	e0bffb17 	ldw	r2,-20(fp)
10002e3c:	10800017 	ldw	r2,0(r2)
10002e40:	10800817 	ldw	r2,32(r2)
10002e44:	e13ffb17 	ldw	r4,-20(fp)
10002e48:	e17ffd17 	ldw	r5,-12(fp)
10002e4c:	103ee83a 	callr	r2
10002e50:	e0bffe15 	stw	r2,-8(fp)
10002e54:	00000b06 	br	10002e84 <fstat+0xbc>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
10002e58:	e0fffd17 	ldw	r3,-12(fp)
10002e5c:	00880004 	movi	r2,8192
10002e60:	18800115 	stw	r2,4(r3)
      return 0;
10002e64:	e03ffe15 	stw	zero,-8(fp)
10002e68:	00000606 	br	10002e84 <fstat+0xbc>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
10002e6c:	0002e9c0 	call	10002e9c <alt_get_errno>
10002e70:	1007883a 	mov	r3,r2
10002e74:	00801444 	movi	r2,81
10002e78:	18800015 	stw	r2,0(r3)
    return -1;
10002e7c:	00bfffc4 	movi	r2,-1
10002e80:	e0bffe15 	stw	r2,-8(fp)
10002e84:	e0bffe17 	ldw	r2,-8(fp)
  }
}
10002e88:	e037883a 	mov	sp,fp
10002e8c:	dfc00117 	ldw	ra,4(sp)
10002e90:	df000017 	ldw	fp,0(sp)
10002e94:	dec00204 	addi	sp,sp,8
10002e98:	f800283a 	ret

10002e9c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
10002e9c:	defffd04 	addi	sp,sp,-12
10002ea0:	dfc00215 	stw	ra,8(sp)
10002ea4:	df000115 	stw	fp,4(sp)
10002ea8:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
10002eac:	00840074 	movhi	r2,4097
10002eb0:	10aa1704 	addi	r2,r2,-22436
10002eb4:	10800017 	ldw	r2,0(r2)
10002eb8:	1005003a 	cmpeq	r2,r2,zero
10002ebc:	1000061e 	bne	r2,zero,10002ed8 <alt_get_errno+0x3c>
10002ec0:	00840074 	movhi	r2,4097
10002ec4:	10aa1704 	addi	r2,r2,-22436
10002ec8:	10800017 	ldw	r2,0(r2)
10002ecc:	103ee83a 	callr	r2
10002ed0:	e0bfff15 	stw	r2,-4(fp)
10002ed4:	00000306 	br	10002ee4 <alt_get_errno+0x48>
10002ed8:	00840074 	movhi	r2,4097
10002edc:	10aa2304 	addi	r2,r2,-22388
10002ee0:	e0bfff15 	stw	r2,-4(fp)
10002ee4:	e0bfff17 	ldw	r2,-4(fp)
}
10002ee8:	e037883a 	mov	sp,fp
10002eec:	dfc00117 	ldw	ra,4(sp)
10002ef0:	df000017 	ldw	fp,0(sp)
10002ef4:	dec00204 	addi	sp,sp,8
10002ef8:	f800283a 	ret

10002efc <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
10002efc:	deffeb04 	addi	sp,sp,-84
10002f00:	dfc01415 	stw	ra,80(sp)
10002f04:	df001315 	stw	fp,76(sp)
10002f08:	df001304 	addi	fp,sp,76
10002f0c:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
10002f10:	e0bffd17 	ldw	r2,-12(fp)
10002f14:	1004803a 	cmplt	r2,r2,zero
10002f18:	1000081e 	bne	r2,zero,10002f3c <isatty+0x40>
10002f1c:	e0bffd17 	ldw	r2,-12(fp)
10002f20:	10800324 	muli	r2,r2,12
10002f24:	1007883a 	mov	r3,r2
10002f28:	00840074 	movhi	r2,4097
10002f2c:	10a54804 	addi	r2,r2,-27360
10002f30:	1887883a 	add	r3,r3,r2
10002f34:	e0ffff15 	stw	r3,-4(fp)
10002f38:	00000106 	br	10002f40 <isatty+0x44>
10002f3c:	e03fff15 	stw	zero,-4(fp)
10002f40:	e0bfff17 	ldw	r2,-4(fp)
10002f44:	e0bfed15 	stw	r2,-76(fp)
  
  if (fd)
10002f48:	e0bfed17 	ldw	r2,-76(fp)
10002f4c:	1005003a 	cmpeq	r2,r2,zero
10002f50:	10000f1e 	bne	r2,zero,10002f90 <isatty+0x94>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
10002f54:	e0bfed17 	ldw	r2,-76(fp)
10002f58:	10800017 	ldw	r2,0(r2)
10002f5c:	10800817 	ldw	r2,32(r2)
10002f60:	1004c03a 	cmpne	r2,r2,zero
10002f64:	1000031e 	bne	r2,zero,10002f74 <isatty+0x78>
    {
      return 1;
10002f68:	00800044 	movi	r2,1
10002f6c:	e0bffe15 	stw	r2,-8(fp)
10002f70:	00000c06 	br	10002fa4 <isatty+0xa8>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
10002f74:	e17fee04 	addi	r5,fp,-72
10002f78:	e13ffd17 	ldw	r4,-12(fp)
10002f7c:	0002dc80 	call	10002dc8 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
10002f80:	e0bfef17 	ldw	r2,-68(fp)
10002f84:	10880020 	cmpeqi	r2,r2,8192
10002f88:	e0bffe15 	stw	r2,-8(fp)
10002f8c:	00000506 	br	10002fa4 <isatty+0xa8>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
10002f90:	0002fbc0 	call	10002fbc <alt_get_errno>
10002f94:	1007883a 	mov	r3,r2
10002f98:	00801444 	movi	r2,81
10002f9c:	18800015 	stw	r2,0(r3)
    return 0;
10002fa0:	e03ffe15 	stw	zero,-8(fp)
10002fa4:	e0bffe17 	ldw	r2,-8(fp)
  }
}
10002fa8:	e037883a 	mov	sp,fp
10002fac:	dfc00117 	ldw	ra,4(sp)
10002fb0:	df000017 	ldw	fp,0(sp)
10002fb4:	dec00204 	addi	sp,sp,8
10002fb8:	f800283a 	ret

10002fbc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
10002fbc:	defffd04 	addi	sp,sp,-12
10002fc0:	dfc00215 	stw	ra,8(sp)
10002fc4:	df000115 	stw	fp,4(sp)
10002fc8:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
10002fcc:	00840074 	movhi	r2,4097
10002fd0:	10aa1704 	addi	r2,r2,-22436
10002fd4:	10800017 	ldw	r2,0(r2)
10002fd8:	1005003a 	cmpeq	r2,r2,zero
10002fdc:	1000061e 	bne	r2,zero,10002ff8 <alt_get_errno+0x3c>
10002fe0:	00840074 	movhi	r2,4097
10002fe4:	10aa1704 	addi	r2,r2,-22436
10002fe8:	10800017 	ldw	r2,0(r2)
10002fec:	103ee83a 	callr	r2
10002ff0:	e0bfff15 	stw	r2,-4(fp)
10002ff4:	00000306 	br	10003004 <alt_get_errno+0x48>
10002ff8:	00840074 	movhi	r2,4097
10002ffc:	10aa2304 	addi	r2,r2,-22388
10003000:	e0bfff15 	stw	r2,-4(fp)
10003004:	e0bfff17 	ldw	r2,-4(fp)
}
10003008:	e037883a 	mov	sp,fp
1000300c:	dfc00117 	ldw	ra,4(sp)
10003010:	df000017 	ldw	fp,0(sp)
10003014:	dec00204 	addi	sp,sp,8
10003018:	f800283a 	ret

1000301c <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
1000301c:	defff804 	addi	sp,sp,-32
10003020:	dfc00715 	stw	ra,28(sp)
10003024:	df000615 	stw	fp,24(sp)
10003028:	df000604 	addi	fp,sp,24
1000302c:	e13ffc15 	stw	r4,-16(fp)
10003030:	e17ffd15 	stw	r5,-12(fp)
10003034:	e1bffe15 	stw	r6,-8(fp)
  alt_fd* fd;
  off_t   rc = 0; 
10003038:	e03ffa15 	stw	zero,-24(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
1000303c:	e0bffc17 	ldw	r2,-16(fp)
10003040:	1004803a 	cmplt	r2,r2,zero
10003044:	1000081e 	bne	r2,zero,10003068 <lseek+0x4c>
10003048:	e0bffc17 	ldw	r2,-16(fp)
1000304c:	10800324 	muli	r2,r2,12
10003050:	1007883a 	mov	r3,r2
10003054:	00840074 	movhi	r2,4097
10003058:	10a54804 	addi	r2,r2,-27360
1000305c:	1887883a 	add	r3,r3,r2
10003060:	e0ffff15 	stw	r3,-4(fp)
10003064:	00000106 	br	1000306c <lseek+0x50>
10003068:	e03fff15 	stw	zero,-4(fp)
1000306c:	e0bfff17 	ldw	r2,-4(fp)
10003070:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd) 
10003074:	e0bffb17 	ldw	r2,-20(fp)
10003078:	1005003a 	cmpeq	r2,r2,zero
1000307c:	1000111e 	bne	r2,zero,100030c4 <lseek+0xa8>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
10003080:	e0bffb17 	ldw	r2,-20(fp)
10003084:	10800017 	ldw	r2,0(r2)
10003088:	10800717 	ldw	r2,28(r2)
1000308c:	1005003a 	cmpeq	r2,r2,zero
10003090:	1000091e 	bne	r2,zero,100030b8 <lseek+0x9c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
10003094:	e0bffb17 	ldw	r2,-20(fp)
10003098:	10800017 	ldw	r2,0(r2)
1000309c:	10800717 	ldw	r2,28(r2)
100030a0:	e13ffb17 	ldw	r4,-20(fp)
100030a4:	e17ffd17 	ldw	r5,-12(fp)
100030a8:	e1bffe17 	ldw	r6,-8(fp)
100030ac:	103ee83a 	callr	r2
100030b0:	e0bffa15 	stw	r2,-24(fp)
100030b4:	00000506 	br	100030cc <lseek+0xb0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
100030b8:	00bfde84 	movi	r2,-134
100030bc:	e0bffa15 	stw	r2,-24(fp)
100030c0:	00000206 	br	100030cc <lseek+0xb0>
    }
  }
  else  
  {
    rc = -EBADFD;
100030c4:	00bfebc4 	movi	r2,-81
100030c8:	e0bffa15 	stw	r2,-24(fp)
  }

  if (rc < 0)
100030cc:	e0bffa17 	ldw	r2,-24(fp)
100030d0:	1004403a 	cmpge	r2,r2,zero
100030d4:	1000071e 	bne	r2,zero,100030f4 <lseek+0xd8>
  {
    ALT_ERRNO = -rc;
100030d8:	000310c0 	call	1000310c <alt_get_errno>
100030dc:	1007883a 	mov	r3,r2
100030e0:	e0bffa17 	ldw	r2,-24(fp)
100030e4:	0085c83a 	sub	r2,zero,r2
100030e8:	18800015 	stw	r2,0(r3)
    rc = -1;
100030ec:	00bfffc4 	movi	r2,-1
100030f0:	e0bffa15 	stw	r2,-24(fp)
  }

  return rc;
100030f4:	e0bffa17 	ldw	r2,-24(fp)
}
100030f8:	e037883a 	mov	sp,fp
100030fc:	dfc00117 	ldw	ra,4(sp)
10003100:	df000017 	ldw	fp,0(sp)
10003104:	dec00204 	addi	sp,sp,8
10003108:	f800283a 	ret

1000310c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
1000310c:	defffd04 	addi	sp,sp,-12
10003110:	dfc00215 	stw	ra,8(sp)
10003114:	df000115 	stw	fp,4(sp)
10003118:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
1000311c:	00840074 	movhi	r2,4097
10003120:	10aa1704 	addi	r2,r2,-22436
10003124:	10800017 	ldw	r2,0(r2)
10003128:	1005003a 	cmpeq	r2,r2,zero
1000312c:	1000061e 	bne	r2,zero,10003148 <alt_get_errno+0x3c>
10003130:	00840074 	movhi	r2,4097
10003134:	10aa1704 	addi	r2,r2,-22436
10003138:	10800017 	ldw	r2,0(r2)
1000313c:	103ee83a 	callr	r2
10003140:	e0bfff15 	stw	r2,-4(fp)
10003144:	00000306 	br	10003154 <alt_get_errno+0x48>
10003148:	00840074 	movhi	r2,4097
1000314c:	10aa2304 	addi	r2,r2,-22388
10003150:	e0bfff15 	stw	r2,-4(fp)
10003154:	e0bfff17 	ldw	r2,-4(fp)
}
10003158:	e037883a 	mov	sp,fp
1000315c:	dfc00117 	ldw	ra,4(sp)
10003160:	df000017 	ldw	fp,0(sp)
10003164:	dec00204 	addi	sp,sp,8
10003168:	f800283a 	ret

1000316c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
1000316c:	defffd04 	addi	sp,sp,-12
10003170:	dfc00215 	stw	ra,8(sp)
10003174:	df000115 	stw	fp,4(sp)
10003178:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
1000317c:	0009883a 	mov	r4,zero
10003180:	00036340 	call	10003634 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
10003184:	00036680 	call	10003668 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
10003188:	01040074 	movhi	r4,4097
1000318c:	21231404 	addi	r4,r4,-29616
10003190:	01440074 	movhi	r5,4097
10003194:	29631404 	addi	r5,r5,-29616
10003198:	01840074 	movhi	r6,4097
1000319c:	31a31404 	addi	r6,r6,-29616
100031a0:	00076e80 	call	100076e8 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
100031a4:	000712c0 	call	1000712c <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
100031a8:	01040034 	movhi	r4,4096
100031ac:	211c6404 	addi	r4,r4,29072
100031b0:	000881c0 	call	1000881c <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
100031b4:	d1201617 	ldw	r4,-32680(gp)
100031b8:	d1601717 	ldw	r5,-32676(gp)
100031bc:	d1a01817 	ldw	r6,-32672(gp)
100031c0:	00002fc0 	call	100002fc <main>
100031c4:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
100031c8:	01000044 	movi	r4,1
100031cc:	0002c400 	call	10002c40 <close>
  exit (result);
100031d0:	e13fff17 	ldw	r4,-4(fp)
100031d4:	00088300 	call	10008830 <exit>

100031d8 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
100031d8:	defffe04 	addi	sp,sp,-8
100031dc:	df000115 	stw	fp,4(sp)
100031e0:	df000104 	addi	fp,sp,4
100031e4:	e13fff15 	stw	r4,-4(fp)
}
100031e8:	e037883a 	mov	sp,fp
100031ec:	df000017 	ldw	fp,0(sp)
100031f0:	dec00104 	addi	sp,sp,4
100031f4:	f800283a 	ret

100031f8 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
100031f8:	defffe04 	addi	sp,sp,-8
100031fc:	df000115 	stw	fp,4(sp)
10003200:	df000104 	addi	fp,sp,4
10003204:	e13fff15 	stw	r4,-4(fp)
}
10003208:	e037883a 	mov	sp,fp
1000320c:	df000017 	ldw	fp,0(sp)
10003210:	dec00104 	addi	sp,sp,4
10003214:	f800283a 	ret

10003218 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
10003218:	defff704 	addi	sp,sp,-36
1000321c:	dfc00815 	stw	ra,32(sp)
10003220:	df000715 	stw	fp,28(sp)
10003224:	df000704 	addi	fp,sp,28
10003228:	e13ffb15 	stw	r4,-20(fp)
1000322c:	e17ffc15 	stw	r5,-16(fp)
10003230:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
10003234:	e0bffb17 	ldw	r2,-20(fp)
10003238:	1004803a 	cmplt	r2,r2,zero
1000323c:	1000081e 	bne	r2,zero,10003260 <read+0x48>
10003240:	e0bffb17 	ldw	r2,-20(fp)
10003244:	10800324 	muli	r2,r2,12
10003248:	1007883a 	mov	r3,r2
1000324c:	00840074 	movhi	r2,4097
10003250:	10a54804 	addi	r2,r2,-27360
10003254:	1887883a 	add	r3,r3,r2
10003258:	e0ffff15 	stw	r3,-4(fp)
1000325c:	00000106 	br	10003264 <read+0x4c>
10003260:	e03fff15 	stw	zero,-4(fp)
10003264:	e0bfff17 	ldw	r2,-4(fp)
10003268:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
1000326c:	e0bffa17 	ldw	r2,-24(fp)
10003270:	1005003a 	cmpeq	r2,r2,zero
10003274:	1000241e 	bne	r2,zero,10003308 <read+0xf0>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
10003278:	e0bffa17 	ldw	r2,-24(fp)
1000327c:	10800217 	ldw	r2,8(r2)
10003280:	108000cc 	andi	r2,r2,3
10003284:	10800060 	cmpeqi	r2,r2,1
10003288:	10001a1e 	bne	r2,zero,100032f4 <read+0xdc>
1000328c:	e0bffa17 	ldw	r2,-24(fp)
10003290:	10800017 	ldw	r2,0(r2)
10003294:	10800517 	ldw	r2,20(r2)
10003298:	1005003a 	cmpeq	r2,r2,zero
1000329c:	1000151e 	bne	r2,zero,100032f4 <read+0xdc>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
100032a0:	e0bffa17 	ldw	r2,-24(fp)
100032a4:	10800017 	ldw	r2,0(r2)
100032a8:	10800517 	ldw	r2,20(r2)
100032ac:	e17ffc17 	ldw	r5,-16(fp)
100032b0:	e1bffd17 	ldw	r6,-12(fp)
100032b4:	e13ffa17 	ldw	r4,-24(fp)
100032b8:	103ee83a 	callr	r2
100032bc:	e0bff915 	stw	r2,-28(fp)
100032c0:	e0bff917 	ldw	r2,-28(fp)
100032c4:	1004403a 	cmpge	r2,r2,zero
100032c8:	1000071e 	bne	r2,zero,100032e8 <read+0xd0>
        {
          ALT_ERRNO = -rval;
100032cc:	00033380 	call	10003338 <alt_get_errno>
100032d0:	e0fff917 	ldw	r3,-28(fp)
100032d4:	00c7c83a 	sub	r3,zero,r3
100032d8:	10c00015 	stw	r3,0(r2)
          return -1;
100032dc:	00bfffc4 	movi	r2,-1
100032e0:	e0bffe15 	stw	r2,-8(fp)
100032e4:	00000e06 	br	10003320 <read+0x108>
        }
        return rval;
100032e8:	e0bff917 	ldw	r2,-28(fp)
100032ec:	e0bffe15 	stw	r2,-8(fp)
100032f0:	00000b06 	br	10003320 <read+0x108>
      }
      else
      {
        ALT_ERRNO = EACCES;
100032f4:	00033380 	call	10003338 <alt_get_errno>
100032f8:	1007883a 	mov	r3,r2
100032fc:	00800344 	movi	r2,13
10003300:	18800015 	stw	r2,0(r3)
10003304:	00000406 	br	10003318 <read+0x100>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
10003308:	00033380 	call	10003338 <alt_get_errno>
1000330c:	1007883a 	mov	r3,r2
10003310:	00801444 	movi	r2,81
10003314:	18800015 	stw	r2,0(r3)
  }
  return -1;
10003318:	00bfffc4 	movi	r2,-1
1000331c:	e0bffe15 	stw	r2,-8(fp)
10003320:	e0bffe17 	ldw	r2,-8(fp)
}
10003324:	e037883a 	mov	sp,fp
10003328:	dfc00117 	ldw	ra,4(sp)
1000332c:	df000017 	ldw	fp,0(sp)
10003330:	dec00204 	addi	sp,sp,8
10003334:	f800283a 	ret

10003338 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
10003338:	defffd04 	addi	sp,sp,-12
1000333c:	dfc00215 	stw	ra,8(sp)
10003340:	df000115 	stw	fp,4(sp)
10003344:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
10003348:	00840074 	movhi	r2,4097
1000334c:	10aa1704 	addi	r2,r2,-22436
10003350:	10800017 	ldw	r2,0(r2)
10003354:	1005003a 	cmpeq	r2,r2,zero
10003358:	1000061e 	bne	r2,zero,10003374 <alt_get_errno+0x3c>
1000335c:	00840074 	movhi	r2,4097
10003360:	10aa1704 	addi	r2,r2,-22436
10003364:	10800017 	ldw	r2,0(r2)
10003368:	103ee83a 	callr	r2
1000336c:	e0bfff15 	stw	r2,-4(fp)
10003370:	00000306 	br	10003380 <alt_get_errno+0x48>
10003374:	00840074 	movhi	r2,4097
10003378:	10aa2304 	addi	r2,r2,-22388
1000337c:	e0bfff15 	stw	r2,-4(fp)
10003380:	e0bfff17 	ldw	r2,-4(fp)
}
10003384:	e037883a 	mov	sp,fp
10003388:	dfc00117 	ldw	ra,4(sp)
1000338c:	df000017 	ldw	fp,0(sp)
10003390:	dec00204 	addi	sp,sp,8
10003394:	f800283a 	ret

10003398 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
10003398:	defffe04 	addi	sp,sp,-8
1000339c:	df000115 	stw	fp,4(sp)
100033a0:	df000104 	addi	fp,sp,4
100033a4:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
100033a8:	e0bfff17 	ldw	r2,-4(fp)
100033ac:	108000d0 	cmplti	r2,r2,3
100033b0:	10000d1e 	bne	r2,zero,100033e8 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
100033b4:	e0bfff17 	ldw	r2,-4(fp)
100033b8:	00c40074 	movhi	r3,4097
100033bc:	18e54804 	addi	r3,r3,-27360
100033c0:	10800324 	muli	r2,r2,12
100033c4:	10c5883a 	add	r2,r2,r3
100033c8:	10800204 	addi	r2,r2,8
100033cc:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
100033d0:	e0bfff17 	ldw	r2,-4(fp)
100033d4:	00c40074 	movhi	r3,4097
100033d8:	18e54804 	addi	r3,r3,-27360
100033dc:	10800324 	muli	r2,r2,12
100033e0:	10c5883a 	add	r2,r2,r3
100033e4:	10000015 	stw	zero,0(r2)
  }
}
100033e8:	e037883a 	mov	sp,fp
100033ec:	df000017 	ldw	fp,0(sp)
100033f0:	dec00104 	addi	sp,sp,4
100033f4:	f800283a 	ret

100033f8 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
100033f8:	defff804 	addi	sp,sp,-32
100033fc:	df000715 	stw	fp,28(sp)
10003400:	df000704 	addi	fp,sp,28
10003404:	e13ffe15 	stw	r4,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10003408:	0005303a 	rdctl	r2,status
1000340c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10003410:	e0fffb17 	ldw	r3,-20(fp)
10003414:	00bfff84 	movi	r2,-2
10003418:	1884703a 	and	r2,r3,r2
1000341c:	1001703a 	wrctl	status,r2
  
  return context;
10003420:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
10003424:	e0bffd15 	stw	r2,-12(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
10003428:	d0a00a17 	ldw	r2,-32728(gp)
1000342c:	10c000c4 	addi	r3,r2,3
10003430:	00bfff04 	movi	r2,-4
10003434:	1884703a 	and	r2,r3,r2
10003438:	d0a00a15 	stw	r2,-32728(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
1000343c:	d0e00a17 	ldw	r3,-32728(gp)
10003440:	e0bffe17 	ldw	r2,-8(fp)
10003444:	1887883a 	add	r3,r3,r2
10003448:	00848034 	movhi	r2,4608
1000344c:	10800004 	addi	r2,r2,0
10003450:	10c0072e 	bgeu	r2,r3,10003470 <sbrk+0x78>
10003454:	e0bffd17 	ldw	r2,-12(fp)
10003458:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
1000345c:	e0bffa17 	ldw	r2,-24(fp)
10003460:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
10003464:	00bfffc4 	movi	r2,-1
10003468:	e0bfff15 	stw	r2,-4(fp)
1000346c:	00000c06 	br	100034a0 <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
10003470:	d0a00a17 	ldw	r2,-32728(gp)
10003474:	e0bffc15 	stw	r2,-16(fp)
  heap_end += incr; 
10003478:	d0e00a17 	ldw	r3,-32728(gp)
1000347c:	e0bffe17 	ldw	r2,-8(fp)
10003480:	1885883a 	add	r2,r3,r2
10003484:	d0a00a15 	stw	r2,-32728(gp)
10003488:	e0bffd17 	ldw	r2,-12(fp)
1000348c:	e0bff915 	stw	r2,-28(fp)
10003490:	e0bff917 	ldw	r2,-28(fp)
10003494:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
10003498:	e0bffc17 	ldw	r2,-16(fp)
1000349c:	e0bfff15 	stw	r2,-4(fp)
100034a0:	e0bfff17 	ldw	r2,-4(fp)
} 
100034a4:	e037883a 	mov	sp,fp
100034a8:	df000017 	ldw	fp,0(sp)
100034ac:	dec00104 	addi	sp,sp,4
100034b0:	f800283a 	ret

100034b4 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
100034b4:	defff704 	addi	sp,sp,-36
100034b8:	dfc00815 	stw	ra,32(sp)
100034bc:	df000715 	stw	fp,28(sp)
100034c0:	df000704 	addi	fp,sp,28
100034c4:	e13ffb15 	stw	r4,-20(fp)
100034c8:	e17ffc15 	stw	r5,-16(fp)
100034cc:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
100034d0:	e0bffb17 	ldw	r2,-20(fp)
100034d4:	1004803a 	cmplt	r2,r2,zero
100034d8:	1000081e 	bne	r2,zero,100034fc <write+0x48>
100034dc:	e0bffb17 	ldw	r2,-20(fp)
100034e0:	10800324 	muli	r2,r2,12
100034e4:	1007883a 	mov	r3,r2
100034e8:	00840074 	movhi	r2,4097
100034ec:	10a54804 	addi	r2,r2,-27360
100034f0:	1887883a 	add	r3,r3,r2
100034f4:	e0ffff15 	stw	r3,-4(fp)
100034f8:	00000106 	br	10003500 <write+0x4c>
100034fc:	e03fff15 	stw	zero,-4(fp)
10003500:	e0bfff17 	ldw	r2,-4(fp)
10003504:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
10003508:	e0bffa17 	ldw	r2,-24(fp)
1000350c:	1005003a 	cmpeq	r2,r2,zero
10003510:	1000241e 	bne	r2,zero,100035a4 <write+0xf0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
10003514:	e0bffa17 	ldw	r2,-24(fp)
10003518:	10800217 	ldw	r2,8(r2)
1000351c:	108000cc 	andi	r2,r2,3
10003520:	1005003a 	cmpeq	r2,r2,zero
10003524:	10001a1e 	bne	r2,zero,10003590 <write+0xdc>
10003528:	e0bffa17 	ldw	r2,-24(fp)
1000352c:	10800017 	ldw	r2,0(r2)
10003530:	10800617 	ldw	r2,24(r2)
10003534:	1005003a 	cmpeq	r2,r2,zero
10003538:	1000151e 	bne	r2,zero,10003590 <write+0xdc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
1000353c:	e0bffa17 	ldw	r2,-24(fp)
10003540:	10800017 	ldw	r2,0(r2)
10003544:	10800617 	ldw	r2,24(r2)
10003548:	e17ffc17 	ldw	r5,-16(fp)
1000354c:	e1bffd17 	ldw	r6,-12(fp)
10003550:	e13ffa17 	ldw	r4,-24(fp)
10003554:	103ee83a 	callr	r2
10003558:	e0bff915 	stw	r2,-28(fp)
1000355c:	e0bff917 	ldw	r2,-28(fp)
10003560:	1004403a 	cmpge	r2,r2,zero
10003564:	1000071e 	bne	r2,zero,10003584 <write+0xd0>
      {
        ALT_ERRNO = -rval;
10003568:	00035d40 	call	100035d4 <alt_get_errno>
1000356c:	e0fff917 	ldw	r3,-28(fp)
10003570:	00c7c83a 	sub	r3,zero,r3
10003574:	10c00015 	stw	r3,0(r2)
        return -1;
10003578:	00bfffc4 	movi	r2,-1
1000357c:	e0bffe15 	stw	r2,-8(fp)
10003580:	00000e06 	br	100035bc <write+0x108>
      }
      return rval;
10003584:	e0bff917 	ldw	r2,-28(fp)
10003588:	e0bffe15 	stw	r2,-8(fp)
1000358c:	00000b06 	br	100035bc <write+0x108>
    }
    else
    {
      ALT_ERRNO = EACCES;
10003590:	00035d40 	call	100035d4 <alt_get_errno>
10003594:	1007883a 	mov	r3,r2
10003598:	00800344 	movi	r2,13
1000359c:	18800015 	stw	r2,0(r3)
100035a0:	00000406 	br	100035b4 <write+0x100>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
100035a4:	00035d40 	call	100035d4 <alt_get_errno>
100035a8:	1007883a 	mov	r3,r2
100035ac:	00801444 	movi	r2,81
100035b0:	18800015 	stw	r2,0(r3)
  }
  return -1;
100035b4:	00bfffc4 	movi	r2,-1
100035b8:	e0bffe15 	stw	r2,-8(fp)
100035bc:	e0bffe17 	ldw	r2,-8(fp)
}
100035c0:	e037883a 	mov	sp,fp
100035c4:	dfc00117 	ldw	ra,4(sp)
100035c8:	df000017 	ldw	fp,0(sp)
100035cc:	dec00204 	addi	sp,sp,8
100035d0:	f800283a 	ret

100035d4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
100035d4:	defffd04 	addi	sp,sp,-12
100035d8:	dfc00215 	stw	ra,8(sp)
100035dc:	df000115 	stw	fp,4(sp)
100035e0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
100035e4:	00840074 	movhi	r2,4097
100035e8:	10aa1704 	addi	r2,r2,-22436
100035ec:	10800017 	ldw	r2,0(r2)
100035f0:	1005003a 	cmpeq	r2,r2,zero
100035f4:	1000061e 	bne	r2,zero,10003610 <alt_get_errno+0x3c>
100035f8:	00840074 	movhi	r2,4097
100035fc:	10aa1704 	addi	r2,r2,-22436
10003600:	10800017 	ldw	r2,0(r2)
10003604:	103ee83a 	callr	r2
10003608:	e0bfff15 	stw	r2,-4(fp)
1000360c:	00000306 	br	1000361c <alt_get_errno+0x48>
10003610:	00840074 	movhi	r2,4097
10003614:	10aa2304 	addi	r2,r2,-22388
10003618:	e0bfff15 	stw	r2,-4(fp)
1000361c:	e0bfff17 	ldw	r2,-4(fp)
}
10003620:	e037883a 	mov	sp,fp
10003624:	dfc00117 	ldw	ra,4(sp)
10003628:	df000017 	ldw	fp,0(sp)
1000362c:	dec00204 	addi	sp,sp,8
10003630:	f800283a 	ret

10003634 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
10003634:	defffd04 	addi	sp,sp,-12
10003638:	dfc00215 	stw	ra,8(sp)
1000363c:	df000115 	stw	fp,4(sp)
10003640:	df000104 	addi	fp,sp,4
10003644:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, cpu);
10003648:	0007c080 	call	10007c08 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
1000364c:	00800044 	movi	r2,1
10003650:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
10003654:	e037883a 	mov	sp,fp
10003658:	dfc00117 	ldw	ra,4(sp)
1000365c:	df000017 	ldw	fp,0(sp)
10003660:	dec00204 	addi	sp,sp,8
10003664:	f800283a 	ret

10003668 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
10003668:	defffe04 	addi	sp,sp,-8
1000366c:	dfc00115 	stw	ra,4(sp)
10003670:	df000015 	stw	fp,0(sp)
10003674:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( PERIPHERAL_SUBSYSTEM_HIGH_RES_TIMER, peripheral_subsystem_high_res_timer);
    ALTERA_AVALON_TIMER_INIT ( PERIPHERAL_SUBSYSTEM_SYS_CLK_TIMER, peripheral_subsystem_sys_clk_timer);
10003678:	01020034 	movhi	r4,2048
1000367c:	21001004 	addi	r4,r4,64
10003680:	000b883a 	mov	r5,zero
10003684:	01800084 	movi	r6,2
10003688:	01c01904 	movi	r7,100
1000368c:	0006dbc0 	call	10006dbc <alt_avalon_timer_sc_init>
    ALTERA_AVALON_CFI_FLASH_INIT ( EXT_FLASH, ext_flash);
10003690:	01040074 	movhi	r4,4097
10003694:	2125a804 	addi	r4,r4,-26976
10003698:	000373c0 	call	1000373c <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( PERIPHERAL_SUBSYSTEM_JTAG_UART, peripheral_subsystem_jtag_uart);
1000369c:	01040074 	movhi	r4,4097
100036a0:	2125e804 	addi	r4,r4,-26720
100036a4:	000b883a 	mov	r5,zero
100036a8:	01800144 	movi	r6,5
100036ac:	00056040 	call	10005604 <altera_avalon_jtag_uart_init>
100036b0:	01040074 	movhi	r4,4097
100036b4:	2125de04 	addi	r4,r4,-26760
100036b8:	00037040 	call	10003704 <alt_dev_reg>
    ALTERA_AVALON_PERFORMANCE_COUNTER_INIT ( PERIPHERAL_SUBSYSTEM_PERFORMANCE_COUNTER, peripheral_subsystem_performance_counter);
100036bc:	00c20034 	movhi	r3,2048
100036c0:	00800044 	movi	r2,1
100036c4:	18800035 	stwio	r2,0(r3)
    ALTERA_AVALON_SGDMA_INIT ( ETHERNET_SUBSYSTEM_SGDMA_RX, ethernet_subsystem_sgdma_rx);
100036c8:	01040074 	movhi	r4,4097
100036cc:	2129f604 	addi	r4,r4,-22568
100036d0:	000b883a 	mov	r5,zero
100036d4:	01800044 	movi	r6,1
100036d8:	0006ca00 	call	10006ca0 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( ETHERNET_SUBSYSTEM_SGDMA_TX, ethernet_subsystem_sgdma_tx);
100036dc:	01040074 	movhi	r4,4097
100036e0:	212a0204 	addi	r4,r4,-22520
100036e4:	000b883a 	mov	r5,zero
100036e8:	000d883a 	mov	r6,zero
100036ec:	0006ca00 	call	10006ca0 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
    TRIPLE_SPEED_ETHERNET_INIT ( ETHERNET_SUBSYSTEM_TSE_MAC, ethernet_subsystem_tse_mac);
}
100036f0:	e037883a 	mov	sp,fp
100036f4:	dfc00117 	ldw	ra,4(sp)
100036f8:	df000017 	ldw	fp,0(sp)
100036fc:	dec00204 	addi	sp,sp,8
10003700:	f800283a 	ret

10003704 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
10003704:	defffd04 	addi	sp,sp,-12
10003708:	dfc00215 	stw	ra,8(sp)
1000370c:	df000115 	stw	fp,4(sp)
10003710:	df000104 	addi	fp,sp,4
10003714:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
10003718:	e13fff17 	ldw	r4,-4(fp)
1000371c:	01440074 	movhi	r5,4097
10003720:	296a1404 	addi	r5,r5,-22448
10003724:	00070180 	call	10007018 <alt_dev_llist_insert>
}
10003728:	e037883a 	mov	sp,fp
1000372c:	dfc00117 	ldw	ra,4(sp)
10003730:	df000017 	ldw	fp,0(sp)
10003734:	dec00204 	addi	sp,sp,8
10003738:	f800283a 	ret

1000373c <alt_flash_cfi_init>:
 * Read the CFI table and fill out the alt_flash_cfi_dev structure with all the 
 * information we need to program the flash.
 * 
 */
int alt_flash_cfi_init( alt_flash_cfi_dev* flash  )
{
1000373c:	defffc04 	addi	sp,sp,-16
10003740:	dfc00315 	stw	ra,12(sp)
10003744:	df000215 	stw	fp,8(sp)
10003748:	df000204 	addi	fp,sp,8
1000374c:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
10003750:	e03ffe15 	stw	zero,-8(fp)
 
  ret_code = alt_read_cfi_width( flash );
10003754:	e13fff17 	ldw	r4,-4(fp)
10003758:	0004c340 	call	10004c34 <alt_read_cfi_width>
1000375c:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
10003760:	e0bffe17 	ldw	r2,-8(fp)
10003764:	1004c03a 	cmpne	r2,r2,zero
10003768:	1000031e 	bne	r2,zero,10003778 <alt_flash_cfi_init+0x3c>
    ret_code = alt_set_flash_width_func( flash );
1000376c:	e13fff17 	ldw	r4,-4(fp)
10003770:	000434c0 	call	1000434c <alt_set_flash_width_func>
10003774:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
10003778:	e0bffe17 	ldw	r2,-8(fp)
1000377c:	1004c03a 	cmpne	r2,r2,zero
10003780:	1000031e 	bne	r2,zero,10003790 <alt_flash_cfi_init+0x54>
    ret_code = alt_read_cfi_table( flash );
10003784:	e13fff17 	ldw	r4,-4(fp)
10003788:	00046540 	call	10004654 <alt_read_cfi_table>
1000378c:	e0bffe15 	stw	r2,-8(fp)

  if (!ret_code) 
10003790:	e0bffe17 	ldw	r2,-8(fp)
10003794:	1004c03a 	cmpne	r2,r2,zero
10003798:	1000031e 	bne	r2,zero,100037a8 <alt_flash_cfi_init+0x6c>
    ret_code = alt_set_flash_algorithm_func( flash);
1000379c:	e13fff17 	ldw	r4,-4(fp)
100037a0:	000452c0 	call	1000452c <alt_set_flash_algorithm_func>
100037a4:	e0bffe15 	stw	r2,-8(fp)

  /*
  *  Register this device as a valid flash device type
  */ 
  if (!ret_code)
100037a8:	e0bffe17 	ldw	r2,-8(fp)
100037ac:	1004c03a 	cmpne	r2,r2,zero
100037b0:	1000031e 	bne	r2,zero,100037c0 <alt_flash_cfi_init+0x84>
    ret_code = alt_flash_device_register(&(flash->dev));
100037b4:	e13fff17 	ldw	r4,-4(fp)
100037b8:	00037d80 	call	100037d8 <alt_flash_device_register>
100037bc:	e0bffe15 	stw	r2,-8(fp)
 
  return ret_code;
100037c0:	e0bffe17 	ldw	r2,-8(fp)
}
100037c4:	e037883a 	mov	sp,fp
100037c8:	dfc00117 	ldw	ra,4(sp)
100037cc:	df000017 	ldw	fp,0(sp)
100037d0:	dec00204 	addi	sp,sp,8
100037d4:	f800283a 	ret

100037d8 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
100037d8:	defffd04 	addi	sp,sp,-12
100037dc:	dfc00215 	stw	ra,8(sp)
100037e0:	df000115 	stw	fp,4(sp)
100037e4:	df000104 	addi	fp,sp,4
100037e8:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
100037ec:	e13fff17 	ldw	r4,-4(fp)
100037f0:	01440074 	movhi	r5,4097
100037f4:	296a1b04 	addi	r5,r5,-22420
100037f8:	00070180 	call	10007018 <alt_dev_llist_insert>
}
100037fc:	e037883a 	mov	sp,fp
10003800:	dfc00117 	ldw	ra,4(sp)
10003804:	df000017 	ldw	fp,0(sp)
10003808:	dec00204 	addi	sp,sp,8
1000380c:	f800283a 	ret

10003810 <alt_flash_cfi_write>:
 * large buffer to tie up in our programming library, when not all users will 
 * want that functionality.
 */
 int alt_flash_cfi_write( alt_flash_dev* flash_info, int offset, 
                          const void* src_addr, int length )
 {
10003810:	deffef04 	addi	sp,sp,-68
10003814:	dfc01015 	stw	ra,64(sp)
10003818:	df000f15 	stw	fp,60(sp)
1000381c:	df000f04 	addi	fp,sp,60
10003820:	e13ffa15 	stw	r4,-24(fp)
10003824:	e17ffb15 	stw	r5,-20(fp)
10003828:	e1bffc15 	stw	r6,-16(fp)
1000382c:	e1fffd15 	stw	r7,-12(fp)
  int         ret_code = 0;
10003830:	e03ff915 	stw	zero,-28(fp)
  int         i,j;
  int         data_to_write;
  int         full_length = length;
10003834:	e0bffd17 	ldw	r2,-12(fp)
10003838:	e0bff515 	stw	r2,-44(fp)
  int         current_offset;
  int         start_offset = offset;
1000383c:	e0bffb17 	ldw	r2,-20(fp)
10003840:	e0bff315 	stw	r2,-52(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
10003844:	e0bffa17 	ldw	r2,-24(fp)
10003848:	e0bff215 	stw	r2,-56(fp)

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
1000384c:	e03ff815 	stw	zero,-32(fp)
10003850:	00008e06 	br	10003a8c <alt_flash_cfi_write+0x27c>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
10003854:	e0bff817 	ldw	r2,-32(fp)
10003858:	e0fff217 	ldw	r3,-56(fp)
1000385c:	1004913a 	slli	r2,r2,4
10003860:	10c5883a 	add	r2,r2,r3
10003864:	10800d04 	addi	r2,r2,52
10003868:	10c00017 	ldw	r3,0(r2)
1000386c:	e0bffb17 	ldw	r2,-20(fp)
10003870:	10c08316 	blt	r2,r3,10003a80 <alt_flash_cfi_write+0x270>
10003874:	e0bff817 	ldw	r2,-32(fp)
10003878:	e0fff217 	ldw	r3,-56(fp)
1000387c:	1004913a 	slli	r2,r2,4
10003880:	10c5883a 	add	r2,r2,r3
10003884:	10800d04 	addi	r2,r2,52
10003888:	11000017 	ldw	r4,0(r2)
1000388c:	e0bff817 	ldw	r2,-32(fp)
10003890:	e0fff217 	ldw	r3,-56(fp)
10003894:	1004913a 	slli	r2,r2,4
10003898:	10c5883a 	add	r2,r2,r3
1000389c:	10800e04 	addi	r2,r2,56
100038a0:	10800017 	ldw	r2,0(r2)
100038a4:	2087883a 	add	r3,r4,r2
100038a8:	e0bffb17 	ldw	r2,-20(fp)
100038ac:	10c0740e 	bge	r2,r3,10003a80 <alt_flash_cfi_write+0x270>
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;
100038b0:	e0bff817 	ldw	r2,-32(fp)
100038b4:	e0fff217 	ldw	r3,-56(fp)
100038b8:	1004913a 	slli	r2,r2,4
100038bc:	10c5883a 	add	r2,r2,r3
100038c0:	10800d04 	addi	r2,r2,52
100038c4:	10800017 	ldw	r2,0(r2)
100038c8:	e0bff415 	stw	r2,-48(fp)

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
100038cc:	e03ff715 	stw	zero,-36(fp)
100038d0:	00006306 	br	10003a60 <alt_flash_cfi_write+0x250>
      {
        if ((offset >= current_offset ) && 
100038d4:	e0fffb17 	ldw	r3,-20(fp)
100038d8:	e0bff417 	ldw	r2,-48(fp)
100038dc:	18805416 	blt	r3,r2,10003a30 <alt_flash_cfi_write+0x220>
100038e0:	e0bff817 	ldw	r2,-32(fp)
100038e4:	e0fff217 	ldw	r3,-56(fp)
100038e8:	1004913a 	slli	r2,r2,4
100038ec:	10c5883a 	add	r2,r2,r3
100038f0:	10801004 	addi	r2,r2,64
100038f4:	10c00017 	ldw	r3,0(r2)
100038f8:	e0bff417 	ldw	r2,-48(fp)
100038fc:	1887883a 	add	r3,r3,r2
10003900:	e0bffb17 	ldw	r2,-20(fp)
10003904:	10c04a0e 	bge	r2,r3,10003a30 <alt_flash_cfi_write+0x220>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash->dev.region_info[i].block_size 
10003908:	e0bff817 	ldw	r2,-32(fp)
1000390c:	e0fff217 	ldw	r3,-56(fp)
10003910:	1004913a 	slli	r2,r2,4
10003914:	10c5883a 	add	r2,r2,r3
10003918:	10801004 	addi	r2,r2,64
1000391c:	10c00017 	ldw	r3,0(r2)
10003920:	e0bff417 	ldw	r2,-48(fp)
10003924:	1887883a 	add	r3,r3,r2
10003928:	e0bffb17 	ldw	r2,-20(fp)
1000392c:	1885c83a 	sub	r2,r3,r2
10003930:	e0bff615 	stw	r2,-40(fp)
                            - offset); 
          data_to_write = MIN(data_to_write, length);
10003934:	e0bff617 	ldw	r2,-40(fp)
10003938:	e0bfff15 	stw	r2,-4(fp)
1000393c:	e0fffd17 	ldw	r3,-12(fp)
10003940:	e0fffe15 	stw	r3,-8(fp)
10003944:	e0bfff17 	ldw	r2,-4(fp)
10003948:	e0fffe17 	ldw	r3,-8(fp)
1000394c:	10c0020e 	bge	r2,r3,10003958 <alt_flash_cfi_write+0x148>
10003950:	e0bfff17 	ldw	r2,-4(fp)
10003954:	e0bffe15 	stw	r2,-8(fp)
10003958:	e0fffe17 	ldw	r3,-8(fp)
1000395c:	e0fff615 	stw	r3,-40(fp)
          if(memcmp(src_addr, 
10003960:	e0bff217 	ldw	r2,-56(fp)
10003964:	10800a17 	ldw	r2,40(r2)
10003968:	1007883a 	mov	r3,r2
1000396c:	e0bffb17 	ldw	r2,-20(fp)
10003970:	188b883a 	add	r5,r3,r2
10003974:	e1bff617 	ldw	r6,-40(fp)
10003978:	e13ffc17 	ldw	r4,-16(fp)
1000397c:	00088680 	call	10008868 <memcmp>
10003980:	1005003a 	cmpeq	r2,r2,zero
10003984:	1000131e 	bne	r2,zero,100039d4 <alt_flash_cfi_write+0x1c4>
                    (alt_u8*)flash->dev.base_addr+offset,
                    data_to_write))
          {
            ret_code = (*flash->dev.erase_block)( &flash->dev, current_offset);
10003988:	e0bff217 	ldw	r2,-56(fp)
1000398c:	10800817 	ldw	r2,32(r2)
10003990:	e13ff217 	ldw	r4,-56(fp)
10003994:	e17ff417 	ldw	r5,-48(fp)
10003998:	103ee83a 	callr	r2
1000399c:	e0bff915 	stw	r2,-28(fp)

            if (!ret_code)
100039a0:	e0bff917 	ldw	r2,-28(fp)
100039a4:	1004c03a 	cmpne	r2,r2,zero
100039a8:	10000a1e 	bne	r2,zero,100039d4 <alt_flash_cfi_write+0x1c4>
            {
              ret_code = (*flash->dev.write_block)( 
100039ac:	e0bff217 	ldw	r2,-56(fp)
100039b0:	10c00917 	ldw	r3,36(r2)
100039b4:	e13ff217 	ldw	r4,-56(fp)
100039b8:	e0bff617 	ldw	r2,-40(fp)
100039bc:	d8800015 	stw	r2,0(sp)
100039c0:	e17ff417 	ldw	r5,-48(fp)
100039c4:	e1bffb17 	ldw	r6,-20(fp)
100039c8:	e1fffc17 	ldw	r7,-16(fp)
100039cc:	183ee83a 	callr	r3
100039d0:	e0bff915 	stw	r2,-28(fp)
                                                  data_to_write);
            }
          }    
    
          /* Was this the last block? */    
          if ((length == data_to_write) || ret_code)
100039d4:	e0fffd17 	ldw	r3,-12(fp)
100039d8:	e0bff617 	ldw	r2,-40(fp)
100039dc:	18802f26 	beq	r3,r2,10003a9c <alt_flash_cfi_write+0x28c>
100039e0:	e0bff917 	ldw	r2,-28(fp)
100039e4:	1004c03a 	cmpne	r2,r2,zero
100039e8:	10002c1e 	bne	r2,zero,10003a9c <alt_flash_cfi_write+0x28c>
          {
            goto finished;
          }
          
          length -= data_to_write;
100039ec:	e0fffd17 	ldw	r3,-12(fp)
100039f0:	e0bff617 	ldw	r2,-40(fp)
100039f4:	1885c83a 	sub	r2,r3,r2
100039f8:	e0bffd15 	stw	r2,-12(fp)
          offset = current_offset + flash->dev.region_info[i].block_size;
100039fc:	e0bff817 	ldw	r2,-32(fp)
10003a00:	e0fff217 	ldw	r3,-56(fp)
10003a04:	1004913a 	slli	r2,r2,4
10003a08:	10c5883a 	add	r2,r2,r3
10003a0c:	10801004 	addi	r2,r2,64
10003a10:	10c00017 	ldw	r3,0(r2)
10003a14:	e0bff417 	ldw	r2,-48(fp)
10003a18:	1885883a 	add	r2,r3,r2
10003a1c:	e0bffb15 	stw	r2,-20(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
10003a20:	e0fffc17 	ldw	r3,-16(fp)
10003a24:	e0bff617 	ldw	r2,-40(fp)
10003a28:	1885883a 	add	r2,r3,r2
10003a2c:	e0bffc15 	stw	r2,-16(fp)
        }
        current_offset += flash->dev.region_info[i].block_size;
10003a30:	e0bff817 	ldw	r2,-32(fp)
10003a34:	e0fff217 	ldw	r3,-56(fp)
10003a38:	1004913a 	slli	r2,r2,4
10003a3c:	10c5883a 	add	r2,r2,r3
10003a40:	10801004 	addi	r2,r2,64
10003a44:	10c00017 	ldw	r3,0(r2)
10003a48:	e0bff417 	ldw	r2,-48(fp)
10003a4c:	10c5883a 	add	r2,r2,r3
10003a50:	e0bff415 	stw	r2,-48(fp)
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
10003a54:	e0bff717 	ldw	r2,-36(fp)
10003a58:	10800044 	addi	r2,r2,1
10003a5c:	e0bff715 	stw	r2,-36(fp)
10003a60:	e0bff817 	ldw	r2,-32(fp)
10003a64:	e0fff217 	ldw	r3,-56(fp)
10003a68:	1004913a 	slli	r2,r2,4
10003a6c:	10c5883a 	add	r2,r2,r3
10003a70:	10800f04 	addi	r2,r2,60
10003a74:	10c00017 	ldw	r3,0(r2)
10003a78:	e0bff717 	ldw	r2,-36(fp)
10003a7c:	10ff9516 	blt	r2,r3,100038d4 <alt_flash_cfi_write+0xc4>
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
10003a80:	e0bff817 	ldw	r2,-32(fp)
10003a84:	10800044 	addi	r2,r2,1
10003a88:	e0bff815 	stw	r2,-32(fp)
10003a8c:	e0bff217 	ldw	r2,-56(fp)
10003a90:	10c00c17 	ldw	r3,48(r2)
10003a94:	e0bff817 	ldw	r2,-32(fp)
10003a98:	10ff6e16 	blt	r2,r3,10003854 <alt_flash_cfi_write+0x44>
      }     
    } 
  }
finished:    

  alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
10003a9c:	e0bff217 	ldw	r2,-56(fp)
10003aa0:	10800a17 	ldw	r2,40(r2)
10003aa4:	1007883a 	mov	r3,r2
10003aa8:	e0bff317 	ldw	r2,-52(fp)
10003aac:	1889883a 	add	r4,r3,r2
10003ab0:	e17ff517 	ldw	r5,-44(fp)
10003ab4:	0006fa00 	call	10006fa0 <alt_dcache_flush>
  return ret_code;
10003ab8:	e0bff917 	ldw	r2,-28(fp)
}
10003abc:	e037883a 	mov	sp,fp
10003ac0:	dfc00117 	ldw	ra,4(sp)
10003ac4:	df000017 	ldw	fp,0(sp)
10003ac8:	dec00204 	addi	sp,sp,8
10003acc:	f800283a 	ret

10003ad0 <alt_flash_cfi_get_info>:
 * 
 *  Pass the table of erase blocks to the user
 */
int alt_flash_cfi_get_info( alt_flash_fd* fd, flash_region** info, 
                            int* number_of_regions)
{
10003ad0:	defffa04 	addi	sp,sp,-24
10003ad4:	df000515 	stw	fp,20(sp)
10003ad8:	df000504 	addi	fp,sp,20
10003adc:	e13ffd15 	stw	r4,-12(fp)
10003ae0:	e17ffe15 	stw	r5,-8(fp)
10003ae4:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
10003ae8:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_dev* flash = (alt_flash_dev*)fd;
10003aec:	e0bffd17 	ldw	r2,-12(fp)
10003af0:	e0bffb15 	stw	r2,-20(fp)

  *number_of_regions = flash->number_of_regions;
10003af4:	e0bffb17 	ldw	r2,-20(fp)
10003af8:	10c00c17 	ldw	r3,48(r2)
10003afc:	e0bfff17 	ldw	r2,-4(fp)
10003b00:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
10003b04:	e0bffb17 	ldw	r2,-20(fp)
10003b08:	10800c17 	ldw	r2,48(r2)
10003b0c:	1004c03a 	cmpne	r2,r2,zero
10003b10:	1000031e 	bne	r2,zero,10003b20 <alt_flash_cfi_get_info+0x50>
  {
    ret_code = -EIO;
10003b14:	00bffec4 	movi	r2,-5
10003b18:	e0bffc15 	stw	r2,-16(fp)
10003b1c:	00000b06 	br	10003b4c <alt_flash_cfi_get_info+0x7c>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
10003b20:	e0bffb17 	ldw	r2,-20(fp)
10003b24:	10800c17 	ldw	r2,48(r2)
10003b28:	10800250 	cmplti	r2,r2,9
10003b2c:	1000031e 	bne	r2,zero,10003b3c <alt_flash_cfi_get_info+0x6c>
  {
    ret_code = -ENOMEM;
10003b30:	00bffd04 	movi	r2,-12
10003b34:	e0bffc15 	stw	r2,-16(fp)
10003b38:	00000406 	br	10003b4c <alt_flash_cfi_get_info+0x7c>
  }
  else
  {
    *info = &flash->region_info[0];
10003b3c:	e0bffb17 	ldw	r2,-20(fp)
10003b40:	10c00d04 	addi	r3,r2,52
10003b44:	e0bffe17 	ldw	r2,-8(fp)
10003b48:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
10003b4c:	e0bffc17 	ldw	r2,-16(fp)
}
10003b50:	e037883a 	mov	sp,fp
10003b54:	df000017 	ldw	fp,0(sp)
10003b58:	dec00104 	addi	sp,sp,4
10003b5c:	f800283a 	ret

10003b60 <alt_flash_cfi_read>:
 *  Read from an area in flash, you could use memcopy yourself
 *  for these flash types, but we're trying to be generic and future proof
 */
int alt_flash_cfi_read( alt_flash_dev* flash_info, int offset, 
                        void* dest_addr, int length )
{
10003b60:	defff904 	addi	sp,sp,-28
10003b64:	dfc00615 	stw	ra,24(sp)
10003b68:	df000515 	stw	fp,20(sp)
10003b6c:	df000504 	addi	fp,sp,20
10003b70:	e13ffc15 	stw	r4,-16(fp)
10003b74:	e17ffd15 	stw	r5,-12(fp)
10003b78:	e1bffe15 	stw	r6,-8(fp)
10003b7c:	e1ffff15 	stw	r7,-4(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
10003b80:	e0bffc17 	ldw	r2,-16(fp)
10003b84:	e0bffb15 	stw	r2,-20(fp)
  memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
10003b88:	e0bffb17 	ldw	r2,-20(fp)
10003b8c:	10800a17 	ldw	r2,40(r2)
10003b90:	1007883a 	mov	r3,r2
10003b94:	e0bffd17 	ldw	r2,-12(fp)
10003b98:	1887883a 	add	r3,r3,r2
10003b9c:	e1bfff17 	ldw	r6,-4(fp)
10003ba0:	e0bffe17 	ldw	r2,-8(fp)
10003ba4:	1009883a 	mov	r4,r2
10003ba8:	180b883a 	mov	r5,r3
10003bac:	00011180 	call	10001118 <memcpy>
  return 0;
10003bb0:	0005883a 	mov	r2,zero
}
10003bb4:	e037883a 	mov	sp,fp
10003bb8:	dfc00117 	ldw	ra,4(sp)
10003bbc:	df000017 	ldw	fp,0(sp)
10003bc0:	dec00204 	addi	sp,sp,8
10003bc4:	f800283a 	ret

10003bc8 <alt_write_value_to_flash>:
* It writes the largest word size that the flash can support
* so if it's an 8 bit flash it writes bytes
* 16 bit half word etc.
*/
void alt_write_value_to_flash(alt_flash_cfi_dev* flash, int offset, const alt_u8* src_addr)
{
10003bc8:	defffa04 	addi	sp,sp,-24
10003bcc:	df000515 	stw	fp,20(sp)
10003bd0:	df000504 	addi	fp,sp,20
10003bd4:	e13ffd15 	stw	r4,-12(fp)
10003bd8:	e17ffe15 	stw	r5,-8(fp)
10003bdc:	e1bfff15 	stw	r6,-4(fp)
  alt_u16 half_word_value;
  alt_u32 word_value;

  if (flash->mode_width == 1)
10003be0:	e0bffd17 	ldw	r2,-12(fp)
10003be4:	10802e17 	ldw	r2,184(r2)
10003be8:	10800058 	cmpnei	r2,r2,1
10003bec:	10000b1e 	bne	r2,zero,10003c1c <alt_write_value_to_flash+0x54>
  {
    IOWR_8DIRECT(flash->dev.base_addr, offset, *src_addr);
10003bf0:	e0bffd17 	ldw	r2,-12(fp)
10003bf4:	10800a17 	ldw	r2,40(r2)
10003bf8:	1007883a 	mov	r3,r2
10003bfc:	e0bffe17 	ldw	r2,-8(fp)
10003c00:	1889883a 	add	r4,r3,r2
10003c04:	e0bfff17 	ldw	r2,-4(fp)
10003c08:	10800003 	ldbu	r2,0(r2)
10003c0c:	10c03fcc 	andi	r3,r2,255
10003c10:	2005883a 	mov	r2,r4
10003c14:	10c00025 	stbio	r3,0(r2)
10003c18:	00004006 	br	10003d1c <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 2)
10003c1c:	e0bffd17 	ldw	r2,-12(fp)
10003c20:	10802e17 	ldw	r2,184(r2)
10003c24:	10800098 	cmpnei	r2,r2,2
10003c28:	1000151e 	bne	r2,zero,10003c80 <alt_write_value_to_flash+0xb8>
  {
    half_word_value = (alt_u16)(*src_addr);
10003c2c:	e0bfff17 	ldw	r2,-4(fp)
10003c30:	10800003 	ldbu	r2,0(r2)
10003c34:	10803fcc 	andi	r2,r2,255
10003c38:	e0bffc0d 	sth	r2,-16(fp)
    half_word_value |= (alt_u16)(*(src_addr + 1)) << 8;
10003c3c:	e0bfff17 	ldw	r2,-4(fp)
10003c40:	10800044 	addi	r2,r2,1
10003c44:	10800003 	ldbu	r2,0(r2)
10003c48:	10803fcc 	andi	r2,r2,255
10003c4c:	1004923a 	slli	r2,r2,8
10003c50:	1007883a 	mov	r3,r2
10003c54:	e0bffc0b 	ldhu	r2,-16(fp)
10003c58:	1884b03a 	or	r2,r3,r2
10003c5c:	e0bffc0d 	sth	r2,-16(fp)
    IOWR_16DIRECT(flash->dev.base_addr, offset, half_word_value);
10003c60:	e0bffd17 	ldw	r2,-12(fp)
10003c64:	10800a17 	ldw	r2,40(r2)
10003c68:	1007883a 	mov	r3,r2
10003c6c:	e0bffe17 	ldw	r2,-8(fp)
10003c70:	1885883a 	add	r2,r3,r2
10003c74:	e0fffc0b 	ldhu	r3,-16(fp)
10003c78:	10c0002d 	sthio	r3,0(r2)
10003c7c:	00002706 	br	10003d1c <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 4)
10003c80:	e0bffd17 	ldw	r2,-12(fp)
10003c84:	10802e17 	ldw	r2,184(r2)
10003c88:	10800118 	cmpnei	r2,r2,4
10003c8c:	1000231e 	bne	r2,zero,10003d1c <alt_write_value_to_flash+0x154>
  {
    word_value = (alt_u32)(*src_addr);
10003c90:	e0bfff17 	ldw	r2,-4(fp)
10003c94:	10800003 	ldbu	r2,0(r2)
10003c98:	10803fcc 	andi	r2,r2,255
10003c9c:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 1)) << 8);
10003ca0:	e0bfff17 	ldw	r2,-4(fp)
10003ca4:	10800044 	addi	r2,r2,1
10003ca8:	10800003 	ldbu	r2,0(r2)
10003cac:	10803fcc 	andi	r2,r2,255
10003cb0:	1006923a 	slli	r3,r2,8
10003cb4:	e0bffb17 	ldw	r2,-20(fp)
10003cb8:	10c4b03a 	or	r2,r2,r3
10003cbc:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 2)) << 16);
10003cc0:	e0bfff17 	ldw	r2,-4(fp)
10003cc4:	10800084 	addi	r2,r2,2
10003cc8:	10800003 	ldbu	r2,0(r2)
10003ccc:	10803fcc 	andi	r2,r2,255
10003cd0:	1006943a 	slli	r3,r2,16
10003cd4:	e0bffb17 	ldw	r2,-20(fp)
10003cd8:	10c4b03a 	or	r2,r2,r3
10003cdc:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 3)) << 24);
10003ce0:	e0bfff17 	ldw	r2,-4(fp)
10003ce4:	108000c4 	addi	r2,r2,3
10003ce8:	10800003 	ldbu	r2,0(r2)
10003cec:	10803fcc 	andi	r2,r2,255
10003cf0:	1006963a 	slli	r3,r2,24
10003cf4:	e0bffb17 	ldw	r2,-20(fp)
10003cf8:	10c4b03a 	or	r2,r2,r3
10003cfc:	e0bffb15 	stw	r2,-20(fp)
    IOWR_32DIRECT(flash->dev.base_addr, offset, word_value);
10003d00:	e0bffd17 	ldw	r2,-12(fp)
10003d04:	10800a17 	ldw	r2,40(r2)
10003d08:	1007883a 	mov	r3,r2
10003d0c:	e0bffe17 	ldw	r2,-8(fp)
10003d10:	1885883a 	add	r2,r3,r2
10003d14:	e0fffb17 	ldw	r3,-20(fp)
10003d18:	10c00035 	stwio	r3,0(r2)
  }

  return;
}
10003d1c:	e037883a 	mov	sp,fp
10003d20:	df000017 	ldw	fp,0(sp)
10003d24:	dec00104 	addi	sp,sp,4
10003d28:	f800283a 	ret

10003d2c <alt_flash_program_block>:
*/
int alt_flash_program_block(  alt_flash_cfi_dev* flash, const int offset, 
                        const alt_u8* src_addr, 
                        const int length,
                        alt_program_word_fn program_word_func)
{
10003d2c:	defff304 	addi	sp,sp,-52
10003d30:	dfc00c15 	stw	ra,48(sp)
10003d34:	df000b15 	stw	fp,44(sp)
10003d38:	df000b04 	addi	fp,sp,44
10003d3c:	e13ffc15 	stw	r4,-16(fp)
10003d40:	e17ffd15 	stw	r5,-12(fp)
10003d44:	e1bffe15 	stw	r6,-8(fp)
10003d48:	e1ffff15 	stw	r7,-4(fp)
  int     ret_code = 0;
10003d4c:	e03ffa15 	stw	zero,-24(fp)

  /*
   * First take care of any writes which are on none native boundaries
   * as far as the flash is concerned.
   */
  bytes_to_preserve = ((int)((alt_u8*)flash->dev.base_addr + offset) % 
10003d50:	e0bffc17 	ldw	r2,-16(fp)
10003d54:	10800a17 	ldw	r2,40(r2)
10003d58:	1007883a 	mov	r3,r2
10003d5c:	e0bffd17 	ldw	r2,-12(fp)
10003d60:	1885883a 	add	r2,r3,r2
10003d64:	1009883a 	mov	r4,r2
10003d68:	e0bffc17 	ldw	r2,-16(fp)
10003d6c:	10c02e17 	ldw	r3,184(r2)
10003d70:	20c5283a 	div	r2,r4,r3
10003d74:	10c5383a 	mul	r2,r2,r3
10003d78:	2085c83a 	sub	r2,r4,r2
10003d7c:	e0bff915 	stw	r2,-28(fp)
                      flash->mode_width);
  if ( bytes_to_preserve != 0)
10003d80:	e0bff917 	ldw	r2,-28(fp)
10003d84:	1005003a 	cmpeq	r2,r2,zero
10003d88:	10003a1e 	bne	r2,zero,10003e74 <alt_flash_program_block+0x148>
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
10003d8c:	e0bffc17 	ldw	r2,-16(fp)
10003d90:	10c02e17 	ldw	r3,184(r2)
10003d94:	e0bff917 	ldw	r2,-28(fp)
10003d98:	1885c83a 	sub	r2,r3,r2
10003d9c:	e0bff815 	stw	r2,-32(fp)
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
10003da0:	e03ff615 	stw	zero,-40(fp)
10003da4:	00001206 	br	10003df0 <alt_flash_program_block+0xc4>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
10003da8:	e17ff617 	ldw	r5,-40(fp)
10003dac:	e0bffc17 	ldw	r2,-16(fp)
10003db0:	10800a17 	ldw	r2,40(r2)
10003db4:	1009883a 	mov	r4,r2
10003db8:	e0fffd17 	ldw	r3,-12(fp)
10003dbc:	e0bff917 	ldw	r2,-28(fp)
10003dc0:	1887c83a 	sub	r3,r3,r2
10003dc4:	e0bff617 	ldw	r2,-40(fp)
10003dc8:	1885883a 	add	r2,r3,r2
10003dcc:	2085883a 	add	r2,r4,r2
10003dd0:	10800023 	ldbuio	r2,0(r2)
10003dd4:	1007883a 	mov	r3,r2
10003dd8:	e0bffb04 	addi	r2,fp,-20
10003ddc:	1145883a 	add	r2,r2,r5
10003de0:	10c00005 	stb	r3,0(r2)
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
10003de4:	e0bff617 	ldw	r2,-40(fp)
10003de8:	10800044 	addi	r2,r2,1
10003dec:	e0bff615 	stw	r2,-40(fp)
10003df0:	e0fff617 	ldw	r3,-40(fp)
10003df4:	e0bff917 	ldw	r2,-28(fp)
10003df8:	18bfeb16 	blt	r3,r2,10003da8 <alt_flash_program_block+0x7c>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
10003dfc:	e03ff615 	stw	zero,-40(fp)
10003e00:	00000e06 	br	10003e3c <alt_flash_program_block+0x110>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
10003e04:	e0fff917 	ldw	r3,-28(fp)
10003e08:	e0bff617 	ldw	r2,-40(fp)
10003e0c:	1889883a 	add	r4,r3,r2
10003e10:	e0bff617 	ldw	r2,-40(fp)
10003e14:	1007883a 	mov	r3,r2
10003e18:	e0bffe17 	ldw	r2,-8(fp)
10003e1c:	1885883a 	add	r2,r3,r2
10003e20:	10c00003 	ldbu	r3,0(r2)
10003e24:	e0bffb04 	addi	r2,fp,-20
10003e28:	1105883a 	add	r2,r2,r4
10003e2c:	10c00005 	stb	r3,0(r2)
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
10003e30:	e0bff617 	ldw	r2,-40(fp)
10003e34:	10800044 	addi	r2,r2,1
10003e38:	e0bff615 	stw	r2,-40(fp)
10003e3c:	e0fff617 	ldw	r3,-40(fp)
10003e40:	e0bff817 	ldw	r2,-32(fp)
10003e44:	18bfef16 	blt	r3,r2,10003e04 <alt_flash_program_block+0xd8>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
    }
    
    ret_code = (*program_word_func)(flash, offset-bytes_to_preserve, unaligned);
10003e48:	e0fffd17 	ldw	r3,-12(fp)
10003e4c:	e0bff917 	ldw	r2,-28(fp)
10003e50:	188bc83a 	sub	r5,r3,r2
10003e54:	e1bffb04 	addi	r6,fp,-20
10003e58:	e0800217 	ldw	r2,8(fp)
10003e5c:	e13ffc17 	ldw	r4,-16(fp)
10003e60:	103ee83a 	callr	r2
10003e64:	e0bffa15 	stw	r2,-24(fp)
    i = unaligned_bytes;
10003e68:	e0bff817 	ldw	r2,-32(fp)
10003e6c:	e0bff615 	stw	r2,-40(fp)
10003e70:	00000106 	br	10003e78 <alt_flash_program_block+0x14c>
  }
  else
  {
    i = 0;
10003e74:	e03ff615 	stw	zero,-40(fp)
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
10003e78:	e0fffd17 	ldw	r3,-12(fp)
10003e7c:	e0bfff17 	ldw	r2,-4(fp)
10003e80:	1889883a 	add	r4,r3,r2
10003e84:	e0bffc17 	ldw	r2,-16(fp)
10003e88:	10c02e17 	ldw	r3,184(r2)
10003e8c:	20c5283a 	div	r2,r4,r3
10003e90:	10c5383a 	mul	r2,r2,r3
10003e94:	2085c83a 	sub	r2,r4,r2
10003e98:	e0bff715 	stw	r2,-36(fp)
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
10003e9c:	00001006 	br	10003ee0 <alt_flash_program_block+0x1b4>
  {
    ret_code = (*program_word_func)(flash, offset+i, src_addr+i);
10003ea0:	e0fffd17 	ldw	r3,-12(fp)
10003ea4:	e0bff617 	ldw	r2,-40(fp)
10003ea8:	188b883a 	add	r5,r3,r2
10003eac:	e0bff617 	ldw	r2,-40(fp)
10003eb0:	1007883a 	mov	r3,r2
10003eb4:	e0bffe17 	ldw	r2,-8(fp)
10003eb8:	188d883a 	add	r6,r3,r2
10003ebc:	e0800217 	ldw	r2,8(fp)
10003ec0:	e13ffc17 	ldw	r4,-16(fp)
10003ec4:	103ee83a 	callr	r2
10003ec8:	e0bffa15 	stw	r2,-24(fp)
    i += flash->mode_width;     
10003ecc:	e0bffc17 	ldw	r2,-16(fp)
10003ed0:	10c02e17 	ldw	r3,184(r2)
10003ed4:	e0bff617 	ldw	r2,-40(fp)
10003ed8:	10c5883a 	add	r2,r2,r3
10003edc:	e0bff615 	stw	r2,-40(fp)
  {
    i = 0;
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
10003ee0:	e0bffa17 	ldw	r2,-24(fp)
10003ee4:	1004c03a 	cmpne	r2,r2,zero
10003ee8:	1000051e 	bne	r2,zero,10003f00 <alt_flash_program_block+0x1d4>
10003eec:	e0ffff17 	ldw	r3,-4(fp)
10003ef0:	e0bff717 	ldw	r2,-36(fp)
10003ef4:	1887c83a 	sub	r3,r3,r2
10003ef8:	e0bff617 	ldw	r2,-40(fp)
10003efc:	10ffe816 	blt	r2,r3,10003ea0 <alt_flash_program_block+0x174>

  /*
   * Now take care of any writes at the end of the buffer which are on none 
   * native boundaries as far as the flash is concerned.
   */
  if (unaligned_end_bytes && !ret_code)
10003f00:	e0bff717 	ldw	r2,-36(fp)
10003f04:	1005003a 	cmpeq	r2,r2,zero
10003f08:	10003c1e 	bne	r2,zero,10003ffc <alt_flash_program_block+0x2d0>
10003f0c:	e0bffa17 	ldw	r2,-24(fp)
10003f10:	1004c03a 	cmpne	r2,r2,zero
10003f14:	1000391e 	bne	r2,zero,10003ffc <alt_flash_program_block+0x2d0>
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
10003f18:	e0bffc17 	ldw	r2,-16(fp)
10003f1c:	10c02e17 	ldw	r3,184(r2)
10003f20:	e0bff717 	ldw	r2,-36(fp)
10003f24:	1885c83a 	sub	r2,r3,r2
10003f28:	e0bff915 	stw	r2,-28(fp)
    
    for (j=0;j<unaligned_end_bytes;j++)
10003f2c:	e03ff515 	stw	zero,-44(fp)
10003f30:	00000e06 	br	10003f6c <alt_flash_program_block+0x240>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
10003f34:	e13ff517 	ldw	r4,-44(fp)
10003f38:	e0bff617 	ldw	r2,-40(fp)
10003f3c:	1007883a 	mov	r3,r2
10003f40:	e0bffe17 	ldw	r2,-8(fp)
10003f44:	1887883a 	add	r3,r3,r2
10003f48:	e0bff517 	ldw	r2,-44(fp)
10003f4c:	1885883a 	add	r2,r3,r2
10003f50:	10c00003 	ldbu	r3,0(r2)
10003f54:	e0bffb04 	addi	r2,fp,-20
10003f58:	1105883a 	add	r2,r2,r4
10003f5c:	10c00005 	stb	r3,0(r2)
   */
  if (unaligned_end_bytes && !ret_code)
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
    
    for (j=0;j<unaligned_end_bytes;j++)
10003f60:	e0bff517 	ldw	r2,-44(fp)
10003f64:	10800044 	addi	r2,r2,1
10003f68:	e0bff515 	stw	r2,-44(fp)
10003f6c:	e0fff517 	ldw	r3,-44(fp)
10003f70:	e0bff717 	ldw	r2,-36(fp)
10003f74:	18bfef16 	blt	r3,r2,10003f34 <alt_flash_program_block+0x208>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
10003f78:	e03ff515 	stw	zero,-44(fp)
10003f7c:	00001406 	br	10003fd0 <alt_flash_program_block+0x2a4>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
10003f80:	e0fff717 	ldw	r3,-36(fp)
10003f84:	e0bff517 	ldw	r2,-44(fp)
10003f88:	188b883a 	add	r5,r3,r2
10003f8c:	e0bffc17 	ldw	r2,-16(fp)
10003f90:	10800a17 	ldw	r2,40(r2)
10003f94:	1009883a 	mov	r4,r2
10003f98:	e0fffd17 	ldw	r3,-12(fp)
10003f9c:	e0bfff17 	ldw	r2,-4(fp)
10003fa0:	1887883a 	add	r3,r3,r2
10003fa4:	e0bff517 	ldw	r2,-44(fp)
10003fa8:	1885883a 	add	r2,r3,r2
10003fac:	2085883a 	add	r2,r4,r2
10003fb0:	10800023 	ldbuio	r2,0(r2)
10003fb4:	1007883a 	mov	r3,r2
10003fb8:	e0bffb04 	addi	r2,fp,-20
10003fbc:	1145883a 	add	r2,r2,r5
10003fc0:	10c00005 	stb	r3,0(r2)
    for (j=0;j<unaligned_end_bytes;j++)
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
10003fc4:	e0bff517 	ldw	r2,-44(fp)
10003fc8:	10800044 	addi	r2,r2,1
10003fcc:	e0bff515 	stw	r2,-44(fp)
10003fd0:	e0fff517 	ldw	r3,-44(fp)
10003fd4:	e0bff917 	ldw	r2,-28(fp)
10003fd8:	18bfe916 	blt	r3,r2,10003f80 <alt_flash_program_block+0x254>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
                                                      offset+length+j);
    }

    ret_code = (*program_word_func)(flash, offset+i, unaligned);      
10003fdc:	e0fffd17 	ldw	r3,-12(fp)
10003fe0:	e0bff617 	ldw	r2,-40(fp)
10003fe4:	188b883a 	add	r5,r3,r2
10003fe8:	e1bffb04 	addi	r6,fp,-20
10003fec:	e0800217 	ldw	r2,8(fp)
10003ff0:	e13ffc17 	ldw	r4,-16(fp)
10003ff4:	103ee83a 	callr	r2
10003ff8:	e0bffa15 	stw	r2,-24(fp)
  }

  return ret_code;
10003ffc:	e0bffa17 	ldw	r2,-24(fp)
}
10004000:	e037883a 	mov	sp,fp
10004004:	dfc00117 	ldw	ra,4(sp)
10004008:	df000017 	ldw	fp,0(sp)
1000400c:	dec00204 	addi	sp,sp,8
10004010:	f800283a 	ret

10004014 <alt_read_query_entry_8bit>:

/*
 *  Read an 8 bit value from the CFI query table in flash
 */
alt_u8 alt_read_query_entry_8bit( alt_flash_cfi_dev* flash, int address)
{
10004014:	defffd04 	addi	sp,sp,-12
10004018:	df000215 	stw	fp,8(sp)
1000401c:	df000204 	addi	fp,sp,8
10004020:	e13ffe15 	stw	r4,-8(fp)
10004024:	e17fff15 	stw	r5,-4(fp)
  return IORD_8DIRECT((alt_u8*)flash->dev.base_addr, address);
10004028:	e0bffe17 	ldw	r2,-8(fp)
1000402c:	10800a17 	ldw	r2,40(r2)
10004030:	1007883a 	mov	r3,r2
10004034:	e0bfff17 	ldw	r2,-4(fp)
10004038:	1885883a 	add	r2,r3,r2
1000403c:	10800023 	ldbuio	r2,0(r2)
10004040:	10803fcc 	andi	r2,r2,255
}
10004044:	e037883a 	mov	sp,fp
10004048:	df000017 	ldw	fp,0(sp)
1000404c:	dec00104 	addi	sp,sp,4
10004050:	f800283a 	ret

10004054 <alt_read_query_entry_16bit>:

alt_u8 alt_read_query_entry_16bit( alt_flash_cfi_dev* flash, int address)
{
10004054:	defffd04 	addi	sp,sp,-12
10004058:	df000215 	stw	fp,8(sp)
1000405c:	df000204 	addi	fp,sp,8
10004060:	e13ffe15 	stw	r4,-8(fp)
10004064:	e17fff15 	stw	r5,-4(fp)
  return (IORD_16DIRECT((alt_u8*)flash->dev.base_addr, address*2) & 0xff);
10004068:	e0bffe17 	ldw	r2,-8(fp)
1000406c:	10800a17 	ldw	r2,40(r2)
10004070:	1007883a 	mov	r3,r2
10004074:	e0bfff17 	ldw	r2,-4(fp)
10004078:	1085883a 	add	r2,r2,r2
1000407c:	1885883a 	add	r2,r3,r2
10004080:	1080002b 	ldhuio	r2,0(r2)
10004084:	10803fcc 	andi	r2,r2,255
}
10004088:	e037883a 	mov	sp,fp
1000408c:	df000017 	ldw	fp,0(sp)
10004090:	dec00104 	addi	sp,sp,4
10004094:	f800283a 	ret

10004098 <alt_read_query_entry_32bit>:

alt_u8 alt_read_query_entry_32bit( alt_flash_cfi_dev* flash, int address)
{
10004098:	defffd04 	addi	sp,sp,-12
1000409c:	df000215 	stw	fp,8(sp)
100040a0:	df000204 	addi	fp,sp,8
100040a4:	e13ffe15 	stw	r4,-8(fp)
100040a8:	e17fff15 	stw	r5,-4(fp)
  return (IORD_32DIRECT((alt_u8*)flash->dev.base_addr, address*4) & 0xff);
100040ac:	e0bffe17 	ldw	r2,-8(fp)
100040b0:	10800a17 	ldw	r2,40(r2)
100040b4:	1007883a 	mov	r3,r2
100040b8:	e0bfff17 	ldw	r2,-4(fp)
100040bc:	1085883a 	add	r2,r2,r2
100040c0:	1085883a 	add	r2,r2,r2
100040c4:	1885883a 	add	r2,r3,r2
100040c8:	10800037 	ldwio	r2,0(r2)
100040cc:	10803fcc 	andi	r2,r2,255
}
100040d0:	e037883a 	mov	sp,fp
100040d4:	df000017 	ldw	fp,0(sp)
100040d8:	dec00104 	addi	sp,sp,4
100040dc:	f800283a 	ret

100040e0 <alt_write_flash_command_8bit_device_8bit_mode>:

/*
 * Write an 8 bit command to a flash
 */
void alt_write_flash_command_8bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
100040e0:	defffc04 	addi	sp,sp,-16
100040e4:	df000315 	stw	fp,12(sp)
100040e8:	df000304 	addi	fp,sp,12
100040ec:	e13ffd15 	stw	r4,-12(fp)
100040f0:	e17ffe15 	stw	r5,-8(fp)
100040f4:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset, value);
100040f8:	e0fffd17 	ldw	r3,-12(fp)
100040fc:	e0bffe17 	ldw	r2,-8(fp)
10004100:	1885883a 	add	r2,r3,r2
10004104:	e0ffff03 	ldbu	r3,-4(fp)
10004108:	10c00025 	stbio	r3,0(r2)
  return;
}
1000410c:	e037883a 	mov	sp,fp
10004110:	df000017 	ldw	fp,0(sp)
10004114:	dec00104 	addi	sp,sp,4
10004118:	f800283a 	ret

1000411c <alt_write_flash_command_16bit_device_8bit_mode>:

void alt_write_flash_command_16bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
1000411c:	defffc04 	addi	sp,sp,-16
10004120:	df000315 	stw	fp,12(sp)
10004124:	df000304 	addi	fp,sp,12
10004128:	e13ffd15 	stw	r4,-12(fp)
1000412c:	e17ffe15 	stw	r5,-8(fp)
10004130:	e1bfff05 	stb	r6,-4(fp)
  if (offset % 2)
10004134:	e0bffe17 	ldw	r2,-8(fp)
10004138:	1080004c 	andi	r2,r2,1
1000413c:	10803fcc 	andi	r2,r2,255
10004140:	1005003a 	cmpeq	r2,r2,zero
10004144:	1000081e 	bne	r2,zero,10004168 <alt_write_flash_command_16bit_device_8bit_mode+0x4c>
  {
    IOWR_8DIRECT(base_addr, offset*2, value);
10004148:	e0bffe17 	ldw	r2,-8(fp)
1000414c:	1085883a 	add	r2,r2,r2
10004150:	1007883a 	mov	r3,r2
10004154:	e0bffd17 	ldw	r2,-12(fp)
10004158:	1885883a 	add	r2,r3,r2
1000415c:	e0ffff03 	ldbu	r3,-4(fp)
10004160:	10c00025 	stbio	r3,0(r2)
10004164:	00000806 	br	10004188 <alt_write_flash_command_16bit_device_8bit_mode+0x6c>
  }
  else
  {
    IOWR_8DIRECT(base_addr, (offset*2)+1, value);
10004168:	e0bffe17 	ldw	r2,-8(fp)
1000416c:	1085883a 	add	r2,r2,r2
10004170:	1007883a 	mov	r3,r2
10004174:	e0bffd17 	ldw	r2,-12(fp)
10004178:	1885883a 	add	r2,r3,r2
1000417c:	10800044 	addi	r2,r2,1
10004180:	e0ffff03 	ldbu	r3,-4(fp)
10004184:	10c00025 	stbio	r3,0(r2)
  }
  return;
}
10004188:	e037883a 	mov	sp,fp
1000418c:	df000017 	ldw	fp,0(sp)
10004190:	dec00104 	addi	sp,sp,4
10004194:	f800283a 	ret

10004198 <alt_write_flash_command_32bit_device_8bit_mode>:

void alt_write_flash_command_32bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
10004198:	defffc04 	addi	sp,sp,-16
1000419c:	df000315 	stw	fp,12(sp)
100041a0:	df000304 	addi	fp,sp,12
100041a4:	e13ffd15 	stw	r4,-12(fp)
100041a8:	e17ffe15 	stw	r5,-8(fp)
100041ac:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset*4, value);
100041b0:	e0bffe17 	ldw	r2,-8(fp)
100041b4:	1085883a 	add	r2,r2,r2
100041b8:	1085883a 	add	r2,r2,r2
100041bc:	1007883a 	mov	r3,r2
100041c0:	e0bffd17 	ldw	r2,-12(fp)
100041c4:	1885883a 	add	r2,r3,r2
100041c8:	e0ffff03 	ldbu	r3,-4(fp)
100041cc:	10c00025 	stbio	r3,0(r2)
  return;
}
100041d0:	e037883a 	mov	sp,fp
100041d4:	df000017 	ldw	fp,0(sp)
100041d8:	dec00104 	addi	sp,sp,4
100041dc:	f800283a 	ret

100041e0 <alt_write_flash_command_16bit_device_16bit_mode>:

void alt_write_flash_command_16bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
100041e0:	defffc04 	addi	sp,sp,-16
100041e4:	df000315 	stw	fp,12(sp)
100041e8:	df000304 	addi	fp,sp,12
100041ec:	e13ffd15 	stw	r4,-12(fp)
100041f0:	e17ffe15 	stw	r5,-8(fp)
100041f4:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*2, ((alt_u16)value)& 0x00ff);
100041f8:	e0bffe17 	ldw	r2,-8(fp)
100041fc:	1085883a 	add	r2,r2,r2
10004200:	1007883a 	mov	r3,r2
10004204:	e0bffd17 	ldw	r2,-12(fp)
10004208:	1885883a 	add	r2,r3,r2
1000420c:	e0ffff03 	ldbu	r3,-4(fp)
10004210:	10c0002d 	sthio	r3,0(r2)
  return;
}
10004214:	e037883a 	mov	sp,fp
10004218:	df000017 	ldw	fp,0(sp)
1000421c:	dec00104 	addi	sp,sp,4
10004220:	f800283a 	ret

10004224 <alt_write_flash_command_32bit_device_16bit_mode>:

void alt_write_flash_command_32bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
10004224:	defffc04 	addi	sp,sp,-16
10004228:	df000315 	stw	fp,12(sp)
1000422c:	df000304 	addi	fp,sp,12
10004230:	e13ffd15 	stw	r4,-12(fp)
10004234:	e17ffe15 	stw	r5,-8(fp)
10004238:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*4, ((alt_u16)value)& 0x00ff);
1000423c:	e0bffe17 	ldw	r2,-8(fp)
10004240:	1085883a 	add	r2,r2,r2
10004244:	1085883a 	add	r2,r2,r2
10004248:	1007883a 	mov	r3,r2
1000424c:	e0bffd17 	ldw	r2,-12(fp)
10004250:	1885883a 	add	r2,r3,r2
10004254:	e0ffff03 	ldbu	r3,-4(fp)
10004258:	10c0002d 	sthio	r3,0(r2)
  return;
}
1000425c:	e037883a 	mov	sp,fp
10004260:	df000017 	ldw	fp,0(sp)
10004264:	dec00104 	addi	sp,sp,4
10004268:	f800283a 	ret

1000426c <alt_write_flash_command_32bit_device_32bit_mode>:

void alt_write_flash_command_32bit_device_32bit_mode( void* base_addr, int offset, alt_u8 value)
{
1000426c:	defffc04 	addi	sp,sp,-16
10004270:	df000315 	stw	fp,12(sp)
10004274:	df000304 	addi	fp,sp,12
10004278:	e13ffd15 	stw	r4,-12(fp)
1000427c:	e17ffe15 	stw	r5,-8(fp)
10004280:	e1bfff05 	stb	r6,-4(fp)
  IOWR_32DIRECT(base_addr, offset*4, ((alt_u32)value)& 0x000000ff);
10004284:	e0bffe17 	ldw	r2,-8(fp)
10004288:	1085883a 	add	r2,r2,r2
1000428c:	1085883a 	add	r2,r2,r2
10004290:	1007883a 	mov	r3,r2
10004294:	e0bffd17 	ldw	r2,-12(fp)
10004298:	1885883a 	add	r2,r3,r2
1000429c:	e0ffff03 	ldbu	r3,-4(fp)
100042a0:	10c00035 	stwio	r3,0(r2)
  return;
}
100042a4:	e037883a 	mov	sp,fp
100042a8:	df000017 	ldw	fp,0(sp)
100042ac:	dec00104 	addi	sp,sp,4
100042b0:	f800283a 	ret

100042b4 <alt_write_native_8bit>:

/*
 * Write the value passed to the flash
 */
void alt_write_native_8bit( void* address, alt_u32 value)
{
100042b4:	defffd04 	addi	sp,sp,-12
100042b8:	df000215 	stw	fp,8(sp)
100042bc:	df000204 	addi	fp,sp,8
100042c0:	e13ffe15 	stw	r4,-8(fp)
100042c4:	e17fff15 	stw	r5,-4(fp)
  IOWR_8DIRECT(address, 0, (alt_u8)(value&0xff));
100042c8:	e0bfff17 	ldw	r2,-4(fp)
100042cc:	10c03fcc 	andi	r3,r2,255
100042d0:	e0bffe17 	ldw	r2,-8(fp)
100042d4:	10c00025 	stbio	r3,0(r2)
  return;
}
100042d8:	e037883a 	mov	sp,fp
100042dc:	df000017 	ldw	fp,0(sp)
100042e0:	dec00104 	addi	sp,sp,4
100042e4:	f800283a 	ret

100042e8 <alt_write_native_16bit>:

void alt_write_native_16bit( void* address, alt_u32 value)
{
100042e8:	defffd04 	addi	sp,sp,-12
100042ec:	df000215 	stw	fp,8(sp)
100042f0:	df000204 	addi	fp,sp,8
100042f4:	e13ffe15 	stw	r4,-8(fp)
100042f8:	e17fff15 	stw	r5,-4(fp)
  IOWR_16DIRECT(address, 0, ((alt_u16)value)& 0xffff);
100042fc:	e0bfff17 	ldw	r2,-4(fp)
10004300:	10ffffcc 	andi	r3,r2,65535
10004304:	e0bffe17 	ldw	r2,-8(fp)
10004308:	10c0002d 	sthio	r3,0(r2)
  return;
}
1000430c:	e037883a 	mov	sp,fp
10004310:	df000017 	ldw	fp,0(sp)
10004314:	dec00104 	addi	sp,sp,4
10004318:	f800283a 	ret

1000431c <alt_write_native_32bit>:

void alt_write_native_32bit( void* address, alt_u32 value)
{
1000431c:	defffd04 	addi	sp,sp,-12
10004320:	df000215 	stw	fp,8(sp)
10004324:	df000204 	addi	fp,sp,8
10004328:	e13ffe15 	stw	r4,-8(fp)
1000432c:	e17fff15 	stw	r5,-4(fp)
  IOWR_32DIRECT(address, 0, value);
10004330:	e0ffff17 	ldw	r3,-4(fp)
10004334:	e0bffe17 	ldw	r2,-8(fp)
10004338:	10c00035 	stwio	r3,0(r2)
  return;
}
1000433c:	e037883a 	mov	sp,fp
10004340:	df000017 	ldw	fp,0(sp)
10004344:	dec00104 	addi	sp,sp,4
10004348:	f800283a 	ret

1000434c <alt_set_flash_width_func>:
 * 
 * Setup the function pointers for writing a byte to the flash for the width
 * of the device
 */
int alt_set_flash_width_func( alt_flash_cfi_dev* flash)
{ 
1000434c:	defffb04 	addi	sp,sp,-20
10004350:	df000415 	stw	fp,16(sp)
10004354:	df000404 	addi	fp,sp,16
10004358:	e13ffd15 	stw	r4,-12(fp)
  int ret_code = 0;
1000435c:	e03ffc15 	stw	zero,-16(fp)
  
  switch(flash->mode_width)
10004360:	e0bffd17 	ldw	r2,-12(fp)
10004364:	10802e17 	ldw	r2,184(r2)
10004368:	e0bfff15 	stw	r2,-4(fp)
1000436c:	e0ffff17 	ldw	r3,-4(fp)
10004370:	188000a0 	cmpeqi	r2,r3,2
10004374:	1000261e 	bne	r2,zero,10004410 <alt_set_flash_width_func+0xc4>
10004378:	e0ffff17 	ldw	r3,-4(fp)
1000437c:	18800120 	cmpeqi	r2,r3,4
10004380:	1000391e 	bne	r2,zero,10004468 <alt_set_flash_width_func+0x11c>
10004384:	e0ffff17 	ldw	r3,-4(fp)
10004388:	18800060 	cmpeqi	r2,r3,1
1000438c:	1000011e 	bne	r2,zero,10004394 <alt_set_flash_width_func+0x48>
10004390:	00003e06 	br	1000448c <alt_set_flash_width_func+0x140>
  {
    case 1:
    {
      flash->write_native = alt_write_native_8bit;
10004394:	e0fffd17 	ldw	r3,-12(fp)
10004398:	00840034 	movhi	r2,4096
1000439c:	1090ad04 	addi	r2,r2,17076
100043a0:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 1)
100043a4:	e0bffd17 	ldw	r2,-12(fp)
100043a8:	10802f17 	ldw	r2,188(r2)
100043ac:	10800058 	cmpnei	r2,r2,1
100043b0:	1000051e 	bne	r2,zero,100043c8 <alt_set_flash_width_func+0x7c>
      {
        flash->write_command = alt_write_flash_command_8bit_device_8bit_mode;
100043b4:	e0fffd17 	ldw	r3,-12(fp)
100043b8:	00840034 	movhi	r2,4096
100043bc:	10903804 	addi	r2,r2,16608
100043c0:	18803315 	stw	r2,204(r3)
100043c4:	00003306 	br	10004494 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 2)
100043c8:	e0bffd17 	ldw	r2,-12(fp)
100043cc:	10802f17 	ldw	r2,188(r2)
100043d0:	10800098 	cmpnei	r2,r2,2
100043d4:	1000051e 	bne	r2,zero,100043ec <alt_set_flash_width_func+0xa0>
      {
        flash->write_command = alt_write_flash_command_16bit_device_8bit_mode;
100043d8:	e0fffd17 	ldw	r3,-12(fp)
100043dc:	00840034 	movhi	r2,4096
100043e0:	10904704 	addi	r2,r2,16668
100043e4:	18803315 	stw	r2,204(r3)
100043e8:	00002a06 	br	10004494 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
100043ec:	e0bffd17 	ldw	r2,-12(fp)
100043f0:	10802f17 	ldw	r2,188(r2)
100043f4:	10800118 	cmpnei	r2,r2,4
100043f8:	1000261e 	bne	r2,zero,10004494 <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
100043fc:	e0fffd17 	ldw	r3,-12(fp)
10004400:	00840034 	movhi	r2,4096
10004404:	10906604 	addi	r2,r2,16792
10004408:	18803315 	stw	r2,204(r3)
      }
      break;
1000440c:	00002106 	br	10004494 <alt_set_flash_width_func+0x148>
    }
    case 2:
    {
      flash->write_native = alt_write_native_16bit;
10004410:	e0fffd17 	ldw	r3,-12(fp)
10004414:	00840034 	movhi	r2,4096
10004418:	1090ba04 	addi	r2,r2,17128
1000441c:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 2)
10004420:	e0bffd17 	ldw	r2,-12(fp)
10004424:	10802f17 	ldw	r2,188(r2)
10004428:	10800098 	cmpnei	r2,r2,2
1000442c:	1000051e 	bne	r2,zero,10004444 <alt_set_flash_width_func+0xf8>
      {
        flash->write_command = alt_write_flash_command_16bit_device_16bit_mode;
10004430:	e0fffd17 	ldw	r3,-12(fp)
10004434:	00840034 	movhi	r2,4096
10004438:	10907804 	addi	r2,r2,16864
1000443c:	18803315 	stw	r2,204(r3)
10004440:	00001406 	br	10004494 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
10004444:	e0bffd17 	ldw	r2,-12(fp)
10004448:	10802f17 	ldw	r2,188(r2)
1000444c:	10800118 	cmpnei	r2,r2,4
10004450:	1000101e 	bne	r2,zero,10004494 <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_16bit_mode;
10004454:	e0fffd17 	ldw	r3,-12(fp)
10004458:	00840034 	movhi	r2,4096
1000445c:	10908904 	addi	r2,r2,16932
10004460:	18803315 	stw	r2,204(r3)
      }

      break;
10004464:	00000b06 	br	10004494 <alt_set_flash_width_func+0x148>
    }
    case 4:
    {
      flash->write_native = alt_write_native_32bit;
10004468:	e0fffd17 	ldw	r3,-12(fp)
1000446c:	00840034 	movhi	r2,4096
10004470:	1090c704 	addi	r2,r2,17180
10004474:	18803515 	stw	r2,212(r3)
      flash->write_command = alt_write_flash_command_32bit_device_32bit_mode;
10004478:	e0fffd17 	ldw	r3,-12(fp)
1000447c:	00840034 	movhi	r2,4096
10004480:	10909b04 	addi	r2,r2,17004
10004484:	18803315 	stw	r2,204(r3)
      break;
10004488:	00000206 	br	10004494 <alt_set_flash_width_func+0x148>
    }
    default:
    {
      ret_code = -EACCES;
1000448c:	00bffcc4 	movi	r2,-13
10004490:	e0bffc15 	stw	r2,-16(fp)
    }
  }

  if (!ret_code)
10004494:	e0bffc17 	ldw	r2,-16(fp)
10004498:	1004c03a 	cmpne	r2,r2,zero
1000449c:	10001e1e 	bne	r2,zero,10004518 <alt_set_flash_width_func+0x1cc>
  {
    switch(flash->device_width)
100044a0:	e0bffd17 	ldw	r2,-12(fp)
100044a4:	10802f17 	ldw	r2,188(r2)
100044a8:	e0bffe15 	stw	r2,-8(fp)
100044ac:	e0fffe17 	ldw	r3,-8(fp)
100044b0:	188000a0 	cmpeqi	r2,r3,2
100044b4:	10000c1e 	bne	r2,zero,100044e8 <alt_set_flash_width_func+0x19c>
100044b8:	e0fffe17 	ldw	r3,-8(fp)
100044bc:	18800120 	cmpeqi	r2,r3,4
100044c0:	10000e1e 	bne	r2,zero,100044fc <alt_set_flash_width_func+0x1b0>
100044c4:	e0fffe17 	ldw	r3,-8(fp)
100044c8:	18800060 	cmpeqi	r2,r3,1
100044cc:	1000011e 	bne	r2,zero,100044d4 <alt_set_flash_width_func+0x188>
100044d0:	00000f06 	br	10004510 <alt_set_flash_width_func+0x1c4>
    {
      case 1:
      {
        flash->read_query = alt_read_query_entry_8bit;
100044d4:	e0fffd17 	ldw	r3,-12(fp)
100044d8:	00840034 	movhi	r2,4096
100044dc:	10900504 	addi	r2,r2,16404
100044e0:	18803415 	stw	r2,208(r3)
        break;
100044e4:	00000c06 	br	10004518 <alt_set_flash_width_func+0x1cc>
      }
      case 2:
      {
        flash->read_query = alt_read_query_entry_16bit;
100044e8:	e0fffd17 	ldw	r3,-12(fp)
100044ec:	00840034 	movhi	r2,4096
100044f0:	10901504 	addi	r2,r2,16468
100044f4:	18803415 	stw	r2,208(r3)
        break;
100044f8:	00000706 	br	10004518 <alt_set_flash_width_func+0x1cc>
      }
      case 4:
      {
        flash->read_query = alt_read_query_entry_32bit;
100044fc:	e0fffd17 	ldw	r3,-12(fp)
10004500:	00840034 	movhi	r2,4096
10004504:	10902604 	addi	r2,r2,16536
10004508:	18803415 	stw	r2,208(r3)
        break;
1000450c:	00000206 	br	10004518 <alt_set_flash_width_func+0x1cc>
      }
      default:
      {
        ret_code = -EACCES;
10004510:	00bffcc4 	movi	r2,-13
10004514:	e0bffc15 	stw	r2,-16(fp)
      }
    }
  }

  return ret_code;
10004518:	e0bffc17 	ldw	r2,-16(fp)
}
1000451c:	e037883a 	mov	sp,fp
10004520:	df000017 	ldw	fp,0(sp)
10004524:	dec00104 	addi	sp,sp,4
10004528:	f800283a 	ret

1000452c <alt_set_flash_algorithm_func>:
 * 
 * Setup the function pointers to the functions for this algorithm
 * 
 */
int alt_set_flash_algorithm_func( alt_flash_cfi_dev* flash)
{
1000452c:	defffc04 	addi	sp,sp,-16
10004530:	df000315 	stw	fp,12(sp)
10004534:	df000304 	addi	fp,sp,12
10004538:	e13ffe15 	stw	r4,-8(fp)
  int ret_code = 0;
1000453c:	e03ffd15 	stw	zero,-12(fp)
 
  switch(flash->algorithm)
10004540:	e0bffe17 	ldw	r2,-8(fp)
10004544:	10802d17 	ldw	r2,180(r2)
10004548:	e0bfff15 	stw	r2,-4(fp)
1000454c:	e0ffff17 	ldw	r3,-4(fp)
10004550:	188000a0 	cmpeqi	r2,r3,2
10004554:	1000071e 	bne	r2,zero,10004574 <alt_set_flash_algorithm_func+0x48>
10004558:	e0ffff17 	ldw	r3,-4(fp)
1000455c:	188000e0 	cmpeqi	r2,r3,3
10004560:	10000d1e 	bne	r2,zero,10004598 <alt_set_flash_algorithm_func+0x6c>
10004564:	e0ffff17 	ldw	r3,-4(fp)
10004568:	18800060 	cmpeqi	r2,r3,1
1000456c:	10000a1e 	bne	r2,zero,10004598 <alt_set_flash_algorithm_func+0x6c>
10004570:	00001206 	br	100045bc <alt_set_flash_algorithm_func+0x90>
  {
    case CFI_ALG_AMD:
    {
      flash->dev.erase_block = alt_erase_block_amd;
10004574:	e0fffe17 	ldw	r3,-8(fp)
10004578:	00840034 	movhi	r2,4096
1000457c:	109f2404 	addi	r2,r2,31888
10004580:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_amd;
10004584:	e0fffe17 	ldw	r3,-8(fp)
10004588:	00840034 	movhi	r2,4096
1000458c:	109f0a04 	addi	r2,r2,31784
10004590:	18800915 	stw	r2,36(r3)
      break;
10004594:	00000b06 	br	100045c4 <alt_set_flash_algorithm_func+0x98>
    }
    case CFI_ALG_INTEL:
    case CFI_ALG_INTEL_STRATA:
    {
      flash->dev.erase_block = alt_erase_block_intel;
10004598:	e0fffe17 	ldw	r3,-8(fp)
1000459c:	00840074 	movhi	r2,4097
100045a0:	10a04304 	addi	r2,r2,-32500
100045a4:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_intel;
100045a8:	e0fffe17 	ldw	r3,-8(fp)
100045ac:	00840074 	movhi	r2,4097
100045b0:	10a02204 	addi	r2,r2,-32632
100045b4:	18800915 	stw	r2,36(r3)
      break;
100045b8:	00000206 	br	100045c4 <alt_set_flash_algorithm_func+0x98>
    }
    default:
    {
      ret_code = -EIO;
100045bc:	00bffec4 	movi	r2,-5
100045c0:	e0bffd15 	stw	r2,-12(fp)
    }
  } 
  return ret_code;  
100045c4:	e0bffd17 	ldw	r2,-12(fp)
}
100045c8:	e037883a 	mov	sp,fp
100045cc:	df000017 	ldw	fp,0(sp)
100045d0:	dec00104 	addi	sp,sp,4
100045d4:	f800283a 	ret

100045d8 <alt_read_16bit_query_entry>:
 * read_16bit_query_entry
 * 
 * Read a 16 bit entry from the CFI Query table
 */
static alt_u16 alt_read_16bit_query_entry(alt_flash_cfi_dev* flash, int address)
{
100045d8:	defffb04 	addi	sp,sp,-20
100045dc:	dfc00415 	stw	ra,16(sp)
100045e0:	df000315 	stw	fp,12(sp)
100045e4:	df000304 	addi	fp,sp,12
100045e8:	e13ffe15 	stw	r4,-8(fp)
100045ec:	e17fff15 	stw	r5,-4(fp)
  alt_u16 ret_code;

  ret_code = (*flash->read_query)( flash, address);
100045f0:	e0bffe17 	ldw	r2,-8(fp)
100045f4:	10803417 	ldw	r2,208(r2)
100045f8:	e13ffe17 	ldw	r4,-8(fp)
100045fc:	e17fff17 	ldw	r5,-4(fp)
10004600:	103ee83a 	callr	r2
10004604:	10803fcc 	andi	r2,r2,255
10004608:	e0bffd0d 	sth	r2,-12(fp)
  ret_code |= (((int)(*flash->read_query)(flash, address+1)) << 8);                   
1000460c:	e0bffe17 	ldw	r2,-8(fp)
10004610:	10c03417 	ldw	r3,208(r2)
10004614:	e0bfff17 	ldw	r2,-4(fp)
10004618:	11400044 	addi	r5,r2,1
1000461c:	e13ffe17 	ldw	r4,-8(fp)
10004620:	183ee83a 	callr	r3
10004624:	10803fcc 	andi	r2,r2,255
10004628:	1004923a 	slli	r2,r2,8
1000462c:	1007883a 	mov	r3,r2
10004630:	e0bffd0b 	ldhu	r2,-12(fp)
10004634:	1884b03a 	or	r2,r3,r2
10004638:	e0bffd0d 	sth	r2,-12(fp)

  return ret_code;
1000463c:	e0bffd0b 	ldhu	r2,-12(fp)
}
10004640:	e037883a 	mov	sp,fp
10004644:	dfc00117 	ldw	ra,4(sp)
10004648:	df000017 	ldw	fp,0(sp)
1000464c:	dec00204 	addi	sp,sp,8
10004650:	f800283a 	ret

10004654 <alt_read_cfi_table>:
 * read_cfi_table
 * 
 * Read the CFI Table
 */
int alt_read_cfi_table(alt_flash_cfi_dev* flash)
{
10004654:	defff104 	addi	sp,sp,-60
10004658:	dfc00e15 	stw	ra,56(sp)
1000465c:	df000d15 	stw	fp,52(sp)
10004660:	dc000c15 	stw	r16,48(sp)
10004664:	df000c04 	addi	fp,sp,48
10004668:	e13ffe15 	stw	r4,-8(fp)
  int   i,j;
  int   device_size;
  int   ret_code = 0;
1000466c:	e03ffa15 	stw	zero,-24(fp)
  int   size = 0;
10004670:	e03ff915 	stw	zero,-28(fp)
  int   swap;
  int   typical_timeout;
  int   max_timeout;
  int   offset = 0;
10004674:	e03ff515 	stw	zero,-44(fp)
   
  /*
  * Check that the Primary Vendor Specific table
  * starts with the letters PRI                                                         
  */
  ret_code = alt_check_primary_table(flash);
10004678:	e13ffe17 	ldw	r4,-8(fp)
1000467c:	00053e00 	call	100053e0 <alt_check_primary_table>
10004680:	e0bffa15 	stw	r2,-24(fp)

  if (!ret_code)
10004684:	e0bffa17 	ldw	r2,-24(fp)
10004688:	1004c03a 	cmpne	r2,r2,zero
1000468c:	1001621e 	bne	r2,zero,10004c18 <alt_read_cfi_table+0x5c4>
  {
    flash->algorithm = (*flash->read_query)(flash, 0x13);
10004690:	e0bffe17 	ldw	r2,-8(fp)
10004694:	10803417 	ldw	r2,208(r2)
10004698:	e13ffe17 	ldw	r4,-8(fp)
1000469c:	014004c4 	movi	r5,19
100046a0:	103ee83a 	callr	r2
100046a4:	10c03fcc 	andi	r3,r2,255
100046a8:	e0bffe17 	ldw	r2,-8(fp)
100046ac:	10c02d15 	stw	r3,180(r2)
  
    /* 
     * Let's read the write timeout values from the flash 
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
100046b0:	e0bffe17 	ldw	r2,-8(fp)
100046b4:	10803417 	ldw	r2,208(r2)
100046b8:	e13ffe17 	ldw	r4,-8(fp)
100046bc:	014007c4 	movi	r5,31
100046c0:	103ee83a 	callr	r2
100046c4:	10803fcc 	andi	r2,r2,255
100046c8:	e0bff715 	stw	r2,-36(fp)
    max_timeout = (*flash->read_query)( flash, 0x23);
100046cc:	e0bffe17 	ldw	r2,-8(fp)
100046d0:	10803417 	ldw	r2,208(r2)
100046d4:	e13ffe17 	ldw	r4,-8(fp)
100046d8:	014008c4 	movi	r5,35
100046dc:	103ee83a 	callr	r2
100046e0:	10803fcc 	andi	r2,r2,255
100046e4:	e0bff615 	stw	r2,-40(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
100046e8:	e0bff717 	ldw	r2,-36(fp)
100046ec:	1005003a 	cmpeq	r2,r2,zero
100046f0:	1000031e 	bne	r2,zero,10004700 <alt_read_cfi_table+0xac>
100046f4:	e0bff617 	ldw	r2,-40(fp)
100046f8:	1004c03a 	cmpne	r2,r2,zero
100046fc:	1000041e 	bne	r2,zero,10004710 <alt_read_cfi_table+0xbc>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
10004700:	e0fffe17 	ldw	r3,-8(fp)
10004704:	0080fa04 	movi	r2,1000
10004708:	18803015 	stw	r2,192(r3)
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
    max_timeout = (*flash->read_query)( flash, 0x23);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
1000470c:	00000706 	br	1000472c <alt_read_cfi_table+0xd8>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
    }
    else
    {
      flash->write_timeout = (1 << typical_timeout) * (1 << max_timeout);
10004710:	00c00044 	movi	r3,1
10004714:	e0bff717 	ldw	r2,-36(fp)
10004718:	1886983a 	sll	r3,r3,r2
1000471c:	e0bff617 	ldw	r2,-40(fp)
10004720:	1886983a 	sll	r3,r3,r2
10004724:	e0bffe17 	ldw	r2,-8(fp)
10004728:	10c03015 	stw	r3,192(r2)
    }
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
1000472c:	e0bffe17 	ldw	r2,-8(fp)
10004730:	10803417 	ldw	r2,208(r2)
10004734:	e13ffe17 	ldw	r4,-8(fp)
10004738:	01400844 	movi	r5,33
1000473c:	103ee83a 	callr	r2
10004740:	10803fcc 	andi	r2,r2,255
10004744:	e0bff715 	stw	r2,-36(fp)
    max_timeout = (*flash->read_query)( flash, 0x25);
10004748:	e0bffe17 	ldw	r2,-8(fp)
1000474c:	10803417 	ldw	r2,208(r2)
10004750:	e13ffe17 	ldw	r4,-8(fp)
10004754:	01400944 	movi	r5,37
10004758:	103ee83a 	callr	r2
1000475c:	10803fcc 	andi	r2,r2,255
10004760:	e0bff615 	stw	r2,-40(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
10004764:	e0bff717 	ldw	r2,-36(fp)
10004768:	1005003a 	cmpeq	r2,r2,zero
1000476c:	1000031e 	bne	r2,zero,1000477c <alt_read_cfi_table+0x128>
10004770:	e0bff617 	ldw	r2,-40(fp)
10004774:	1004c03a 	cmpne	r2,r2,zero
10004778:	1000051e 	bne	r2,zero,10004790 <alt_read_cfi_table+0x13c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
1000477c:	e0fffe17 	ldw	r3,-8(fp)
10004780:	00804c74 	movhi	r2,305
10004784:	108b4004 	addi	r2,r2,11520
10004788:	18803115 	stw	r2,196(r3)
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
    max_timeout = (*flash->read_query)( flash, 0x25);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
1000478c:	00000806 	br	100047b0 <alt_read_cfi_table+0x15c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
    }
    else
    {
      flash->erase_timeout = (1 << typical_timeout) * (1 << max_timeout) * 1000;
10004790:	00c00044 	movi	r3,1
10004794:	e0bff717 	ldw	r2,-36(fp)
10004798:	1886983a 	sll	r3,r3,r2
1000479c:	e0bff617 	ldw	r2,-40(fp)
100047a0:	1884983a 	sll	r2,r3,r2
100047a4:	10c0fa24 	muli	r3,r2,1000
100047a8:	e0bffe17 	ldw	r2,-8(fp)
100047ac:	10c03115 	stw	r3,196(r2)
    }
   
    device_size = 0x1 << (*flash->read_query)( flash, 0x27);
100047b0:	e0bffe17 	ldw	r2,-8(fp)
100047b4:	10803417 	ldw	r2,208(r2)
100047b8:	e13ffe17 	ldw	r4,-8(fp)
100047bc:	014009c4 	movi	r5,39
100047c0:	103ee83a 	callr	r2
100047c4:	10c03fcc 	andi	r3,r2,255
100047c8:	00800044 	movi	r2,1
100047cc:	10c4983a 	sll	r2,r2,r3
100047d0:	e0bffb15 	stw	r2,-20(fp)
  
    flash->dev.number_of_regions = (*flash->read_query)(flash, 0x2c);
100047d4:	e0bffe17 	ldw	r2,-8(fp)
100047d8:	10803417 	ldw	r2,208(r2)
100047dc:	e13ffe17 	ldw	r4,-8(fp)
100047e0:	01400b04 	movi	r5,44
100047e4:	103ee83a 	callr	r2
100047e8:	10c03fcc 	andi	r3,r2,255
100047ec:	e0bffe17 	ldw	r2,-8(fp)
100047f0:	10c00c15 	stw	r3,48(r2)
    
    if (flash->dev.number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
100047f4:	e0bffe17 	ldw	r2,-8(fp)
100047f8:	10800c17 	ldw	r2,48(r2)
100047fc:	10800250 	cmplti	r2,r2,9
10004800:	1000031e 	bne	r2,zero,10004810 <alt_read_cfi_table+0x1bc>
    {
      ret_code = -ENOMEM;
10004804:	00bffd04 	movi	r2,-12
10004808:	e0bffa15 	stw	r2,-24(fp)
1000480c:	00005e06 	br	10004988 <alt_read_cfi_table+0x334>
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
10004810:	e03ffd15 	stw	zero,-12(fp)
10004814:	00005306 	br	10004964 <alt_read_cfi_table+0x310>
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
10004818:	e43ffd17 	ldw	r16,-12(fp)
1000481c:	e0bffd17 	ldw	r2,-12(fp)
10004820:	1085883a 	add	r2,r2,r2
10004824:	1085883a 	add	r2,r2,r2
10004828:	11400b44 	addi	r5,r2,45
1000482c:	e13ffe17 	ldw	r4,-8(fp)
10004830:	00045d80 	call	100045d8 <alt_read_16bit_query_entry>
10004834:	113fffcc 	andi	r4,r2,65535
10004838:	e0fffe17 	ldw	r3,-8(fp)
1000483c:	8004913a 	slli	r2,r16,4
10004840:	10c5883a 	add	r2,r2,r3
10004844:	10800f04 	addi	r2,r2,60
10004848:	11000015 	stw	r4,0(r2)
                                                            flash,
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
1000484c:	e17ffd17 	ldw	r5,-12(fp)
10004850:	e0bffd17 	ldw	r2,-12(fp)
10004854:	e0fffe17 	ldw	r3,-8(fp)
10004858:	1004913a 	slli	r2,r2,4
1000485c:	10c5883a 	add	r2,r2,r3
10004860:	10800f04 	addi	r2,r2,60
10004864:	10800017 	ldw	r2,0(r2)
10004868:	11000044 	addi	r4,r2,1
1000486c:	e0fffe17 	ldw	r3,-8(fp)
10004870:	2804913a 	slli	r2,r5,4
10004874:	10c5883a 	add	r2,r2,r3
10004878:	10800f04 	addi	r2,r2,60
1000487c:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
10004880:	e43ffd17 	ldw	r16,-12(fp)
10004884:	e0bffd17 	ldw	r2,-12(fp)
10004888:	1085883a 	add	r2,r2,r2
1000488c:	1085883a 	add	r2,r2,r2
10004890:	11400bc4 	addi	r5,r2,47
10004894:	e13ffe17 	ldw	r4,-8(fp)
10004898:	00045d80 	call	100045d8 <alt_read_16bit_query_entry>
1000489c:	113fffcc 	andi	r4,r2,65535
100048a0:	e0fffe17 	ldw	r3,-8(fp)
100048a4:	8004913a 	slli	r2,r16,4
100048a8:	10c5883a 	add	r2,r2,r3
100048ac:	10801004 	addi	r2,r2,64
100048b0:	11000015 	stw	r4,0(r2)
                                                              (0x2F+i*4));
        flash->dev.region_info[i].block_size *= 256;
100048b4:	e17ffd17 	ldw	r5,-12(fp)
100048b8:	e0bffd17 	ldw	r2,-12(fp)
100048bc:	e0fffe17 	ldw	r3,-8(fp)
100048c0:	1004913a 	slli	r2,r2,4
100048c4:	10c5883a 	add	r2,r2,r3
100048c8:	10801004 	addi	r2,r2,64
100048cc:	10800017 	ldw	r2,0(r2)
100048d0:	1008923a 	slli	r4,r2,8
100048d4:	e0fffe17 	ldw	r3,-8(fp)
100048d8:	2804913a 	slli	r2,r5,4
100048dc:	10c5883a 	add	r2,r2,r3
100048e0:	10801004 	addi	r2,r2,64
100048e4:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].region_size = 
100048e8:	e17ffd17 	ldw	r5,-12(fp)
100048ec:	e0bffd17 	ldw	r2,-12(fp)
100048f0:	e0fffe17 	ldw	r3,-8(fp)
100048f4:	1004913a 	slli	r2,r2,4
100048f8:	10c5883a 	add	r2,r2,r3
100048fc:	10800f04 	addi	r2,r2,60
10004900:	11000017 	ldw	r4,0(r2)
10004904:	e0bffd17 	ldw	r2,-12(fp)
10004908:	e0fffe17 	ldw	r3,-8(fp)
1000490c:	1004913a 	slli	r2,r2,4
10004910:	10c5883a 	add	r2,r2,r3
10004914:	10801004 	addi	r2,r2,64
10004918:	10800017 	ldw	r2,0(r2)
1000491c:	2089383a 	mul	r4,r4,r2
10004920:	e0fffe17 	ldw	r3,-8(fp)
10004924:	2804913a 	slli	r2,r5,4
10004928:	10c5883a 	add	r2,r2,r3
1000492c:	10800e04 	addi	r2,r2,56
10004930:	11000015 	stw	r4,0(r2)
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
10004934:	e0bffd17 	ldw	r2,-12(fp)
10004938:	e0fffe17 	ldw	r3,-8(fp)
1000493c:	1004913a 	slli	r2,r2,4
10004940:	10c5883a 	add	r2,r2,r3
10004944:	10800e04 	addi	r2,r2,56
10004948:	10c00017 	ldw	r3,0(r2)
1000494c:	e0bff917 	ldw	r2,-28(fp)
10004950:	10c5883a 	add	r2,r2,r3
10004954:	e0bff915 	stw	r2,-28(fp)
    {
      ret_code = -ENOMEM;
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
10004958:	e0bffd17 	ldw	r2,-12(fp)
1000495c:	10800044 	addi	r2,r2,1
10004960:	e0bffd15 	stw	r2,-12(fp)
10004964:	e0bffe17 	ldw	r2,-8(fp)
10004968:	10c00c17 	ldw	r3,48(r2)
1000496c:	e0bffd17 	ldw	r2,-12(fp)
10004970:	10ffa916 	blt	r2,r3,10004818 <alt_read_cfi_table+0x1c4>
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
      }
       
      if (size != device_size)
10004974:	e0fff917 	ldw	r3,-28(fp)
10004978:	e0bffb17 	ldw	r2,-20(fp)
1000497c:	18800226 	beq	r3,r2,10004988 <alt_read_cfi_table+0x334>
      {
        ret_code = -ENODEV;
10004980:	00bffb44 	movi	r2,-19
10004984:	e0bffa15 	stw	r2,-24(fp)
      }
    }
    
    boot_mode = (*flash->read_query)( flash, flash->primary_address + 0xf);
10004988:	e0bffe17 	ldw	r2,-8(fp)
1000498c:	10c03417 	ldw	r3,208(r2)
10004990:	e0bffe17 	ldw	r2,-8(fp)
10004994:	10803217 	ldw	r2,200(r2)
10004998:	114003c4 	addi	r5,r2,15
1000499c:	e13ffe17 	ldw	r4,-8(fp)
100049a0:	183ee83a 	callr	r3
100049a4:	e0bff405 	stb	r2,-48(fp)
     * Intel Flash parts describe the sections in the order they appear
     * for AMD they just put all the small ones first then the bigger ones
     * So if it's a top boot part we have to reverse the order of the sectors
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
100049a8:	e0bffe17 	ldw	r2,-8(fp)
100049ac:	10802d17 	ldw	r2,180(r2)
100049b0:	10800098 	cmpnei	r2,r2,2
100049b4:	1000601e 	bne	r2,zero,10004b38 <alt_read_cfi_table+0x4e4>
100049b8:	e0bff403 	ldbu	r2,-48(fp)
100049bc:	108000d8 	cmpnei	r2,r2,3
100049c0:	10005d1e 	bne	r2,zero,10004b38 <alt_read_cfi_table+0x4e4>
    {
      for(i=flash->dev.number_of_regions-1, j=0;
100049c4:	e0bffe17 	ldw	r2,-8(fp)
100049c8:	10800c17 	ldw	r2,48(r2)
100049cc:	10bfffc4 	addi	r2,r2,-1
100049d0:	e0bffd15 	stw	r2,-12(fp)
100049d4:	e03ffc15 	stw	zero,-16(fp)
          j<=i;i--,j++)
100049d8:	00005406 	br	10004b2c <alt_read_cfi_table+0x4d8>
      {
        swap = flash->dev.region_info[i].region_size;
100049dc:	e0bffd17 	ldw	r2,-12(fp)
100049e0:	e0fffe17 	ldw	r3,-8(fp)
100049e4:	1004913a 	slli	r2,r2,4
100049e8:	10c5883a 	add	r2,r2,r3
100049ec:	10800e04 	addi	r2,r2,56
100049f0:	10800017 	ldw	r2,0(r2)
100049f4:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].region_size =  
100049f8:	e17ffd17 	ldw	r5,-12(fp)
100049fc:	e0bffc17 	ldw	r2,-16(fp)
10004a00:	e0fffe17 	ldw	r3,-8(fp)
10004a04:	1004913a 	slli	r2,r2,4
10004a08:	10c5883a 	add	r2,r2,r3
10004a0c:	10800e04 	addi	r2,r2,56
10004a10:	11000017 	ldw	r4,0(r2)
10004a14:	e0fffe17 	ldw	r3,-8(fp)
10004a18:	2804913a 	slli	r2,r5,4
10004a1c:	10c5883a 	add	r2,r2,r3
10004a20:	10800e04 	addi	r2,r2,56
10004a24:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].region_size;
        flash->dev.region_info[j].region_size = swap;
10004a28:	e0bffc17 	ldw	r2,-16(fp)
10004a2c:	e0fffe17 	ldw	r3,-8(fp)
10004a30:	1004913a 	slli	r2,r2,4
10004a34:	10c5883a 	add	r2,r2,r3
10004a38:	10c00e04 	addi	r3,r2,56
10004a3c:	e0bff817 	ldw	r2,-32(fp)
10004a40:	18800015 	stw	r2,0(r3)

        swap = flash->dev.region_info[i].block_size;
10004a44:	e0bffd17 	ldw	r2,-12(fp)
10004a48:	e0fffe17 	ldw	r3,-8(fp)
10004a4c:	1004913a 	slli	r2,r2,4
10004a50:	10c5883a 	add	r2,r2,r3
10004a54:	10801004 	addi	r2,r2,64
10004a58:	10800017 	ldw	r2,0(r2)
10004a5c:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].block_size =  
10004a60:	e17ffd17 	ldw	r5,-12(fp)
10004a64:	e0bffc17 	ldw	r2,-16(fp)
10004a68:	e0fffe17 	ldw	r3,-8(fp)
10004a6c:	1004913a 	slli	r2,r2,4
10004a70:	10c5883a 	add	r2,r2,r3
10004a74:	10801004 	addi	r2,r2,64
10004a78:	11000017 	ldw	r4,0(r2)
10004a7c:	e0fffe17 	ldw	r3,-8(fp)
10004a80:	2804913a 	slli	r2,r5,4
10004a84:	10c5883a 	add	r2,r2,r3
10004a88:	10801004 	addi	r2,r2,64
10004a8c:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].block_size;
        flash->dev.region_info[j].block_size = swap;
10004a90:	e0bffc17 	ldw	r2,-16(fp)
10004a94:	e0fffe17 	ldw	r3,-8(fp)
10004a98:	1004913a 	slli	r2,r2,4
10004a9c:	10c5883a 	add	r2,r2,r3
10004aa0:	10c01004 	addi	r3,r2,64
10004aa4:	e0bff817 	ldw	r2,-32(fp)
10004aa8:	18800015 	stw	r2,0(r3)
 
        swap = flash->dev.region_info[i].number_of_blocks;
10004aac:	e0bffd17 	ldw	r2,-12(fp)
10004ab0:	e0fffe17 	ldw	r3,-8(fp)
10004ab4:	1004913a 	slli	r2,r2,4
10004ab8:	10c5883a 	add	r2,r2,r3
10004abc:	10800f04 	addi	r2,r2,60
10004ac0:	10800017 	ldw	r2,0(r2)
10004ac4:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].number_of_blocks =  
10004ac8:	e17ffd17 	ldw	r5,-12(fp)
10004acc:	e0bffc17 	ldw	r2,-16(fp)
10004ad0:	e0fffe17 	ldw	r3,-8(fp)
10004ad4:	1004913a 	slli	r2,r2,4
10004ad8:	10c5883a 	add	r2,r2,r3
10004adc:	10800f04 	addi	r2,r2,60
10004ae0:	11000017 	ldw	r4,0(r2)
10004ae4:	e0fffe17 	ldw	r3,-8(fp)
10004ae8:	2804913a 	slli	r2,r5,4
10004aec:	10c5883a 	add	r2,r2,r3
10004af0:	10800f04 	addi	r2,r2,60
10004af4:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].number_of_blocks;
        flash->dev.region_info[j].number_of_blocks = swap;
10004af8:	e0bffc17 	ldw	r2,-16(fp)
10004afc:	e0fffe17 	ldw	r3,-8(fp)
10004b00:	1004913a 	slli	r2,r2,4
10004b04:	10c5883a 	add	r2,r2,r3
10004b08:	10c00f04 	addi	r3,r2,60
10004b0c:	e0bff817 	ldw	r2,-32(fp)
10004b10:	18800015 	stw	r2,0(r3)
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
    {
      for(i=flash->dev.number_of_regions-1, j=0;
          j<=i;i--,j++)
10004b14:	e0bffd17 	ldw	r2,-12(fp)
10004b18:	10bfffc4 	addi	r2,r2,-1
10004b1c:	e0bffd15 	stw	r2,-12(fp)
10004b20:	e0bffc17 	ldw	r2,-16(fp)
10004b24:	10800044 	addi	r2,r2,1
10004b28:	e0bffc15 	stw	r2,-16(fp)
10004b2c:	e0fffc17 	ldw	r3,-16(fp)
10004b30:	e0bffd17 	ldw	r2,-12(fp)
10004b34:	10ffa90e 	bge	r2,r3,100049dc <alt_read_cfi_table+0x388>
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
10004b38:	e03ffd15 	stw	zero,-12(fp)
10004b3c:	00001306 	br	10004b8c <alt_read_cfi_table+0x538>
    {
      flash->dev.region_info[i].offset = offset;
10004b40:	e0bffd17 	ldw	r2,-12(fp)
10004b44:	e0fffe17 	ldw	r3,-8(fp)
10004b48:	1004913a 	slli	r2,r2,4
10004b4c:	10c5883a 	add	r2,r2,r3
10004b50:	10c00d04 	addi	r3,r2,52
10004b54:	e0bff517 	ldw	r2,-44(fp)
10004b58:	18800015 	stw	r2,0(r3)
      offset += flash->dev.region_info[i].region_size;
10004b5c:	e0bffd17 	ldw	r2,-12(fp)
10004b60:	e0fffe17 	ldw	r3,-8(fp)
10004b64:	1004913a 	slli	r2,r2,4
10004b68:	10c5883a 	add	r2,r2,r3
10004b6c:	10800e04 	addi	r2,r2,56
10004b70:	10c00017 	ldw	r3,0(r2)
10004b74:	e0bff517 	ldw	r2,-44(fp)
10004b78:	10c5883a 	add	r2,r2,r3
10004b7c:	e0bff515 	stw	r2,-44(fp)
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
10004b80:	e0bffd17 	ldw	r2,-12(fp)
10004b84:	10800044 	addi	r2,r2,1
10004b88:	e0bffd15 	stw	r2,-12(fp)
10004b8c:	e0bffe17 	ldw	r2,-8(fp)
10004b90:	10c00c17 	ldw	r3,48(r2)
10004b94:	e0bffd17 	ldw	r2,-12(fp)
10004b98:	10ffe916 	blt	r2,r3,10004b40 <alt_read_cfi_table+0x4ec>
    {
      flash->dev.region_info[i].offset = offset;
      offset += flash->dev.region_info[i].region_size;
    }

    switch(flash->algorithm)
10004b9c:	e0bffe17 	ldw	r2,-8(fp)
10004ba0:	10802d17 	ldw	r2,180(r2)
10004ba4:	e0bfff15 	stw	r2,-4(fp)
10004ba8:	e0ffff17 	ldw	r3,-4(fp)
10004bac:	188000a0 	cmpeqi	r2,r3,2
10004bb0:	1000071e 	bne	r2,zero,10004bd0 <alt_read_cfi_table+0x57c>
10004bb4:	e0ffff17 	ldw	r3,-4(fp)
10004bb8:	188000e0 	cmpeqi	r2,r3,3
10004bbc:	10000c1e 	bne	r2,zero,10004bf0 <alt_read_cfi_table+0x59c>
10004bc0:	e0ffff17 	ldw	r3,-4(fp)
10004bc4:	18800060 	cmpeqi	r2,r3,1
10004bc8:	1000091e 	bne	r2,zero,10004bf0 <alt_read_cfi_table+0x59c>
10004bcc:	00001006 	br	10004c10 <alt_read_cfi_table+0x5bc>
    {
      case CFI_ALG_AMD:
      {
        (*flash->write_command)(flash->dev.base_addr, 
10004bd0:	e0bffe17 	ldw	r2,-8(fp)
10004bd4:	10c03317 	ldw	r3,204(r2)
10004bd8:	e0bffe17 	ldw	r2,-8(fp)
10004bdc:	11000a17 	ldw	r4,40(r2)
10004be0:	01401544 	movi	r5,85
10004be4:	01803c04 	movi	r6,240
10004be8:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_AMD_MODE);
        break;
10004bec:	00000a06 	br	10004c18 <alt_read_cfi_table+0x5c4>
      }
      case CFI_ALG_INTEL:
      case CFI_ALG_INTEL_STRATA:
      {
        (*flash->write_command)(flash->dev.base_addr, 
10004bf0:	e0bffe17 	ldw	r2,-8(fp)
10004bf4:	10c03317 	ldw	r3,204(r2)
10004bf8:	e0bffe17 	ldw	r2,-8(fp)
10004bfc:	11000a17 	ldw	r4,40(r2)
10004c00:	01401544 	movi	r5,85
10004c04:	01803fc4 	movi	r6,255
10004c08:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_INTEL_MODE);
        break;
10004c0c:	00000206 	br	10004c18 <alt_read_cfi_table+0x5c4>
      }
      default:
      {
        ret_code = -EIO;
10004c10:	00bffec4 	movi	r2,-5
10004c14:	e0bffa15 	stw	r2,-24(fp)
      }
    } 
  }  

  return ret_code;
10004c18:	e0bffa17 	ldw	r2,-24(fp)
}
10004c1c:	e037883a 	mov	sp,fp
10004c20:	dfc00217 	ldw	ra,8(sp)
10004c24:	df000117 	ldw	fp,4(sp)
10004c28:	dc000017 	ldw	r16,0(sp)
10004c2c:	dec00304 	addi	sp,sp,12
10004c30:	f800283a 	ret

10004c34 <alt_read_cfi_width>:
 * 
 * Work out the width of the device we're talking to and sanity check that we  
 * can read the CFI and the Primary Vendor specific Table
 */
int alt_read_cfi_width(alt_flash_cfi_dev* flash)
{
10004c34:	defff704 	addi	sp,sp,-36
10004c38:	dfc00815 	stw	ra,32(sp)
10004c3c:	df000715 	stw	fp,28(sp)
10004c40:	df000704 	addi	fp,sp,28
10004c44:	e13fff15 	stw	r4,-4(fp)
  int i;
  alt_u8 byte_id[12];
  alt_u16 iface;
  int ret_code = 0;
10004c48:	e03ff915 	stw	zero,-28(fp)

  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
10004c4c:	e0bfff17 	ldw	r2,-4(fp)
10004c50:	11000a17 	ldw	r4,40(r2)
10004c54:	01401544 	movi	r5,85
10004c58:	01802604 	movi	r6,152
10004c5c:	00040e00 	call	100040e0 <alt_write_flash_command_8bit_device_8bit_mode>

  for(i=0;i<3;i++)
10004c60:	e03ffb15 	stw	zero,-20(fp)
10004c64:	00000f06 	br	10004ca4 <alt_read_cfi_width+0x70>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
10004c68:	e13ffb17 	ldw	r4,-20(fp)
10004c6c:	e0bfff17 	ldw	r2,-4(fp)
10004c70:	10800a17 	ldw	r2,40(r2)
10004c74:	1007883a 	mov	r3,r2
10004c78:	e0bffb17 	ldw	r2,-20(fp)
10004c7c:	1885883a 	add	r2,r3,r2
10004c80:	10800404 	addi	r2,r2,16
10004c84:	10800023 	ldbuio	r2,0(r2)
10004c88:	1007883a 	mov	r3,r2
10004c8c:	e0bffc04 	addi	r2,fp,-16
10004c90:	1105883a 	add	r2,r2,r4
10004c94:	10c00005 	stb	r3,0(r2)
  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);

  for(i=0;i<3;i++)
10004c98:	e0bffb17 	ldw	r2,-20(fp)
10004c9c:	10800044 	addi	r2,r2,1
10004ca0:	e0bffb15 	stw	r2,-20(fp)
10004ca4:	e0bffb17 	ldw	r2,-20(fp)
10004ca8:	108000d0 	cmplti	r2,r2,3
10004cac:	103fee1e 	bne	r2,zero,10004c68 <alt_read_cfi_width+0x34>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
10004cb0:	e0bffc03 	ldbu	r2,-16(fp)
10004cb4:	10803fcc 	andi	r2,r2,255
10004cb8:	10801458 	cmpnei	r2,r2,81
10004cbc:	10001d1e 	bne	r2,zero,10004d34 <alt_read_cfi_width+0x100>
10004cc0:	e0bffc43 	ldbu	r2,-15(fp)
10004cc4:	10803fcc 	andi	r2,r2,255
10004cc8:	10801498 	cmpnei	r2,r2,82
10004ccc:	1000191e 	bne	r2,zero,10004d34 <alt_read_cfi_width+0x100>
10004cd0:	e0bffc83 	ldbu	r2,-14(fp)
10004cd4:	10803fcc 	andi	r2,r2,255
10004cd8:	10801658 	cmpnei	r2,r2,89
10004cdc:	1000151e 	bne	r2,zero,10004d34 <alt_read_cfi_width+0x100>
      (byte_id[1] == 'R') &&
      (byte_id[2] == 'Y'))
  {
    flash->mode_width = 1;
10004ce0:	e0ffff17 	ldw	r3,-4(fp)
10004ce4:	00800044 	movi	r2,1
10004ce8:	18802e15 	stw	r2,184(r3)
    flash->device_width = 1; 
10004cec:	e0ffff17 	ldw	r3,-4(fp)
10004cf0:	00800044 	movi	r2,1
10004cf4:	18802f15 	stw	r2,188(r3)
    iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR);
10004cf8:	e0bfff17 	ldw	r2,-4(fp)
10004cfc:	10800a17 	ldw	r2,40(r2)
10004d00:	10800a04 	addi	r2,r2,40
10004d04:	1080002b 	ldhuio	r2,0(r2)
10004d08:	e0bffa0d 	sth	r2,-24(fp)
    iface += 1;
10004d0c:	e0bffa0b 	ldhu	r2,-24(fp)
10004d10:	10800044 	addi	r2,r2,1
10004d14:	e0bffa0d 	sth	r2,-24(fp)
    if (!(iface & 0x1))
10004d18:	e0bffa0b 	ldhu	r2,-24(fp)
10004d1c:	1080004c 	andi	r2,r2,1
10004d20:	1004c03a 	cmpne	r2,r2,zero
10004d24:	1001a81e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
    {
      ret_code = -ENODEV;
10004d28:	00bffb44 	movi	r2,-19
10004d2c:	e0bff915 	stw	r2,-28(fp)
  for(i=0;i<3;i++)
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
10004d30:	0001a506 	br	100053c8 <alt_read_cfi_width+0x794>
  else
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
10004d34:	e0bfff17 	ldw	r2,-4(fp)
10004d38:	11000a17 	ldw	r4,40(r2)
10004d3c:	01401544 	movi	r5,85
10004d40:	01802604 	movi	r6,152
10004d44:	000411c0 	call	1000411c <alt_write_flash_command_16bit_device_8bit_mode>
    for(i=0;i<6;i++)
10004d48:	e03ffb15 	stw	zero,-20(fp)
10004d4c:	00000f06 	br	10004d8c <alt_read_cfi_width+0x158>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
10004d50:	e13ffb17 	ldw	r4,-20(fp)
10004d54:	e0bfff17 	ldw	r2,-4(fp)
10004d58:	10800a17 	ldw	r2,40(r2)
10004d5c:	1007883a 	mov	r3,r2
10004d60:	e0bffb17 	ldw	r2,-20(fp)
10004d64:	1885883a 	add	r2,r3,r2
10004d68:	10800804 	addi	r2,r2,32
10004d6c:	10800023 	ldbuio	r2,0(r2)
10004d70:	1007883a 	mov	r3,r2
10004d74:	e0bffc04 	addi	r2,fp,-16
10004d78:	1105883a 	add	r2,r2,r4
10004d7c:	10c00005 	stb	r3,0(r2)
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
    for(i=0;i<6;i++)
10004d80:	e0bffb17 	ldw	r2,-20(fp)
10004d84:	10800044 	addi	r2,r2,1
10004d88:	e0bffb15 	stw	r2,-20(fp)
10004d8c:	e0bffb17 	ldw	r2,-20(fp)
10004d90:	10800190 	cmplti	r2,r2,6
10004d94:	103fee1e 	bne	r2,zero,10004d50 <alt_read_cfi_width+0x11c>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
10004d98:	e0bffc03 	ldbu	r2,-16(fp)
10004d9c:	10803fcc 	andi	r2,r2,255
10004da0:	10801458 	cmpnei	r2,r2,81
10004da4:	1000291e 	bne	r2,zero,10004e4c <alt_read_cfi_width+0x218>
10004da8:	e0bffc43 	ldbu	r2,-15(fp)
10004dac:	10803fcc 	andi	r2,r2,255
10004db0:	10801458 	cmpnei	r2,r2,81
10004db4:	1000251e 	bne	r2,zero,10004e4c <alt_read_cfi_width+0x218>
10004db8:	e0bffc83 	ldbu	r2,-14(fp)
10004dbc:	10803fcc 	andi	r2,r2,255
10004dc0:	10801498 	cmpnei	r2,r2,82
10004dc4:	1000211e 	bne	r2,zero,10004e4c <alt_read_cfi_width+0x218>
10004dc8:	e0bffcc3 	ldbu	r2,-13(fp)
10004dcc:	10803fcc 	andi	r2,r2,255
10004dd0:	10801498 	cmpnei	r2,r2,82
10004dd4:	10001d1e 	bne	r2,zero,10004e4c <alt_read_cfi_width+0x218>
10004dd8:	e0bffd03 	ldbu	r2,-12(fp)
10004ddc:	10803fcc 	andi	r2,r2,255
10004de0:	10801658 	cmpnei	r2,r2,89
10004de4:	1000191e 	bne	r2,zero,10004e4c <alt_read_cfi_width+0x218>
10004de8:	e0bffd43 	ldbu	r2,-11(fp)
10004dec:	10803fcc 	andi	r2,r2,255
10004df0:	10801658 	cmpnei	r2,r2,89
10004df4:	1000151e 	bne	r2,zero,10004e4c <alt_read_cfi_width+0x218>
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
        (byte_id[4] == 'Y') && 
        (byte_id[5] == 'Y'))
    {
      flash->mode_width = 1;
10004df8:	e0ffff17 	ldw	r3,-4(fp)
10004dfc:	00800044 	movi	r2,1
10004e00:	18802e15 	stw	r2,184(r3)
      flash->device_width = 2; 
10004e04:	e0ffff17 	ldw	r3,-4(fp)
10004e08:	00800084 	movi	r2,2
10004e0c:	18802f15 	stw	r2,188(r3)
      iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
10004e10:	e0bfff17 	ldw	r2,-4(fp)
10004e14:	10800a17 	ldw	r2,40(r2)
10004e18:	10801404 	addi	r2,r2,80
10004e1c:	1080002b 	ldhuio	r2,0(r2)
10004e20:	e0bffa0d 	sth	r2,-24(fp)
      iface += 1;
10004e24:	e0bffa0b 	ldhu	r2,-24(fp)
10004e28:	10800044 	addi	r2,r2,1
10004e2c:	e0bffa0d 	sth	r2,-24(fp)
      if (!(iface & 0x1))
10004e30:	e0bffa0b 	ldhu	r2,-24(fp)
10004e34:	1080004c 	andi	r2,r2,1
10004e38:	1004c03a 	cmpne	r2,r2,zero
10004e3c:	1001621e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
      {
        ret_code = -ENODEV;
10004e40:	00bffb44 	movi	r2,-19
10004e44:	e0bff915 	stw	r2,-28(fp)
    for(i=0;i<6;i++)
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
10004e48:	00015f06 	br	100053c8 <alt_read_cfi_width+0x794>
    else
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
10004e4c:	e0bfff17 	ldw	r2,-4(fp)
10004e50:	11000a17 	ldw	r4,40(r2)
10004e54:	01401544 	movi	r5,85
10004e58:	01802604 	movi	r6,152
10004e5c:	00041e00 	call	100041e0 <alt_write_flash_command_16bit_device_16bit_mode>
      for(i=0;i<6;i++)
10004e60:	e03ffb15 	stw	zero,-20(fp)
10004e64:	00000f06 	br	10004ea4 <alt_read_cfi_width+0x270>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
10004e68:	e13ffb17 	ldw	r4,-20(fp)
10004e6c:	e0bfff17 	ldw	r2,-4(fp)
10004e70:	10800a17 	ldw	r2,40(r2)
10004e74:	1007883a 	mov	r3,r2
10004e78:	e0bffb17 	ldw	r2,-20(fp)
10004e7c:	1885883a 	add	r2,r3,r2
10004e80:	10800804 	addi	r2,r2,32
10004e84:	10800023 	ldbuio	r2,0(r2)
10004e88:	1007883a 	mov	r3,r2
10004e8c:	e0bffc04 	addi	r2,fp,-16
10004e90:	1105883a 	add	r2,r2,r4
10004e94:	10c00005 	stb	r3,0(r2)
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
      for(i=0;i<6;i++)
10004e98:	e0bffb17 	ldw	r2,-20(fp)
10004e9c:	10800044 	addi	r2,r2,1
10004ea0:	e0bffb15 	stw	r2,-20(fp)
10004ea4:	e0bffb17 	ldw	r2,-20(fp)
10004ea8:	10800190 	cmplti	r2,r2,6
10004eac:	103fee1e 	bne	r2,zero,10004e68 <alt_read_cfi_width+0x234>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
10004eb0:	e0bffc03 	ldbu	r2,-16(fp)
10004eb4:	10803fcc 	andi	r2,r2,255
10004eb8:	10801458 	cmpnei	r2,r2,81
10004ebc:	1000291e 	bne	r2,zero,10004f64 <alt_read_cfi_width+0x330>
10004ec0:	e0bffc43 	ldbu	r2,-15(fp)
10004ec4:	10803fcc 	andi	r2,r2,255
10004ec8:	1004c03a 	cmpne	r2,r2,zero
10004ecc:	1000251e 	bne	r2,zero,10004f64 <alt_read_cfi_width+0x330>
10004ed0:	e0bffc83 	ldbu	r2,-14(fp)
10004ed4:	10803fcc 	andi	r2,r2,255
10004ed8:	10801498 	cmpnei	r2,r2,82
10004edc:	1000211e 	bne	r2,zero,10004f64 <alt_read_cfi_width+0x330>
10004ee0:	e0bffcc3 	ldbu	r2,-13(fp)
10004ee4:	10803fcc 	andi	r2,r2,255
10004ee8:	1004c03a 	cmpne	r2,r2,zero
10004eec:	10001d1e 	bne	r2,zero,10004f64 <alt_read_cfi_width+0x330>
10004ef0:	e0bffd03 	ldbu	r2,-12(fp)
10004ef4:	10803fcc 	andi	r2,r2,255
10004ef8:	10801658 	cmpnei	r2,r2,89
10004efc:	1000191e 	bne	r2,zero,10004f64 <alt_read_cfi_width+0x330>
10004f00:	e0bffd43 	ldbu	r2,-11(fp)
10004f04:	10803fcc 	andi	r2,r2,255
10004f08:	1004c03a 	cmpne	r2,r2,zero
10004f0c:	1000151e 	bne	r2,zero,10004f64 <alt_read_cfi_width+0x330>
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'Y') && 
          (byte_id[5] == '\0'))
      {
        flash->mode_width = 2;
10004f10:	e0ffff17 	ldw	r3,-4(fp)
10004f14:	00800084 	movi	r2,2
10004f18:	18802e15 	stw	r2,184(r3)
        flash->device_width = 2; 
10004f1c:	e0ffff17 	ldw	r3,-4(fp)
10004f20:	00800084 	movi	r2,2
10004f24:	18802f15 	stw	r2,188(r3)
        iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
10004f28:	e0bfff17 	ldw	r2,-4(fp)
10004f2c:	10800a17 	ldw	r2,40(r2)
10004f30:	10801404 	addi	r2,r2,80
10004f34:	1080002b 	ldhuio	r2,0(r2)
10004f38:	e0bffa0d 	sth	r2,-24(fp)
        iface += 1;
10004f3c:	e0bffa0b 	ldhu	r2,-24(fp)
10004f40:	10800044 	addi	r2,r2,1
10004f44:	e0bffa0d 	sth	r2,-24(fp)
        if (!(iface & 0x2))
10004f48:	e0bffa0b 	ldhu	r2,-24(fp)
10004f4c:	1080008c 	andi	r2,r2,2
10004f50:	1004c03a 	cmpne	r2,r2,zero
10004f54:	10011c1e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
        {
          ret_code = -ENODEV;
10004f58:	00bffb44 	movi	r2,-19
10004f5c:	e0bff915 	stw	r2,-28(fp)
      for(i=0;i<6;i++)
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
10004f60:	00011906 	br	100053c8 <alt_read_cfi_width+0x794>
      else
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
10004f64:	e0bfff17 	ldw	r2,-4(fp)
10004f68:	11000a17 	ldw	r4,40(r2)
10004f6c:	01401544 	movi	r5,85
10004f70:	01802604 	movi	r6,152
10004f74:	000426c0 	call	1000426c <alt_write_flash_command_32bit_device_32bit_mode>
        for(i=0;i<12;i++)
10004f78:	e03ffb15 	stw	zero,-20(fp)
10004f7c:	00000f06 	br	10004fbc <alt_read_cfi_width+0x388>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
10004f80:	e13ffb17 	ldw	r4,-20(fp)
10004f84:	e0bfff17 	ldw	r2,-4(fp)
10004f88:	10800a17 	ldw	r2,40(r2)
10004f8c:	1007883a 	mov	r3,r2
10004f90:	e0bffb17 	ldw	r2,-20(fp)
10004f94:	1885883a 	add	r2,r3,r2
10004f98:	10801004 	addi	r2,r2,64
10004f9c:	10800023 	ldbuio	r2,0(r2)
10004fa0:	1007883a 	mov	r3,r2
10004fa4:	e0bffc04 	addi	r2,fp,-16
10004fa8:	1105883a 	add	r2,r2,r4
10004fac:	10c00005 	stb	r3,0(r2)
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
        for(i=0;i<12;i++)
10004fb0:	e0bffb17 	ldw	r2,-20(fp)
10004fb4:	10800044 	addi	r2,r2,1
10004fb8:	e0bffb15 	stw	r2,-20(fp)
10004fbc:	e0bffb17 	ldw	r2,-20(fp)
10004fc0:	10800310 	cmplti	r2,r2,12
10004fc4:	103fee1e 	bne	r2,zero,10004f80 <alt_read_cfi_width+0x34c>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
10004fc8:	e0bffc03 	ldbu	r2,-16(fp)
10004fcc:	10803fcc 	andi	r2,r2,255
10004fd0:	10801458 	cmpnei	r2,r2,81
10004fd4:	1000411e 	bne	r2,zero,100050dc <alt_read_cfi_width+0x4a8>
10004fd8:	e0bffc43 	ldbu	r2,-15(fp)
10004fdc:	10803fcc 	andi	r2,r2,255
10004fe0:	1004c03a 	cmpne	r2,r2,zero
10004fe4:	10003d1e 	bne	r2,zero,100050dc <alt_read_cfi_width+0x4a8>
10004fe8:	e0bffc83 	ldbu	r2,-14(fp)
10004fec:	10803fcc 	andi	r2,r2,255
10004ff0:	1004c03a 	cmpne	r2,r2,zero
10004ff4:	1000391e 	bne	r2,zero,100050dc <alt_read_cfi_width+0x4a8>
10004ff8:	e0bffcc3 	ldbu	r2,-13(fp)
10004ffc:	10803fcc 	andi	r2,r2,255
10005000:	1004c03a 	cmpne	r2,r2,zero
10005004:	1000351e 	bne	r2,zero,100050dc <alt_read_cfi_width+0x4a8>
10005008:	e0bffd03 	ldbu	r2,-12(fp)
1000500c:	10803fcc 	andi	r2,r2,255
10005010:	10801498 	cmpnei	r2,r2,82
10005014:	1000311e 	bne	r2,zero,100050dc <alt_read_cfi_width+0x4a8>
10005018:	e0bffd43 	ldbu	r2,-11(fp)
1000501c:	10803fcc 	andi	r2,r2,255
10005020:	1004c03a 	cmpne	r2,r2,zero
10005024:	10002d1e 	bne	r2,zero,100050dc <alt_read_cfi_width+0x4a8>
10005028:	e0bffd83 	ldbu	r2,-10(fp)
1000502c:	10803fcc 	andi	r2,r2,255
10005030:	1004c03a 	cmpne	r2,r2,zero
10005034:	1000291e 	bne	r2,zero,100050dc <alt_read_cfi_width+0x4a8>
10005038:	e0bffdc3 	ldbu	r2,-9(fp)
1000503c:	10803fcc 	andi	r2,r2,255
10005040:	1004c03a 	cmpne	r2,r2,zero
10005044:	1000251e 	bne	r2,zero,100050dc <alt_read_cfi_width+0x4a8>
10005048:	e0bffe03 	ldbu	r2,-8(fp)
1000504c:	10803fcc 	andi	r2,r2,255
10005050:	10801658 	cmpnei	r2,r2,89
10005054:	1000211e 	bne	r2,zero,100050dc <alt_read_cfi_width+0x4a8>
10005058:	e0bffe43 	ldbu	r2,-7(fp)
1000505c:	10803fcc 	andi	r2,r2,255
10005060:	1004c03a 	cmpne	r2,r2,zero
10005064:	10001d1e 	bne	r2,zero,100050dc <alt_read_cfi_width+0x4a8>
10005068:	e0bffe83 	ldbu	r2,-6(fp)
1000506c:	10803fcc 	andi	r2,r2,255
10005070:	1004c03a 	cmpne	r2,r2,zero
10005074:	1000191e 	bne	r2,zero,100050dc <alt_read_cfi_width+0x4a8>
10005078:	e0bffec3 	ldbu	r2,-5(fp)
1000507c:	10803fcc 	andi	r2,r2,255
10005080:	1004c03a 	cmpne	r2,r2,zero
10005084:	1000151e 	bne	r2,zero,100050dc <alt_read_cfi_width+0x4a8>
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
          (byte_id[10] == '\0') && 
          (byte_id[11] == '\0'))
        {
          flash->mode_width = 4;
10005088:	e0ffff17 	ldw	r3,-4(fp)
1000508c:	00800104 	movi	r2,4
10005090:	18802e15 	stw	r2,184(r3)
          flash->device_width = 4; 
10005094:	e0ffff17 	ldw	r3,-4(fp)
10005098:	00800104 	movi	r2,4
1000509c:	18802f15 	stw	r2,188(r3)
          iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
100050a0:	e0bfff17 	ldw	r2,-4(fp)
100050a4:	10800a17 	ldw	r2,40(r2)
100050a8:	10802804 	addi	r2,r2,160
100050ac:	10800037 	ldwio	r2,0(r2)
100050b0:	e0bffa0d 	sth	r2,-24(fp)
          iface += 1;
100050b4:	e0bffa0b 	ldhu	r2,-24(fp)
100050b8:	10800044 	addi	r2,r2,1
100050bc:	e0bffa0d 	sth	r2,-24(fp)
          if (!(iface & 0x4))
100050c0:	e0bffa0b 	ldhu	r2,-24(fp)
100050c4:	1080010c 	andi	r2,r2,4
100050c8:	1004c03a 	cmpne	r2,r2,zero
100050cc:	1000be1e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
          {
            ret_code = -ENODEV;
100050d0:	00bffb44 	movi	r2,-19
100050d4:	e0bff915 	stw	r2,-28(fp)
        for(i=0;i<12;i++)
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
100050d8:	0000bb06 	br	100053c8 <alt_read_cfi_width+0x794>
        else
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
100050dc:	e0bfff17 	ldw	r2,-4(fp)
100050e0:	11000a17 	ldw	r4,40(r2)
100050e4:	01401544 	movi	r5,85
100050e8:	01802604 	movi	r6,152
100050ec:	00042240 	call	10004224 <alt_write_flash_command_32bit_device_16bit_mode>
          for(i=0;i<12;i++)
100050f0:	e03ffb15 	stw	zero,-20(fp)
100050f4:	00000f06 	br	10005134 <alt_read_cfi_width+0x500>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
100050f8:	e13ffb17 	ldw	r4,-20(fp)
100050fc:	e0bfff17 	ldw	r2,-4(fp)
10005100:	10800a17 	ldw	r2,40(r2)
10005104:	1007883a 	mov	r3,r2
10005108:	e0bffb17 	ldw	r2,-20(fp)
1000510c:	1885883a 	add	r2,r3,r2
10005110:	10801004 	addi	r2,r2,64
10005114:	10800023 	ldbuio	r2,0(r2)
10005118:	1007883a 	mov	r3,r2
1000511c:	e0bffc04 	addi	r2,fp,-16
10005120:	1105883a 	add	r2,r2,r4
10005124:	10c00005 	stb	r3,0(r2)
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
          for(i=0;i<12;i++)
10005128:	e0bffb17 	ldw	r2,-20(fp)
1000512c:	10800044 	addi	r2,r2,1
10005130:	e0bffb15 	stw	r2,-20(fp)
10005134:	e0bffb17 	ldw	r2,-20(fp)
10005138:	10800310 	cmplti	r2,r2,12
1000513c:	103fee1e 	bne	r2,zero,100050f8 <alt_read_cfi_width+0x4c4>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
10005140:	e0bffc03 	ldbu	r2,-16(fp)
10005144:	10803fcc 	andi	r2,r2,255
10005148:	10801458 	cmpnei	r2,r2,81
1000514c:	1000411e 	bne	r2,zero,10005254 <alt_read_cfi_width+0x620>
10005150:	e0bffc43 	ldbu	r2,-15(fp)
10005154:	10803fcc 	andi	r2,r2,255
10005158:	1004c03a 	cmpne	r2,r2,zero
1000515c:	10003d1e 	bne	r2,zero,10005254 <alt_read_cfi_width+0x620>
10005160:	e0bffc83 	ldbu	r2,-14(fp)
10005164:	10803fcc 	andi	r2,r2,255
10005168:	10801458 	cmpnei	r2,r2,81
1000516c:	1000391e 	bne	r2,zero,10005254 <alt_read_cfi_width+0x620>
10005170:	e0bffcc3 	ldbu	r2,-13(fp)
10005174:	10803fcc 	andi	r2,r2,255
10005178:	1004c03a 	cmpne	r2,r2,zero
1000517c:	1000351e 	bne	r2,zero,10005254 <alt_read_cfi_width+0x620>
10005180:	e0bffd03 	ldbu	r2,-12(fp)
10005184:	10803fcc 	andi	r2,r2,255
10005188:	10801498 	cmpnei	r2,r2,82
1000518c:	1000311e 	bne	r2,zero,10005254 <alt_read_cfi_width+0x620>
10005190:	e0bffd43 	ldbu	r2,-11(fp)
10005194:	10803fcc 	andi	r2,r2,255
10005198:	1004c03a 	cmpne	r2,r2,zero
1000519c:	10002d1e 	bne	r2,zero,10005254 <alt_read_cfi_width+0x620>
100051a0:	e0bffd83 	ldbu	r2,-10(fp)
100051a4:	10803fcc 	andi	r2,r2,255
100051a8:	10801498 	cmpnei	r2,r2,82
100051ac:	1000291e 	bne	r2,zero,10005254 <alt_read_cfi_width+0x620>
100051b0:	e0bffdc3 	ldbu	r2,-9(fp)
100051b4:	10803fcc 	andi	r2,r2,255
100051b8:	1004c03a 	cmpne	r2,r2,zero
100051bc:	1000251e 	bne	r2,zero,10005254 <alt_read_cfi_width+0x620>
100051c0:	e0bffe03 	ldbu	r2,-8(fp)
100051c4:	10803fcc 	andi	r2,r2,255
100051c8:	10801658 	cmpnei	r2,r2,89
100051cc:	1000211e 	bne	r2,zero,10005254 <alt_read_cfi_width+0x620>
100051d0:	e0bffe43 	ldbu	r2,-7(fp)
100051d4:	10803fcc 	andi	r2,r2,255
100051d8:	1004c03a 	cmpne	r2,r2,zero
100051dc:	10001d1e 	bne	r2,zero,10005254 <alt_read_cfi_width+0x620>
100051e0:	e0bffe83 	ldbu	r2,-6(fp)
100051e4:	10803fcc 	andi	r2,r2,255
100051e8:	10801658 	cmpnei	r2,r2,89
100051ec:	1000191e 	bne	r2,zero,10005254 <alt_read_cfi_width+0x620>
100051f0:	e0bffec3 	ldbu	r2,-5(fp)
100051f4:	10803fcc 	andi	r2,r2,255
100051f8:	1004c03a 	cmpne	r2,r2,zero
100051fc:	1000151e 	bne	r2,zero,10005254 <alt_read_cfi_width+0x620>
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
              (byte_id[10] == 'Y') &&
              (byte_id[11] == '\0'))
          {
            flash->mode_width = 2;
10005200:	e0ffff17 	ldw	r3,-4(fp)
10005204:	00800084 	movi	r2,2
10005208:	18802e15 	stw	r2,184(r3)
            flash->device_width = 4; 
1000520c:	e0ffff17 	ldw	r3,-4(fp)
10005210:	00800104 	movi	r2,4
10005214:	18802f15 	stw	r2,188(r3)
            iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
10005218:	e0bfff17 	ldw	r2,-4(fp)
1000521c:	10800a17 	ldw	r2,40(r2)
10005220:	10802804 	addi	r2,r2,160
10005224:	10800037 	ldwio	r2,0(r2)
10005228:	e0bffa0d 	sth	r2,-24(fp)
            iface += 1;
1000522c:	e0bffa0b 	ldhu	r2,-24(fp)
10005230:	10800044 	addi	r2,r2,1
10005234:	e0bffa0d 	sth	r2,-24(fp)
            if (!(iface & 0x4))
10005238:	e0bffa0b 	ldhu	r2,-24(fp)
1000523c:	1080010c 	andi	r2,r2,4
10005240:	1004c03a 	cmpne	r2,r2,zero
10005244:	1000601e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
            {
              ret_code = -ENODEV;
10005248:	00bffb44 	movi	r2,-19
1000524c:	e0bff915 	stw	r2,-28(fp)
          for(i=0;i<12;i++)
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
10005250:	00005d06 	br	100053c8 <alt_read_cfi_width+0x794>
          else
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
10005254:	e0bfff17 	ldw	r2,-4(fp)
10005258:	11000a17 	ldw	r4,40(r2)
1000525c:	01401544 	movi	r5,85
10005260:	01802604 	movi	r6,152
10005264:	00041980 	call	10004198 <alt_write_flash_command_32bit_device_8bit_mode>
            for(i=0;i<12;i++)
10005268:	e03ffb15 	stw	zero,-20(fp)
1000526c:	00000f06 	br	100052ac <alt_read_cfi_width+0x678>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
10005270:	e13ffb17 	ldw	r4,-20(fp)
10005274:	e0bfff17 	ldw	r2,-4(fp)
10005278:	10800a17 	ldw	r2,40(r2)
1000527c:	1007883a 	mov	r3,r2
10005280:	e0bffb17 	ldw	r2,-20(fp)
10005284:	1885883a 	add	r2,r3,r2
10005288:	10801004 	addi	r2,r2,64
1000528c:	10800023 	ldbuio	r2,0(r2)
10005290:	1007883a 	mov	r3,r2
10005294:	e0bffc04 	addi	r2,fp,-16
10005298:	1105883a 	add	r2,r2,r4
1000529c:	10c00005 	stb	r3,0(r2)
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
            for(i=0;i<12;i++)
100052a0:	e0bffb17 	ldw	r2,-20(fp)
100052a4:	10800044 	addi	r2,r2,1
100052a8:	e0bffb15 	stw	r2,-20(fp)
100052ac:	e0bffb17 	ldw	r2,-20(fp)
100052b0:	10800310 	cmplti	r2,r2,12
100052b4:	103fee1e 	bne	r2,zero,10005270 <alt_read_cfi_width+0x63c>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
100052b8:	e0bffc03 	ldbu	r2,-16(fp)
100052bc:	10803fcc 	andi	r2,r2,255
100052c0:	10801458 	cmpnei	r2,r2,81
100052c4:	1000401e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
100052c8:	e0bffc43 	ldbu	r2,-15(fp)
100052cc:	10803fcc 	andi	r2,r2,255
100052d0:	10801458 	cmpnei	r2,r2,81
100052d4:	10003c1e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
100052d8:	e0bffc83 	ldbu	r2,-14(fp)
100052dc:	10803fcc 	andi	r2,r2,255
100052e0:	10801458 	cmpnei	r2,r2,81
100052e4:	1000381e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
100052e8:	e0bffcc3 	ldbu	r2,-13(fp)
100052ec:	10803fcc 	andi	r2,r2,255
100052f0:	10801458 	cmpnei	r2,r2,81
100052f4:	1000341e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
100052f8:	e0bffd03 	ldbu	r2,-12(fp)
100052fc:	10803fcc 	andi	r2,r2,255
10005300:	10801498 	cmpnei	r2,r2,82
10005304:	1000301e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
10005308:	e0bffd43 	ldbu	r2,-11(fp)
1000530c:	10803fcc 	andi	r2,r2,255
10005310:	10801498 	cmpnei	r2,r2,82
10005314:	10002c1e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
10005318:	e0bffd83 	ldbu	r2,-10(fp)
1000531c:	10803fcc 	andi	r2,r2,255
10005320:	10801498 	cmpnei	r2,r2,82
10005324:	1000281e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
10005328:	e0bffdc3 	ldbu	r2,-9(fp)
1000532c:	10803fcc 	andi	r2,r2,255
10005330:	10801498 	cmpnei	r2,r2,82
10005334:	1000241e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
10005338:	e0bffe03 	ldbu	r2,-8(fp)
1000533c:	10803fcc 	andi	r2,r2,255
10005340:	10801658 	cmpnei	r2,r2,89
10005344:	1000201e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
10005348:	e0bffe43 	ldbu	r2,-7(fp)
1000534c:	10803fcc 	andi	r2,r2,255
10005350:	10801658 	cmpnei	r2,r2,89
10005354:	10001c1e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
10005358:	e0bffe83 	ldbu	r2,-6(fp)
1000535c:	10803fcc 	andi	r2,r2,255
10005360:	10801658 	cmpnei	r2,r2,89
10005364:	1000181e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
10005368:	e0bffec3 	ldbu	r2,-5(fp)
1000536c:	10803fcc 	andi	r2,r2,255
10005370:	10801658 	cmpnei	r2,r2,89
10005374:	1000141e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
                (byte_id[10] == 'Y') && 
                (byte_id[11] == 'Y'))
            {
              flash->mode_width = 1;
10005378:	e0ffff17 	ldw	r3,-4(fp)
1000537c:	00800044 	movi	r2,1
10005380:	18802e15 	stw	r2,184(r3)
              flash->device_width = 4; 
10005384:	e0ffff17 	ldw	r3,-4(fp)
10005388:	00800104 	movi	r2,4
1000538c:	18802f15 	stw	r2,188(r3)
              iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
10005390:	e0bfff17 	ldw	r2,-4(fp)
10005394:	10800a17 	ldw	r2,40(r2)
10005398:	10802804 	addi	r2,r2,160
1000539c:	10800037 	ldwio	r2,0(r2)
100053a0:	e0bffa0d 	sth	r2,-24(fp)
              iface += 1;
100053a4:	e0bffa0b 	ldhu	r2,-24(fp)
100053a8:	10800044 	addi	r2,r2,1
100053ac:	e0bffa0d 	sth	r2,-24(fp)
              if (!(iface & 0x4))
100053b0:	e0bffa0b 	ldhu	r2,-24(fp)
100053b4:	1080010c 	andi	r2,r2,4
100053b8:	1004c03a 	cmpne	r2,r2,zero
100053bc:	1000021e 	bne	r2,zero,100053c8 <alt_read_cfi_width+0x794>
              {
                ret_code = -ENODEV;
100053c0:	00bffb44 	movi	r2,-19
100053c4:	e0bff915 	stw	r2,-28(fp)
        }
      }
    }
  }
  
  return ret_code;
100053c8:	e0bff917 	ldw	r2,-28(fp)
}
100053cc:	e037883a 	mov	sp,fp
100053d0:	dfc00117 	ldw	ra,4(sp)
100053d4:	df000017 	ldw	fp,0(sp)
100053d8:	dec00204 	addi	sp,sp,8
100053dc:	f800283a 	ret

100053e0 <alt_check_primary_table>:
 * 
 * Check that the primary Vendor table starts with the 
 * correct pattern
 */
int alt_check_primary_table(alt_flash_cfi_dev* flash)
{
100053e0:	defff904 	addi	sp,sp,-28
100053e4:	dfc00615 	stw	ra,24(sp)
100053e8:	df000515 	stw	fp,20(sp)
100053ec:	dc000415 	stw	r16,16(sp)
100053f0:	df000404 	addi	fp,sp,16
100053f4:	e13fff15 	stw	r4,-4(fp)
  int i;
  int ret_code = 0;
100053f8:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
100053fc:	e13fff17 	ldw	r4,-4(fp)
10005400:	01400544 	movi	r5,21
10005404:	00045d80 	call	100045d8 <alt_read_16bit_query_entry>
10005408:	10ffffcc 	andi	r3,r2,65535
1000540c:	e0bfff17 	ldw	r2,-4(fp)
10005410:	10c03215 	stw	r3,200(r2)
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
10005414:	e03ffd15 	stw	zero,-12(fp)
10005418:	00001006 	br	1000545c <alt_check_primary_table+0x7c>
  {
    primary_query_string[i] = 
1000541c:	e43ffd17 	ldw	r16,-12(fp)
10005420:	e0bfff17 	ldw	r2,-4(fp)
10005424:	11803417 	ldw	r6,208(r2)
10005428:	e0bfff17 	ldw	r2,-4(fp)
1000542c:	10c03217 	ldw	r3,200(r2)
10005430:	e0bffd17 	ldw	r2,-12(fp)
10005434:	188b883a 	add	r5,r3,r2
10005438:	e13fff17 	ldw	r4,-4(fp)
1000543c:	303ee83a 	callr	r6
10005440:	1007883a 	mov	r3,r2
10005444:	e0bffe04 	addi	r2,fp,-8
10005448:	1405883a 	add	r2,r2,r16
1000544c:	10c00005 	stb	r3,0(r2)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
10005450:	e0bffd17 	ldw	r2,-12(fp)
10005454:	10800044 	addi	r2,r2,1
10005458:	e0bffd15 	stw	r2,-12(fp)
1000545c:	e0bffd17 	ldw	r2,-12(fp)
10005460:	108000d0 	cmplti	r2,r2,3
10005464:	103fed1e 	bne	r2,zero,1000541c <alt_check_primary_table+0x3c>
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
10005468:	e0bffe03 	ldbu	r2,-8(fp)
1000546c:	10803fcc 	andi	r2,r2,255
10005470:	10801418 	cmpnei	r2,r2,80
10005474:	1000081e 	bne	r2,zero,10005498 <alt_check_primary_table+0xb8>
10005478:	e0bffe43 	ldbu	r2,-7(fp)
1000547c:	10803fcc 	andi	r2,r2,255
10005480:	10801498 	cmpnei	r2,r2,82
10005484:	1000041e 	bne	r2,zero,10005498 <alt_check_primary_table+0xb8>
10005488:	e0bffe83 	ldbu	r2,-6(fp)
1000548c:	10803fcc 	andi	r2,r2,255
10005490:	10801260 	cmpeqi	r2,r2,73
10005494:	1000021e 	bne	r2,zero,100054a0 <alt_check_primary_table+0xc0>
      (primary_query_string[1] != 'R') ||
      (primary_query_string[2] != 'I'))
  {
    ret_code = -ENODEV;
10005498:	00bffb44 	movi	r2,-19
1000549c:	e0bffc15 	stw	r2,-16(fp)
  }
  
  return ret_code;
100054a0:	e0bffc17 	ldw	r2,-16(fp)
}
100054a4:	e037883a 	mov	sp,fp
100054a8:	dfc00217 	ldw	ra,8(sp)
100054ac:	df000117 	ldw	fp,4(sp)
100054b0:	dc000017 	ldw	r16,0(sp)
100054b4:	dec00304 	addi	sp,sp,12
100054b8:	f800283a 	ret

100054bc <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
100054bc:	defffa04 	addi	sp,sp,-24
100054c0:	dfc00515 	stw	ra,20(sp)
100054c4:	df000415 	stw	fp,16(sp)
100054c8:	df000404 	addi	fp,sp,16
100054cc:	e13ffd15 	stw	r4,-12(fp)
100054d0:	e17ffe15 	stw	r5,-8(fp)
100054d4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
100054d8:	e0bffd17 	ldw	r2,-12(fp)
100054dc:	10800017 	ldw	r2,0(r2)
100054e0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
100054e4:	e0bffc17 	ldw	r2,-16(fp)
100054e8:	11000a04 	addi	r4,r2,40
100054ec:	e0bffd17 	ldw	r2,-12(fp)
100054f0:	11c00217 	ldw	r7,8(r2)
100054f4:	e17ffe17 	ldw	r5,-8(fp)
100054f8:	e1bfff17 	ldw	r6,-4(fp)
100054fc:	0005b040 	call	10005b04 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
10005500:	e037883a 	mov	sp,fp
10005504:	dfc00117 	ldw	ra,4(sp)
10005508:	df000017 	ldw	fp,0(sp)
1000550c:	dec00204 	addi	sp,sp,8
10005510:	f800283a 	ret

10005514 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
10005514:	defffa04 	addi	sp,sp,-24
10005518:	dfc00515 	stw	ra,20(sp)
1000551c:	df000415 	stw	fp,16(sp)
10005520:	df000404 	addi	fp,sp,16
10005524:	e13ffd15 	stw	r4,-12(fp)
10005528:	e17ffe15 	stw	r5,-8(fp)
1000552c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
10005530:	e0bffd17 	ldw	r2,-12(fp)
10005534:	10800017 	ldw	r2,0(r2)
10005538:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
1000553c:	e0bffc17 	ldw	r2,-16(fp)
10005540:	11000a04 	addi	r4,r2,40
10005544:	e0bffd17 	ldw	r2,-12(fp)
10005548:	11c00217 	ldw	r7,8(r2)
1000554c:	e17ffe17 	ldw	r5,-8(fp)
10005550:	e1bfff17 	ldw	r6,-4(fp)
10005554:	0005d280 	call	10005d28 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
10005558:	e037883a 	mov	sp,fp
1000555c:	dfc00117 	ldw	ra,4(sp)
10005560:	df000017 	ldw	fp,0(sp)
10005564:	dec00204 	addi	sp,sp,8
10005568:	f800283a 	ret

1000556c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
1000556c:	defffc04 	addi	sp,sp,-16
10005570:	dfc00315 	stw	ra,12(sp)
10005574:	df000215 	stw	fp,8(sp)
10005578:	df000204 	addi	fp,sp,8
1000557c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
10005580:	e0bfff17 	ldw	r2,-4(fp)
10005584:	10800017 	ldw	r2,0(r2)
10005588:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
1000558c:	e0bffe17 	ldw	r2,-8(fp)
10005590:	11000a04 	addi	r4,r2,40
10005594:	e0bfff17 	ldw	r2,-4(fp)
10005598:	11400217 	ldw	r5,8(r2)
1000559c:	000599c0 	call	1000599c <altera_avalon_jtag_uart_close>
}
100055a0:	e037883a 	mov	sp,fp
100055a4:	dfc00117 	ldw	ra,4(sp)
100055a8:	df000017 	ldw	fp,0(sp)
100055ac:	dec00204 	addi	sp,sp,8
100055b0:	f800283a 	ret

100055b4 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
100055b4:	defffa04 	addi	sp,sp,-24
100055b8:	dfc00515 	stw	ra,20(sp)
100055bc:	df000415 	stw	fp,16(sp)
100055c0:	df000404 	addi	fp,sp,16
100055c4:	e13ffd15 	stw	r4,-12(fp)
100055c8:	e17ffe15 	stw	r5,-8(fp)
100055cc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
100055d0:	e0bffd17 	ldw	r2,-12(fp)
100055d4:	10800017 	ldw	r2,0(r2)
100055d8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
100055dc:	e0bffc17 	ldw	r2,-16(fp)
100055e0:	11000a04 	addi	r4,r2,40
100055e4:	e17ffe17 	ldw	r5,-8(fp)
100055e8:	e1bfff17 	ldw	r6,-4(fp)
100055ec:	0005a100 	call	10005a10 <altera_avalon_jtag_uart_ioctl>
}
100055f0:	e037883a 	mov	sp,fp
100055f4:	dfc00117 	ldw	ra,4(sp)
100055f8:	df000017 	ldw	fp,0(sp)
100055fc:	dec00204 	addi	sp,sp,8
10005600:	f800283a 	ret

10005604 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
10005604:	defffa04 	addi	sp,sp,-24
10005608:	dfc00515 	stw	ra,20(sp)
1000560c:	df000415 	stw	fp,16(sp)
10005610:	df000404 	addi	fp,sp,16
10005614:	e13ffd15 	stw	r4,-12(fp)
10005618:	e17ffe15 	stw	r5,-8(fp)
1000561c:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
10005620:	e0fffd17 	ldw	r3,-12(fp)
10005624:	00800044 	movi	r2,1
10005628:	18800815 	stw	r2,32(r3)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
1000562c:	e0bffd17 	ldw	r2,-12(fp)
10005630:	10800017 	ldw	r2,0(r2)
10005634:	11000104 	addi	r4,r2,4
10005638:	e0bffd17 	ldw	r2,-12(fp)
1000563c:	10800817 	ldw	r2,32(r2)
10005640:	1007883a 	mov	r3,r2
10005644:	2005883a 	mov	r2,r4
10005648:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
1000564c:	e13ffe17 	ldw	r4,-8(fp)
10005650:	e17fff17 	ldw	r5,-4(fp)
10005654:	d8000015 	stw	zero,0(sp)
10005658:	01840034 	movhi	r6,4096
1000565c:	3195b104 	addi	r6,r6,22212
10005660:	e1fffd17 	ldw	r7,-12(fp)
10005664:	00073580 	call	10007358 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
10005668:	e0bffd17 	ldw	r2,-12(fp)
1000566c:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
10005670:	e0bffd17 	ldw	r2,-12(fp)
10005674:	11000204 	addi	r4,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
10005678:	00840074 	movhi	r2,4097
1000567c:	10aa2804 	addi	r2,r2,-22368
10005680:	10800017 	ldw	r2,0(r2)
10005684:	100b883a 	mov	r5,r2
10005688:	01840034 	movhi	r6,4096
1000568c:	31963b04 	addi	r6,r6,22764
10005690:	e1fffd17 	ldw	r7,-12(fp)
10005694:	0006e4c0 	call	10006e4c <alt_alarm_start>
10005698:	1004403a 	cmpge	r2,r2,zero
1000569c:	1000041e 	bne	r2,zero,100056b0 <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
100056a0:	e0fffd17 	ldw	r3,-12(fp)
100056a4:	00a00034 	movhi	r2,32768
100056a8:	10bfffc4 	addi	r2,r2,-1
100056ac:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
100056b0:	e037883a 	mov	sp,fp
100056b4:	dfc00117 	ldw	ra,4(sp)
100056b8:	df000017 	ldw	fp,0(sp)
100056bc:	dec00204 	addi	sp,sp,8
100056c0:	f800283a 	ret

100056c4 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
100056c4:	defff804 	addi	sp,sp,-32
100056c8:	df000715 	stw	fp,28(sp)
100056cc:	df000704 	addi	fp,sp,28
100056d0:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
100056d4:	e0bfff17 	ldw	r2,-4(fp)
100056d8:	e0bffe15 	stw	r2,-8(fp)
  unsigned int base = sp->base;
100056dc:	e0bffe17 	ldw	r2,-8(fp)
100056e0:	10800017 	ldw	r2,0(r2)
100056e4:	e0bffd15 	stw	r2,-12(fp)
100056e8:	00000006 	br	100056ec <altera_avalon_jtag_uart_irq+0x28>
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
100056ec:	e0bffd17 	ldw	r2,-12(fp)
100056f0:	10800104 	addi	r2,r2,4
100056f4:	10800037 	ldwio	r2,0(r2)
100056f8:	e0bffc15 	stw	r2,-16(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
100056fc:	e0bffc17 	ldw	r2,-16(fp)
10005700:	1080c00c 	andi	r2,r2,768
10005704:	1005003a 	cmpeq	r2,r2,zero
10005708:	1000741e 	bne	r2,zero,100058dc <altera_avalon_jtag_uart_irq+0x218>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
1000570c:	e0bffc17 	ldw	r2,-16(fp)
10005710:	1080400c 	andi	r2,r2,256
10005714:	1005003a 	cmpeq	r2,r2,zero
10005718:	1000351e 	bne	r2,zero,100057f0 <altera_avalon_jtag_uart_irq+0x12c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
1000571c:	00800074 	movhi	r2,1
10005720:	e0bffb15 	stw	r2,-20(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
10005724:	e0bffe17 	ldw	r2,-8(fp)
10005728:	10800a17 	ldw	r2,40(r2)
1000572c:	10800044 	addi	r2,r2,1
10005730:	1081ffcc 	andi	r2,r2,2047
10005734:	e0bffa15 	stw	r2,-24(fp)
        if (next == sp->rx_out)
10005738:	e0bffe17 	ldw	r2,-8(fp)
1000573c:	10c00b17 	ldw	r3,44(r2)
10005740:	e0bffa17 	ldw	r2,-24(fp)
10005744:	18801626 	beq	r3,r2,100057a0 <altera_avalon_jtag_uart_irq+0xdc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
10005748:	e0bffd17 	ldw	r2,-12(fp)
1000574c:	10800037 	ldwio	r2,0(r2)
10005750:	e0bffb15 	stw	r2,-20(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
10005754:	e0bffb17 	ldw	r2,-20(fp)
10005758:	10a0000c 	andi	r2,r2,32768
1000575c:	1005003a 	cmpeq	r2,r2,zero
10005760:	10000f1e 	bne	r2,zero,100057a0 <altera_avalon_jtag_uart_irq+0xdc>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
10005764:	e0bffe17 	ldw	r2,-8(fp)
10005768:	10c00a17 	ldw	r3,40(r2)
1000576c:	e0bffb17 	ldw	r2,-20(fp)
10005770:	1009883a 	mov	r4,r2
10005774:	e0bffe17 	ldw	r2,-8(fp)
10005778:	1885883a 	add	r2,r3,r2
1000577c:	10800e04 	addi	r2,r2,56
10005780:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
10005784:	e0bffe17 	ldw	r2,-8(fp)
10005788:	10800a17 	ldw	r2,40(r2)
1000578c:	10800044 	addi	r2,r2,1
10005790:	10c1ffcc 	andi	r3,r2,2047
10005794:	e0bffe17 	ldw	r2,-8(fp)
10005798:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
1000579c:	003fe106 	br	10005724 <altera_avalon_jtag_uart_irq+0x60>

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
100057a0:	e0bffb17 	ldw	r2,-20(fp)
100057a4:	10bfffec 	andhi	r2,r2,65535
100057a8:	1005003a 	cmpeq	r2,r2,zero
100057ac:	1000101e 	bne	r2,zero,100057f0 <altera_avalon_jtag_uart_irq+0x12c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
100057b0:	e0bffe17 	ldw	r2,-8(fp)
100057b4:	10c00817 	ldw	r3,32(r2)
100057b8:	00bfff84 	movi	r2,-2
100057bc:	1886703a 	and	r3,r3,r2
100057c0:	e0bffe17 	ldw	r2,-8(fp)
100057c4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
100057c8:	e0bffd17 	ldw	r2,-12(fp)
100057cc:	11000104 	addi	r4,r2,4
100057d0:	e0bffe17 	ldw	r2,-8(fp)
100057d4:	10800817 	ldw	r2,32(r2)
100057d8:	1007883a 	mov	r3,r2
100057dc:	2005883a 	mov	r2,r4
100057e0:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
100057e4:	e0bffd17 	ldw	r2,-12(fp)
100057e8:	10800104 	addi	r2,r2,4
100057ec:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
100057f0:	e0bffc17 	ldw	r2,-16(fp)
100057f4:	1080800c 	andi	r2,r2,512
100057f8:	1005003a 	cmpeq	r2,r2,zero
100057fc:	103fbb1e 	bne	r2,zero,100056ec <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
10005800:	e0bffc17 	ldw	r2,-16(fp)
10005804:	10bfffec 	andhi	r2,r2,65535
10005808:	1004d43a 	srli	r2,r2,16
1000580c:	e0bff915 	stw	r2,-28(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
10005810:	00001506 	br	10005868 <altera_avalon_jtag_uart_irq+0x1a4>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
10005814:	e13ffd17 	ldw	r4,-12(fp)
10005818:	e0bffe17 	ldw	r2,-8(fp)
1000581c:	10c00d17 	ldw	r3,52(r2)
10005820:	e0bffe17 	ldw	r2,-8(fp)
10005824:	1885883a 	add	r2,r3,r2
10005828:	10820e04 	addi	r2,r2,2104
1000582c:	10800003 	ldbu	r2,0(r2)
10005830:	10c03fcc 	andi	r3,r2,255
10005834:	18c0201c 	xori	r3,r3,128
10005838:	18ffe004 	addi	r3,r3,-128
1000583c:	2005883a 	mov	r2,r4
10005840:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
10005844:	e0bffe17 	ldw	r2,-8(fp)
10005848:	10800d17 	ldw	r2,52(r2)
1000584c:	10800044 	addi	r2,r2,1
10005850:	10c1ffcc 	andi	r3,r2,2047
10005854:	e0bffe17 	ldw	r2,-8(fp)
10005858:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
1000585c:	e0bff917 	ldw	r2,-28(fp)
10005860:	10bfffc4 	addi	r2,r2,-1
10005864:	e0bff915 	stw	r2,-28(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
10005868:	e0bff917 	ldw	r2,-28(fp)
1000586c:	1005003a 	cmpeq	r2,r2,zero
10005870:	1000051e 	bne	r2,zero,10005888 <altera_avalon_jtag_uart_irq+0x1c4>
10005874:	e0bffe17 	ldw	r2,-8(fp)
10005878:	10c00d17 	ldw	r3,52(r2)
1000587c:	e0bffe17 	ldw	r2,-8(fp)
10005880:	10800c17 	ldw	r2,48(r2)
10005884:	18bfe31e 	bne	r3,r2,10005814 <altera_avalon_jtag_uart_irq+0x150>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
10005888:	e0bff917 	ldw	r2,-28(fp)
1000588c:	1005003a 	cmpeq	r2,r2,zero
10005890:	103f961e 	bne	r2,zero,100056ec <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
10005894:	e0bffe17 	ldw	r2,-8(fp)
10005898:	10c00817 	ldw	r3,32(r2)
1000589c:	00bfff44 	movi	r2,-3
100058a0:	1886703a 	and	r3,r3,r2
100058a4:	e0bffe17 	ldw	r2,-8(fp)
100058a8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
100058ac:	e0bffe17 	ldw	r2,-8(fp)
100058b0:	10800017 	ldw	r2,0(r2)
100058b4:	11000104 	addi	r4,r2,4
100058b8:	e0bffe17 	ldw	r2,-8(fp)
100058bc:	10800817 	ldw	r2,32(r2)
100058c0:	1007883a 	mov	r3,r2
100058c4:	2005883a 	mov	r2,r4
100058c8:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
100058cc:	e0bffd17 	ldw	r2,-12(fp)
100058d0:	10800104 	addi	r2,r2,4
100058d4:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
100058d8:	003f8406 	br	100056ec <altera_avalon_jtag_uart_irq+0x28>
}
100058dc:	e037883a 	mov	sp,fp
100058e0:	df000017 	ldw	fp,0(sp)
100058e4:	dec00104 	addi	sp,sp,4
100058e8:	f800283a 	ret

100058ec <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
100058ec:	defffc04 	addi	sp,sp,-16
100058f0:	df000315 	stw	fp,12(sp)
100058f4:	df000304 	addi	fp,sp,12
100058f8:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
100058fc:	e0bfff17 	ldw	r2,-4(fp)
10005900:	e0bffe15 	stw	r2,-8(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
10005904:	e0bffe17 	ldw	r2,-8(fp)
10005908:	10800017 	ldw	r2,0(r2)
1000590c:	10800104 	addi	r2,r2,4
10005910:	10800037 	ldwio	r2,0(r2)
10005914:	e0bffd15 	stw	r2,-12(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
10005918:	e0bffd17 	ldw	r2,-12(fp)
1000591c:	1081000c 	andi	r2,r2,1024
10005920:	1005003a 	cmpeq	r2,r2,zero
10005924:	10000c1e 	bne	r2,zero,10005958 <altera_avalon_jtag_uart_timeout+0x6c>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
10005928:	e0bffe17 	ldw	r2,-8(fp)
1000592c:	10800017 	ldw	r2,0(r2)
10005930:	11000104 	addi	r4,r2,4
10005934:	e0bffe17 	ldw	r2,-8(fp)
10005938:	10800817 	ldw	r2,32(r2)
1000593c:	10810014 	ori	r2,r2,1024
10005940:	1007883a 	mov	r3,r2
10005944:	2005883a 	mov	r2,r4
10005948:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
1000594c:	e0bffe17 	ldw	r2,-8(fp)
10005950:	10000915 	stw	zero,36(r2)
10005954:	00000a06 	br	10005980 <altera_avalon_jtag_uart_timeout+0x94>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
10005958:	e0bffe17 	ldw	r2,-8(fp)
1000595c:	10c00917 	ldw	r3,36(r2)
10005960:	00a00034 	movhi	r2,32768
10005964:	10bfff04 	addi	r2,r2,-4
10005968:	10c00536 	bltu	r2,r3,10005980 <altera_avalon_jtag_uart_timeout+0x94>
    sp->host_inactive++;
1000596c:	e0bffe17 	ldw	r2,-8(fp)
10005970:	10800917 	ldw	r2,36(r2)
10005974:	10c00044 	addi	r3,r2,1
10005978:	e0bffe17 	ldw	r2,-8(fp)
1000597c:	10c00915 	stw	r3,36(r2)
10005980:	00840074 	movhi	r2,4097
10005984:	10aa2804 	addi	r2,r2,-22368
10005988:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
1000598c:	e037883a 	mov	sp,fp
10005990:	df000017 	ldw	fp,0(sp)
10005994:	dec00104 	addi	sp,sp,4
10005998:	f800283a 	ret

1000599c <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
1000599c:	defffc04 	addi	sp,sp,-16
100059a0:	df000315 	stw	fp,12(sp)
100059a4:	df000304 	addi	fp,sp,12
100059a8:	e13ffd15 	stw	r4,-12(fp)
100059ac:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
100059b0:	00000706 	br	100059d0 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
100059b4:	e0bffe17 	ldw	r2,-8(fp)
100059b8:	1090000c 	andi	r2,r2,16384
100059bc:	1005003a 	cmpeq	r2,r2,zero
100059c0:	1000031e 	bne	r2,zero,100059d0 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
100059c4:	00bffd44 	movi	r2,-11
100059c8:	e0bfff15 	stw	r2,-4(fp)
100059cc:	00000b06 	br	100059fc <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
100059d0:	e0bffd17 	ldw	r2,-12(fp)
100059d4:	10c00d17 	ldw	r3,52(r2)
100059d8:	e0bffd17 	ldw	r2,-12(fp)
100059dc:	10800c17 	ldw	r2,48(r2)
100059e0:	18800526 	beq	r3,r2,100059f8 <altera_avalon_jtag_uart_close+0x5c>
100059e4:	e0bffd17 	ldw	r2,-12(fp)
100059e8:	10c00917 	ldw	r3,36(r2)
100059ec:	e0bffd17 	ldw	r2,-12(fp)
100059f0:	10800117 	ldw	r2,4(r2)
100059f4:	18bfef36 	bltu	r3,r2,100059b4 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
100059f8:	e03fff15 	stw	zero,-4(fp)
100059fc:	e0bfff17 	ldw	r2,-4(fp)
}
10005a00:	e037883a 	mov	sp,fp
10005a04:	df000017 	ldw	fp,0(sp)
10005a08:	dec00104 	addi	sp,sp,4
10005a0c:	f800283a 	ret

10005a10 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
10005a10:	defff804 	addi	sp,sp,-32
10005a14:	df000715 	stw	fp,28(sp)
10005a18:	df000704 	addi	fp,sp,28
10005a1c:	e13ffb15 	stw	r4,-20(fp)
10005a20:	e17ffc15 	stw	r5,-16(fp)
10005a24:	e1bffd15 	stw	r6,-12(fp)
  int rc = -ENOTTY;
10005a28:	00bff9c4 	movi	r2,-25
10005a2c:	e0bffa15 	stw	r2,-24(fp)

  switch (req)
10005a30:	e0bffc17 	ldw	r2,-16(fp)
10005a34:	e0bfff15 	stw	r2,-4(fp)
10005a38:	e0ffff17 	ldw	r3,-4(fp)
10005a3c:	189a8060 	cmpeqi	r2,r3,27137
10005a40:	1000041e 	bne	r2,zero,10005a54 <altera_avalon_jtag_uart_ioctl+0x44>
10005a44:	e0ffff17 	ldw	r3,-4(fp)
10005a48:	189a80a0 	cmpeqi	r2,r3,27138
10005a4c:	10001b1e 	bne	r2,zero,10005abc <altera_avalon_jtag_uart_ioctl+0xac>
10005a50:	00002706 	br	10005af0 <altera_avalon_jtag_uart_ioctl+0xe0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
10005a54:	e0bffb17 	ldw	r2,-20(fp)
10005a58:	10c00117 	ldw	r3,4(r2)
10005a5c:	00a00034 	movhi	r2,32768
10005a60:	10bfffc4 	addi	r2,r2,-1
10005a64:	18802226 	beq	r3,r2,10005af0 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
10005a68:	e0bffd17 	ldw	r2,-12(fp)
10005a6c:	10800017 	ldw	r2,0(r2)
10005a70:	e0bff915 	stw	r2,-28(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
10005a74:	e0bff917 	ldw	r2,-28(fp)
10005a78:	10800090 	cmplti	r2,r2,2
10005a7c:	1000071e 	bne	r2,zero,10005a9c <altera_avalon_jtag_uart_ioctl+0x8c>
10005a80:	e0fff917 	ldw	r3,-28(fp)
10005a84:	00a00034 	movhi	r2,32768
10005a88:	10bfffc4 	addi	r2,r2,-1
10005a8c:	18800326 	beq	r3,r2,10005a9c <altera_avalon_jtag_uart_ioctl+0x8c>
10005a90:	e0bff917 	ldw	r2,-28(fp)
10005a94:	e0bffe15 	stw	r2,-8(fp)
10005a98:	00000306 	br	10005aa8 <altera_avalon_jtag_uart_ioctl+0x98>
10005a9c:	00e00034 	movhi	r3,32768
10005aa0:	18ffff84 	addi	r3,r3,-2
10005aa4:	e0fffe15 	stw	r3,-8(fp)
10005aa8:	e0bffb17 	ldw	r2,-20(fp)
10005aac:	e0fffe17 	ldw	r3,-8(fp)
10005ab0:	10c00115 	stw	r3,4(r2)
      rc = 0;
10005ab4:	e03ffa15 	stw	zero,-24(fp)
    }
    break;
10005ab8:	00000d06 	br	10005af0 <altera_avalon_jtag_uart_ioctl+0xe0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
10005abc:	e0bffb17 	ldw	r2,-20(fp)
10005ac0:	10c00117 	ldw	r3,4(r2)
10005ac4:	00a00034 	movhi	r2,32768
10005ac8:	10bfffc4 	addi	r2,r2,-1
10005acc:	18800826 	beq	r3,r2,10005af0 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
10005ad0:	e13ffd17 	ldw	r4,-12(fp)
10005ad4:	e0bffb17 	ldw	r2,-20(fp)
10005ad8:	10c00917 	ldw	r3,36(r2)
10005adc:	e0bffb17 	ldw	r2,-20(fp)
10005ae0:	10800117 	ldw	r2,4(r2)
10005ae4:	1885803a 	cmpltu	r2,r3,r2
10005ae8:	20800015 	stw	r2,0(r4)
      rc = 0;
10005aec:	e03ffa15 	stw	zero,-24(fp)

  default:
    break;
  }

  return rc;
10005af0:	e0bffa17 	ldw	r2,-24(fp)
}
10005af4:	e037883a 	mov	sp,fp
10005af8:	df000017 	ldw	fp,0(sp)
10005afc:	dec00104 	addi	sp,sp,4
10005b00:	f800283a 	ret

10005b04 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
10005b04:	defff204 	addi	sp,sp,-56
10005b08:	dfc00d15 	stw	ra,52(sp)
10005b0c:	df000c15 	stw	fp,48(sp)
10005b10:	df000c04 	addi	fp,sp,48
10005b14:	e13ffb15 	stw	r4,-20(fp)
10005b18:	e17ffc15 	stw	r5,-16(fp)
10005b1c:	e1bffd15 	stw	r6,-12(fp)
10005b20:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
10005b24:	e0bffc17 	ldw	r2,-16(fp)
10005b28:	e0bffa15 	stw	r2,-24(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
10005b2c:	00004806 	br	10005c50 <altera_avalon_jtag_uart_read+0x14c>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
10005b30:	e0bffb17 	ldw	r2,-20(fp)
10005b34:	10800a17 	ldw	r2,40(r2)
10005b38:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
10005b3c:	e0bffb17 	ldw	r2,-20(fp)
10005b40:	10800b17 	ldw	r2,44(r2)
10005b44:	e0bff615 	stw	r2,-40(fp)

      if (in >= out)
10005b48:	e0fff717 	ldw	r3,-36(fp)
10005b4c:	e0bff617 	ldw	r2,-40(fp)
10005b50:	18800536 	bltu	r3,r2,10005b68 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
10005b54:	e0bff717 	ldw	r2,-36(fp)
10005b58:	e0fff617 	ldw	r3,-40(fp)
10005b5c:	10c5c83a 	sub	r2,r2,r3
10005b60:	e0bff815 	stw	r2,-32(fp)
10005b64:	00000406 	br	10005b78 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
10005b68:	00820004 	movi	r2,2048
10005b6c:	e0fff617 	ldw	r3,-40(fp)
10005b70:	10c5c83a 	sub	r2,r2,r3
10005b74:	e0bff815 	stw	r2,-32(fp)

      if (n == 0)
10005b78:	e0bff817 	ldw	r2,-32(fp)
10005b7c:	1005003a 	cmpeq	r2,r2,zero
10005b80:	10001f1e 	bne	r2,zero,10005c00 <altera_avalon_jtag_uart_read+0xfc>
        break; /* No more data available */

      if (n > space)
10005b84:	e0fffd17 	ldw	r3,-12(fp)
10005b88:	e0bff817 	ldw	r2,-32(fp)
10005b8c:	1880022e 	bgeu	r3,r2,10005b98 <altera_avalon_jtag_uart_read+0x94>
        n = space;
10005b90:	e0bffd17 	ldw	r2,-12(fp)
10005b94:	e0bff815 	stw	r2,-32(fp)

      memcpy(ptr, sp->rx_buf + out, n);
10005b98:	e0bffb17 	ldw	r2,-20(fp)
10005b9c:	10c00e04 	addi	r3,r2,56
10005ba0:	e0bff617 	ldw	r2,-40(fp)
10005ba4:	1887883a 	add	r3,r3,r2
10005ba8:	e0bffa17 	ldw	r2,-24(fp)
10005bac:	1009883a 	mov	r4,r2
10005bb0:	180b883a 	mov	r5,r3
10005bb4:	e1bff817 	ldw	r6,-32(fp)
10005bb8:	00011180 	call	10001118 <memcpy>
      ptr   += n;
10005bbc:	e0fff817 	ldw	r3,-32(fp)
10005bc0:	e0bffa17 	ldw	r2,-24(fp)
10005bc4:	10c5883a 	add	r2,r2,r3
10005bc8:	e0bffa15 	stw	r2,-24(fp)
      space -= n;
10005bcc:	e0fffd17 	ldw	r3,-12(fp)
10005bd0:	e0bff817 	ldw	r2,-32(fp)
10005bd4:	1885c83a 	sub	r2,r3,r2
10005bd8:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
10005bdc:	e0fff617 	ldw	r3,-40(fp)
10005be0:	e0bff817 	ldw	r2,-32(fp)
10005be4:	1885883a 	add	r2,r3,r2
10005be8:	10c1ffcc 	andi	r3,r2,2047
10005bec:	e0bffb17 	ldw	r2,-20(fp)
10005bf0:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
10005bf4:	e0bffd17 	ldw	r2,-12(fp)
10005bf8:	10800048 	cmpgei	r2,r2,1
10005bfc:	103fcc1e 	bne	r2,zero,10005b30 <altera_avalon_jtag_uart_read+0x2c>

    /* If we read any data then return it */
    if (ptr != buffer)
10005c00:	e0fffa17 	ldw	r3,-24(fp)
10005c04:	e0bffc17 	ldw	r2,-16(fp)
10005c08:	1880141e 	bne	r3,r2,10005c5c <altera_avalon_jtag_uart_read+0x158>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
10005c0c:	e0bffe17 	ldw	r2,-8(fp)
10005c10:	1090000c 	andi	r2,r2,16384
10005c14:	1004c03a 	cmpne	r2,r2,zero
10005c18:	1000101e 	bne	r2,zero,10005c5c <altera_avalon_jtag_uart_read+0x158>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
10005c1c:	e0bffb17 	ldw	r2,-20(fp)
10005c20:	10c00a17 	ldw	r3,40(r2)
10005c24:	e0bff717 	ldw	r2,-36(fp)
10005c28:	1880051e 	bne	r3,r2,10005c40 <altera_avalon_jtag_uart_read+0x13c>
10005c2c:	e0bffb17 	ldw	r2,-20(fp)
10005c30:	10c00917 	ldw	r3,36(r2)
10005c34:	e0bffb17 	ldw	r2,-20(fp)
10005c38:	10800117 	ldw	r2,4(r2)
10005c3c:	18bff736 	bltu	r3,r2,10005c1c <altera_avalon_jtag_uart_read+0x118>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
10005c40:	e0bffb17 	ldw	r2,-20(fp)
10005c44:	10c00a17 	ldw	r3,40(r2)
10005c48:	e0bff717 	ldw	r2,-36(fp)
10005c4c:	18800326 	beq	r3,r2,10005c5c <altera_avalon_jtag_uart_read+0x158>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
10005c50:	e0bffd17 	ldw	r2,-12(fp)
10005c54:	10800048 	cmpgei	r2,r2,1
10005c58:	103fb51e 	bne	r2,zero,10005b30 <altera_avalon_jtag_uart_read+0x2c>
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
10005c5c:	e0fffa17 	ldw	r3,-24(fp)
10005c60:	e0bffc17 	ldw	r2,-16(fp)
10005c64:	18801926 	beq	r3,r2,10005ccc <altera_avalon_jtag_uart_read+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10005c68:	0005303a 	rdctl	r2,status
10005c6c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10005c70:	e0fff517 	ldw	r3,-44(fp)
10005c74:	00bfff84 	movi	r2,-2
10005c78:	1884703a 	and	r2,r3,r2
10005c7c:	1001703a 	wrctl	status,r2
  
  return context;
10005c80:	e0bff517 	ldw	r2,-44(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
10005c84:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
10005c88:	e0bffb17 	ldw	r2,-20(fp)
10005c8c:	10800817 	ldw	r2,32(r2)
10005c90:	10c00054 	ori	r3,r2,1
10005c94:	e0bffb17 	ldw	r2,-20(fp)
10005c98:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
10005c9c:	e0bffb17 	ldw	r2,-20(fp)
10005ca0:	10800017 	ldw	r2,0(r2)
10005ca4:	11000104 	addi	r4,r2,4
10005ca8:	e0bffb17 	ldw	r2,-20(fp)
10005cac:	10800817 	ldw	r2,32(r2)
10005cb0:	1007883a 	mov	r3,r2
10005cb4:	2005883a 	mov	r2,r4
10005cb8:	10c00035 	stwio	r3,0(r2)
10005cbc:	e0bff917 	ldw	r2,-28(fp)
10005cc0:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10005cc4:	e0bff417 	ldw	r2,-48(fp)
10005cc8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
10005ccc:	e0fffa17 	ldw	r3,-24(fp)
10005cd0:	e0bffc17 	ldw	r2,-16(fp)
10005cd4:	18800526 	beq	r3,r2,10005cec <altera_avalon_jtag_uart_read+0x1e8>
    return ptr - buffer;
10005cd8:	e0fffa17 	ldw	r3,-24(fp)
10005cdc:	e0bffc17 	ldw	r2,-16(fp)
10005ce0:	1887c83a 	sub	r3,r3,r2
10005ce4:	e0ffff15 	stw	r3,-4(fp)
10005ce8:	00000906 	br	10005d10 <altera_avalon_jtag_uart_read+0x20c>
  else if (flags & O_NONBLOCK)
10005cec:	e0bffe17 	ldw	r2,-8(fp)
10005cf0:	1090000c 	andi	r2,r2,16384
10005cf4:	1005003a 	cmpeq	r2,r2,zero
10005cf8:	1000031e 	bne	r2,zero,10005d08 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
10005cfc:	00bffd44 	movi	r2,-11
10005d00:	e0bfff15 	stw	r2,-4(fp)
10005d04:	00000206 	br	10005d10 <altera_avalon_jtag_uart_read+0x20c>
  else
    return -EIO;
10005d08:	00bffec4 	movi	r2,-5
10005d0c:	e0bfff15 	stw	r2,-4(fp)
10005d10:	e0bfff17 	ldw	r2,-4(fp)
}
10005d14:	e037883a 	mov	sp,fp
10005d18:	dfc00117 	ldw	ra,4(sp)
10005d1c:	df000017 	ldw	fp,0(sp)
10005d20:	dec00204 	addi	sp,sp,8
10005d24:	f800283a 	ret

10005d28 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
10005d28:	defff204 	addi	sp,sp,-56
10005d2c:	dfc00d15 	stw	ra,52(sp)
10005d30:	df000c15 	stw	fp,48(sp)
10005d34:	df000c04 	addi	fp,sp,48
10005d38:	e13ffb15 	stw	r4,-20(fp)
10005d3c:	e17ffc15 	stw	r5,-16(fp)
10005d40:	e1bffd15 	stw	r6,-12(fp)
10005d44:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
10005d48:	e03ff915 	stw	zero,-28(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
10005d4c:	e0bffc17 	ldw	r2,-16(fp)
10005d50:	e0bff615 	stw	r2,-40(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
10005d54:	00003a06 	br	10005e40 <altera_avalon_jtag_uart_write+0x118>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
10005d58:	e0bffb17 	ldw	r2,-20(fp)
10005d5c:	10800c17 	ldw	r2,48(r2)
10005d60:	e0bffa15 	stw	r2,-24(fp)
      out = sp->tx_out;
10005d64:	e0bffb17 	ldw	r2,-20(fp)
10005d68:	10800d17 	ldw	r2,52(r2)
10005d6c:	e0bff915 	stw	r2,-28(fp)

      if (in < out)
10005d70:	e0fffa17 	ldw	r3,-24(fp)
10005d74:	e0bff917 	ldw	r2,-28(fp)
10005d78:	1880062e 	bgeu	r3,r2,10005d94 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
10005d7c:	e0fff917 	ldw	r3,-28(fp)
10005d80:	e0bffa17 	ldw	r2,-24(fp)
10005d84:	1885c83a 	sub	r2,r3,r2
10005d88:	10bfffc4 	addi	r2,r2,-1
10005d8c:	e0bff815 	stw	r2,-32(fp)
10005d90:	00000c06 	br	10005dc4 <altera_avalon_jtag_uart_write+0x9c>
      else if (out > 0)
10005d94:	e0bff917 	ldw	r2,-28(fp)
10005d98:	1005003a 	cmpeq	r2,r2,zero
10005d9c:	1000051e 	bne	r2,zero,10005db4 <altera_avalon_jtag_uart_write+0x8c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
10005da0:	00820004 	movi	r2,2048
10005da4:	e0fffa17 	ldw	r3,-24(fp)
10005da8:	10c5c83a 	sub	r2,r2,r3
10005dac:	e0bff815 	stw	r2,-32(fp)
10005db0:	00000406 	br	10005dc4 <altera_avalon_jtag_uart_write+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
10005db4:	0081ffc4 	movi	r2,2047
10005db8:	e0fffa17 	ldw	r3,-24(fp)
10005dbc:	10c5c83a 	sub	r2,r2,r3
10005dc0:	e0bff815 	stw	r2,-32(fp)

      if (n == 0)
10005dc4:	e0bff817 	ldw	r2,-32(fp)
10005dc8:	1005003a 	cmpeq	r2,r2,zero
10005dcc:	10001f1e 	bne	r2,zero,10005e4c <altera_avalon_jtag_uart_write+0x124>
        break;

      if (n > count)
10005dd0:	e0fffd17 	ldw	r3,-12(fp)
10005dd4:	e0bff817 	ldw	r2,-32(fp)
10005dd8:	1880022e 	bgeu	r3,r2,10005de4 <altera_avalon_jtag_uart_write+0xbc>
        n = count;
10005ddc:	e0bffd17 	ldw	r2,-12(fp)
10005de0:	e0bff815 	stw	r2,-32(fp)

      memcpy(sp->tx_buf + in, ptr, n);
10005de4:	e0bffb17 	ldw	r2,-20(fp)
10005de8:	10c20e04 	addi	r3,r2,2104
10005dec:	e0bffa17 	ldw	r2,-24(fp)
10005df0:	1885883a 	add	r2,r3,r2
10005df4:	e0fffc17 	ldw	r3,-16(fp)
10005df8:	1009883a 	mov	r4,r2
10005dfc:	180b883a 	mov	r5,r3
10005e00:	e1bff817 	ldw	r6,-32(fp)
10005e04:	00011180 	call	10001118 <memcpy>
      ptr   += n;
10005e08:	e0fff817 	ldw	r3,-32(fp)
10005e0c:	e0bffc17 	ldw	r2,-16(fp)
10005e10:	10c5883a 	add	r2,r2,r3
10005e14:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
10005e18:	e0fffd17 	ldw	r3,-12(fp)
10005e1c:	e0bff817 	ldw	r2,-32(fp)
10005e20:	1885c83a 	sub	r2,r3,r2
10005e24:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
10005e28:	e0fffa17 	ldw	r3,-24(fp)
10005e2c:	e0bff817 	ldw	r2,-32(fp)
10005e30:	1885883a 	add	r2,r3,r2
10005e34:	10c1ffcc 	andi	r3,r2,2047
10005e38:	e0bffb17 	ldw	r2,-20(fp)
10005e3c:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
10005e40:	e0bffd17 	ldw	r2,-12(fp)
10005e44:	10800048 	cmpgei	r2,r2,1
10005e48:	103fc31e 	bne	r2,zero,10005d58 <altera_avalon_jtag_uart_write+0x30>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10005e4c:	0005303a 	rdctl	r2,status
10005e50:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10005e54:	e0fff517 	ldw	r3,-44(fp)
10005e58:	00bfff84 	movi	r2,-2
10005e5c:	1884703a 	and	r2,r3,r2
10005e60:	1001703a 	wrctl	status,r2
  
  return context;
10005e64:	e0bff517 	ldw	r2,-44(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
10005e68:	e0bff715 	stw	r2,-36(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
10005e6c:	e0bffb17 	ldw	r2,-20(fp)
10005e70:	10800817 	ldw	r2,32(r2)
10005e74:	10c00094 	ori	r3,r2,2
10005e78:	e0bffb17 	ldw	r2,-20(fp)
10005e7c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
10005e80:	e0bffb17 	ldw	r2,-20(fp)
10005e84:	10800017 	ldw	r2,0(r2)
10005e88:	11000104 	addi	r4,r2,4
10005e8c:	e0bffb17 	ldw	r2,-20(fp)
10005e90:	10800817 	ldw	r2,32(r2)
10005e94:	1007883a 	mov	r3,r2
10005e98:	2005883a 	mov	r2,r4
10005e9c:	10c00035 	stwio	r3,0(r2)
10005ea0:	e0bff717 	ldw	r2,-36(fp)
10005ea4:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10005ea8:	e0bff417 	ldw	r2,-48(fp)
10005eac:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
10005eb0:	e0bffd17 	ldw	r2,-12(fp)
10005eb4:	10800050 	cmplti	r2,r2,1
10005eb8:	1000111e 	bne	r2,zero,10005f00 <altera_avalon_jtag_uart_write+0x1d8>
    {
      if (flags & O_NONBLOCK)
10005ebc:	e0bffe17 	ldw	r2,-8(fp)
10005ec0:	1090000c 	andi	r2,r2,16384
10005ec4:	1004c03a 	cmpne	r2,r2,zero
10005ec8:	1000101e 	bne	r2,zero,10005f0c <altera_avalon_jtag_uart_write+0x1e4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
10005ecc:	e0bffb17 	ldw	r2,-20(fp)
10005ed0:	10c00d17 	ldw	r3,52(r2)
10005ed4:	e0bff917 	ldw	r2,-28(fp)
10005ed8:	1880051e 	bne	r3,r2,10005ef0 <altera_avalon_jtag_uart_write+0x1c8>
10005edc:	e0bffb17 	ldw	r2,-20(fp)
10005ee0:	10c00917 	ldw	r3,36(r2)
10005ee4:	e0bffb17 	ldw	r2,-20(fp)
10005ee8:	10800117 	ldw	r2,4(r2)
10005eec:	18bff736 	bltu	r3,r2,10005ecc <altera_avalon_jtag_uart_write+0x1a4>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
10005ef0:	e0bffb17 	ldw	r2,-20(fp)
10005ef4:	10c00d17 	ldw	r3,52(r2)
10005ef8:	e0bff917 	ldw	r2,-28(fp)
10005efc:	18800326 	beq	r3,r2,10005f0c <altera_avalon_jtag_uart_write+0x1e4>
         break;
    }
  }
  while (count > 0);
10005f00:	e0bffd17 	ldw	r2,-12(fp)
10005f04:	10800048 	cmpgei	r2,r2,1
10005f08:	103fcd1e 	bne	r2,zero,10005e40 <altera_avalon_jtag_uart_write+0x118>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
10005f0c:	e0fffc17 	ldw	r3,-16(fp)
10005f10:	e0bff617 	ldw	r2,-40(fp)
10005f14:	18800526 	beq	r3,r2,10005f2c <altera_avalon_jtag_uart_write+0x204>
    return ptr - start;
10005f18:	e0fffc17 	ldw	r3,-16(fp)
10005f1c:	e0bff617 	ldw	r2,-40(fp)
10005f20:	1887c83a 	sub	r3,r3,r2
10005f24:	e0ffff15 	stw	r3,-4(fp)
10005f28:	00000906 	br	10005f50 <altera_avalon_jtag_uart_write+0x228>
  else if (flags & O_NONBLOCK)
10005f2c:	e0bffe17 	ldw	r2,-8(fp)
10005f30:	1090000c 	andi	r2,r2,16384
10005f34:	1005003a 	cmpeq	r2,r2,zero
10005f38:	1000031e 	bne	r2,zero,10005f48 <altera_avalon_jtag_uart_write+0x220>
    return -EWOULDBLOCK;
10005f3c:	00bffd44 	movi	r2,-11
10005f40:	e0bfff15 	stw	r2,-4(fp)
10005f44:	00000206 	br	10005f50 <altera_avalon_jtag_uart_write+0x228>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
10005f48:	00bffec4 	movi	r2,-5
10005f4c:	e0bfff15 	stw	r2,-4(fp)
10005f50:	e0bfff17 	ldw	r2,-4(fp)
}
10005f54:	e037883a 	mov	sp,fp
10005f58:	dfc00117 	ldw	ra,4(sp)
10005f5c:	df000017 	ldw	fp,0(sp)
10005f60:	dec00204 	addi	sp,sp,8
10005f64:	f800283a 	ret

10005f68 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
10005f68:	defffb04 	addi	sp,sp,-20
10005f6c:	df000415 	stw	fp,16(sp)
10005f70:	df000404 	addi	fp,sp,16
10005f74:	e13ffd15 	stw	r4,-12(fp)
10005f78:	e17ffe15 	stw	r5,-8(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
10005f7c:	e0bffd17 	ldw	r2,-12(fp)
10005f80:	10800317 	ldw	r2,12(r2)
10005f84:	10800037 	ldwio	r2,0(r2)
10005f88:	1080040c 	andi	r2,r2,16
10005f8c:	1005003a 	cmpeq	r2,r2,zero
10005f90:	1000031e 	bne	r2,zero,10005fa0 <alt_avalon_sgdma_do_async_transfer+0x38>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
10005f94:	00bffc04 	movi	r2,-16
10005f98:	e0bfff15 	stw	r2,-4(fp)
10005f9c:	00003c06 	br	10006090 <alt_avalon_sgdma_do_async_transfer+0x128>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
10005fa0:	e0bffd17 	ldw	r2,-12(fp)
10005fa4:	10800317 	ldw	r2,12(r2)
10005fa8:	11000404 	addi	r4,r2,16
10005fac:	e0bffd17 	ldw	r2,-12(fp)
10005fb0:	10800317 	ldw	r2,12(r2)
10005fb4:	10800404 	addi	r2,r2,16
10005fb8:	10c00037 	ldwio	r3,0(r2)
10005fbc:	00bff7c4 	movi	r2,-33
10005fc0:	1886703a 	and	r3,r3,r2
10005fc4:	2005883a 	mov	r2,r4
10005fc8:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
10005fcc:	e0bffd17 	ldw	r2,-12(fp)
10005fd0:	10800317 	ldw	r2,12(r2)
10005fd4:	1007883a 	mov	r3,r2
10005fd8:	00803fc4 	movi	r2,255
10005fdc:	18800035 	stwio	r2,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
10005fe0:	e0bffd17 	ldw	r2,-12(fp)
10005fe4:	10800317 	ldw	r2,12(r2)
10005fe8:	10800804 	addi	r2,r2,32
10005fec:	e0fffe17 	ldw	r3,-8(fp)
10005ff0:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
10005ff4:	e0bffd17 	ldw	r2,-12(fp)
10005ff8:	10800917 	ldw	r2,36(r2)
10005ffc:	1005003a 	cmpeq	r2,r2,zero
10006000:	1000111e 	bne	r2,zero,10006048 <alt_avalon_sgdma_do_async_transfer+0xe0>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
10006004:	e0bffd17 	ldw	r2,-12(fp)
10006008:	10800317 	ldw	r2,12(r2)
1000600c:	10800404 	addi	r2,r2,16
10006010:	10800037 	ldwio	r2,0(r2)
10006014:	e0bffc15 	stw	r2,-16(fp)

    control |= (dev->chain_control                          |
10006018:	e0bffd17 	ldw	r2,-12(fp)
1000601c:	10c00b17 	ldw	r3,44(r2)
10006020:	e0bffc17 	ldw	r2,-16(fp)
10006024:	1884b03a 	or	r2,r3,r2
10006028:	10801814 	ori	r2,r2,96
1000602c:	e0bffc15 	stw	r2,-16(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
10006030:	e0bffd17 	ldw	r2,-12(fp)
10006034:	10800317 	ldw	r2,12(r2)
10006038:	10800404 	addi	r2,r2,16
1000603c:	e0fffc17 	ldw	r3,-16(fp)
10006040:	10c00035 	stwio	r3,0(r2)
10006044:	00001106 	br	1000608c <alt_avalon_sgdma_do_async_transfer+0x124>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
10006048:	e0bffd17 	ldw	r2,-12(fp)
1000604c:	10800317 	ldw	r2,12(r2)
10006050:	10800404 	addi	r2,r2,16
10006054:	10800037 	ldwio	r2,0(r2)
10006058:	e0bffc15 	stw	r2,-16(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
1000605c:	e0bffc17 	ldw	r2,-16(fp)
10006060:	10801814 	ori	r2,r2,96
10006064:	e0bffc15 	stw	r2,-16(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
10006068:	e0fffc17 	ldw	r3,-16(fp)
1000606c:	00bffbc4 	movi	r2,-17
10006070:	1884703a 	and	r2,r3,r2
10006074:	e0bffc15 	stw	r2,-16(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
10006078:	e0bffd17 	ldw	r2,-12(fp)
1000607c:	10800317 	ldw	r2,12(r2)
10006080:	10800404 	addi	r2,r2,16
10006084:	e0fffc17 	ldw	r3,-16(fp)
10006088:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
1000608c:	e03fff15 	stw	zero,-4(fp)
10006090:	e0bfff17 	ldw	r2,-4(fp)
}
10006094:	e037883a 	mov	sp,fp
10006098:	df000017 	ldw	fp,0(sp)
1000609c:	dec00104 	addi	sp,sp,4
100060a0:	f800283a 	ret

100060a4 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
100060a4:	defffc04 	addi	sp,sp,-16
100060a8:	df000315 	stw	fp,12(sp)
100060ac:	df000304 	addi	fp,sp,12
100060b0:	e13ffe15 	stw	r4,-8(fp)
100060b4:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
100060b8:	e0bffe17 	ldw	r2,-8(fp)
100060bc:	10800317 	ldw	r2,12(r2)
100060c0:	10800037 	ldwio	r2,0(r2)
100060c4:	1080040c 	andi	r2,r2,16
100060c8:	1004c03a 	cmpne	r2,r2,zero
100060cc:	103ffa1e 	bne	r2,zero,100060b8 <alt_avalon_sgdma_do_sync_transfer+0x14>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
100060d0:	e0bffe17 	ldw	r2,-8(fp)
100060d4:	10800317 	ldw	r2,12(r2)
100060d8:	11000404 	addi	r4,r2,16
100060dc:	e0bffe17 	ldw	r2,-8(fp)
100060e0:	10800317 	ldw	r2,12(r2)
100060e4:	10800404 	addi	r2,r2,16
100060e8:	10c00037 	ldwio	r3,0(r2)
100060ec:	00bff7c4 	movi	r2,-33
100060f0:	1886703a 	and	r3,r3,r2
100060f4:	2005883a 	mov	r2,r4
100060f8:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
100060fc:	e0bffe17 	ldw	r2,-8(fp)
10006100:	10800317 	ldw	r2,12(r2)
10006104:	1007883a 	mov	r3,r2
10006108:	00803fc4 	movi	r2,255
1000610c:	18800035 	stwio	r2,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
10006110:	e0bffe17 	ldw	r2,-8(fp)
10006114:	10800317 	ldw	r2,12(r2)
10006118:	10800804 	addi	r2,r2,32
1000611c:	e0ffff17 	ldw	r3,-4(fp)
10006120:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
10006124:	e0bffe17 	ldw	r2,-8(fp)
10006128:	10800317 	ldw	r2,12(r2)
1000612c:	11000404 	addi	r4,r2,16
10006130:	e0bffe17 	ldw	r2,-8(fp)
10006134:	10800317 	ldw	r2,12(r2)
10006138:	10800404 	addi	r2,r2,16
1000613c:	10800037 	ldwio	r2,0(r2)
10006140:	10c01814 	ori	r3,r2,96
10006144:	2005883a 	mov	r2,r4
10006148:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
1000614c:	e0bffe17 	ldw	r2,-8(fp)
10006150:	10800317 	ldw	r2,12(r2)
10006154:	10800037 	ldwio	r2,0(r2)
10006158:	1080040c 	andi	r2,r2,16
1000615c:	1004c03a 	cmpne	r2,r2,zero
10006160:	103ffa1e 	bne	r2,zero,1000614c <alt_avalon_sgdma_do_sync_transfer+0xa8>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
10006164:	e0bffe17 	ldw	r2,-8(fp)
10006168:	10800317 	ldw	r2,12(r2)
1000616c:	11000404 	addi	r4,r2,16
10006170:	e0bffe17 	ldw	r2,-8(fp)
10006174:	10800317 	ldw	r2,12(r2)
10006178:	10800404 	addi	r2,r2,16
1000617c:	10c00037 	ldwio	r3,0(r2)
10006180:	00bff7c4 	movi	r2,-33
10006184:	1886703a 	and	r3,r3,r2
10006188:	2005883a 	mov	r2,r4
1000618c:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
10006190:	e0bffe17 	ldw	r2,-8(fp)
10006194:	10800317 	ldw	r2,12(r2)
10006198:	10800037 	ldwio	r2,0(r2)
1000619c:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
100061a0:	e0bffe17 	ldw	r2,-8(fp)
100061a4:	10800317 	ldw	r2,12(r2)
100061a8:	1007883a 	mov	r3,r2
100061ac:	00803fc4 	movi	r2,255
100061b0:	18800035 	stwio	r2,0(r3)

  return status;
100061b4:	e0bffd03 	ldbu	r2,-12(fp)
}
100061b8:	e037883a 	mov	sp,fp
100061bc:	df000017 	ldw	fp,0(sp)
100061c0:	dec00104 	addi	sp,sp,4
100061c4:	f800283a 	ret

100061c8 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
100061c8:	defff404 	addi	sp,sp,-48
100061cc:	dfc00b15 	stw	ra,44(sp)
100061d0:	df000a15 	stw	fp,40(sp)
100061d4:	df000a04 	addi	fp,sp,40
100061d8:	e13ffb15 	stw	r4,-20(fp)
100061dc:	e17ffc15 	stw	r5,-16(fp)
100061e0:	e1bffd15 	stw	r6,-12(fp)
100061e4:	e1fffe15 	stw	r7,-8(fp)
100061e8:	e0800217 	ldw	r2,8(fp)
100061ec:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
100061f0:	e0bfff0b 	ldhu	r2,-4(fp)
100061f4:	d8800015 	stw	r2,0(sp)
100061f8:	e0800317 	ldw	r2,12(fp)
100061fc:	d8800115 	stw	r2,4(sp)
10006200:	e0800417 	ldw	r2,16(fp)
10006204:	d8800215 	stw	r2,8(sp)
10006208:	d8000315 	stw	zero,12(sp)
1000620c:	d8000415 	stw	zero,16(sp)
10006210:	e13ffb17 	ldw	r4,-20(fp)
10006214:	e17ffc17 	ldw	r5,-16(fp)
10006218:	e1bffd17 	ldw	r6,-12(fp)
1000621c:	e1fffe17 	ldw	r7,-8(fp)
10006220:	00062380 	call	10006238 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
10006224:	e037883a 	mov	sp,fp
10006228:	dfc00117 	ldw	ra,4(sp)
1000622c:	df000017 	ldw	fp,0(sp)
10006230:	dec00204 	addi	sp,sp,8
10006234:	f800283a 	ret

10006238 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
10006238:	defff204 	addi	sp,sp,-56
1000623c:	dfc00d15 	stw	ra,52(sp)
10006240:	df000c15 	stw	fp,48(sp)
10006244:	df000c04 	addi	fp,sp,48
10006248:	e13ffb15 	stw	r4,-20(fp)
1000624c:	e17ffc15 	stw	r5,-16(fp)
10006250:	e1bffd15 	stw	r6,-12(fp)
10006254:	e1fffe15 	stw	r7,-8(fp)
10006258:	e0800217 	ldw	r2,8(fp)
1000625c:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
10006260:	e0bfff0b 	ldhu	r2,-4(fp)
10006264:	d8800015 	stw	r2,0(sp)
10006268:	d8000115 	stw	zero,4(sp)
1000626c:	e0800317 	ldw	r2,12(fp)
10006270:	d8800215 	stw	r2,8(sp)
10006274:	e0800417 	ldw	r2,16(fp)
10006278:	d8800315 	stw	r2,12(sp)
1000627c:	e0800517 	ldw	r2,20(fp)
10006280:	d8800415 	stw	r2,16(sp)
10006284:	e0800617 	ldw	r2,24(fp)
10006288:	d8800515 	stw	r2,20(sp)
1000628c:	d8000615 	stw	zero,24(sp)
10006290:	e13ffb17 	ldw	r4,-20(fp)
10006294:	e17ffc17 	ldw	r5,-16(fp)
10006298:	e1bffd17 	ldw	r6,-12(fp)
1000629c:	e1fffe17 	ldw	r7,-8(fp)
100062a0:	00067f80 	call	100067f8 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
100062a4:	e037883a 	mov	sp,fp
100062a8:	dfc00117 	ldw	ra,4(sp)
100062ac:	df000017 	ldw	fp,0(sp)
100062b0:	dec00204 	addi	sp,sp,8
100062b4:	f800283a 	ret

100062b8 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
100062b8:	defff804 	addi	sp,sp,-32
100062bc:	dfc00715 	stw	ra,28(sp)
100062c0:	df000615 	stw	fp,24(sp)
100062c4:	df000604 	addi	fp,sp,24
100062c8:	e13ffc15 	stw	r4,-16(fp)
100062cc:	e17ffd15 	stw	r5,-12(fp)
100062d0:	e1bffe15 	stw	r6,-8(fp)
100062d4:	e1ffff0d 	sth	r7,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
100062d8:	e1ffff0b 	ldhu	r7,-4(fp)
100062dc:	e0800217 	ldw	r2,8(fp)
100062e0:	d8800015 	stw	r2,0(sp)
100062e4:	d8000115 	stw	zero,4(sp)
100062e8:	e13ffc17 	ldw	r4,-16(fp)
100062ec:	e17ffd17 	ldw	r5,-12(fp)
100062f0:	e1bffe17 	ldw	r6,-8(fp)
100062f4:	000630c0 	call	1000630c <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
100062f8:	e037883a 	mov	sp,fp
100062fc:	dfc00117 	ldw	ra,4(sp)
10006300:	df000017 	ldw	fp,0(sp)
10006304:	dec00204 	addi	sp,sp,8
10006308:	f800283a 	ret

1000630c <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
1000630c:	defff304 	addi	sp,sp,-52
10006310:	dfc00c15 	stw	ra,48(sp)
10006314:	df000b15 	stw	fp,44(sp)
10006318:	df000b04 	addi	fp,sp,44
1000631c:	e13ffc15 	stw	r4,-16(fp)
10006320:	e17ffd15 	stw	r5,-12(fp)
10006324:	e1bffe15 	stw	r6,-8(fp)
10006328:	e1ffff0d 	sth	r7,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
1000632c:	e0bfff0b 	ldhu	r2,-4(fp)
10006330:	d8800015 	stw	r2,0(sp)
10006334:	d8000115 	stw	zero,4(sp)
10006338:	d8000215 	stw	zero,8(sp)
1000633c:	e0800217 	ldw	r2,8(fp)
10006340:	d8800315 	stw	r2,12(sp)
10006344:	d8000415 	stw	zero,16(sp)
10006348:	e0800317 	ldw	r2,12(fp)
1000634c:	d8800515 	stw	r2,20(sp)
10006350:	d8000615 	stw	zero,24(sp)
10006354:	e13ffc17 	ldw	r4,-16(fp)
10006358:	e17ffd17 	ldw	r5,-12(fp)
1000635c:	000d883a 	mov	r6,zero
10006360:	e1fffe17 	ldw	r7,-8(fp)
10006364:	00067f80 	call	100067f8 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
10006368:	e037883a 	mov	sp,fp
1000636c:	dfc00117 	ldw	ra,4(sp)
10006370:	df000017 	ldw	fp,0(sp)
10006374:	dec00204 	addi	sp,sp,8
10006378:	f800283a 	ret

1000637c <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
1000637c:	defff404 	addi	sp,sp,-48
10006380:	dfc00b15 	stw	ra,44(sp)
10006384:	df000a15 	stw	fp,40(sp)
10006388:	df000a04 	addi	fp,sp,40
1000638c:	e13ffb15 	stw	r4,-20(fp)
10006390:	e17ffc15 	stw	r5,-16(fp)
10006394:	e1bffd15 	stw	r6,-12(fp)
10006398:	e0800517 	ldw	r2,20(fp)
1000639c:	e1fffe0d 	sth	r7,-8(fp)
100063a0:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
100063a4:	e1fffe0b 	ldhu	r7,-8(fp)
100063a8:	e0ffff03 	ldbu	r3,-4(fp)
100063ac:	e0800217 	ldw	r2,8(fp)
100063b0:	d8800015 	stw	r2,0(sp)
100063b4:	e0800317 	ldw	r2,12(fp)
100063b8:	d8800115 	stw	r2,4(sp)
100063bc:	e0800417 	ldw	r2,16(fp)
100063c0:	d8800215 	stw	r2,8(sp)
100063c4:	d8000315 	stw	zero,12(sp)
100063c8:	d8c00415 	stw	r3,16(sp)
100063cc:	e13ffb17 	ldw	r4,-20(fp)
100063d0:	e17ffc17 	ldw	r5,-16(fp)
100063d4:	e1bffd17 	ldw	r6,-12(fp)
100063d8:	00063f00 	call	100063f0 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
100063dc:	e037883a 	mov	sp,fp
100063e0:	dfc00117 	ldw	ra,4(sp)
100063e4:	df000017 	ldw	fp,0(sp)
100063e8:	dec00204 	addi	sp,sp,8
100063ec:	f800283a 	ret

100063f0 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
100063f0:	defff204 	addi	sp,sp,-56
100063f4:	dfc00d15 	stw	ra,52(sp)
100063f8:	df000c15 	stw	fp,48(sp)
100063fc:	df000c04 	addi	fp,sp,48
10006400:	e13ffb15 	stw	r4,-20(fp)
10006404:	e17ffc15 	stw	r5,-16(fp)
10006408:	e1bffd15 	stw	r6,-12(fp)
1000640c:	e0800617 	ldw	r2,24(fp)
10006410:	e1fffe0d 	sth	r7,-8(fp)
10006414:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
10006418:	e0bffe0b 	ldhu	r2,-8(fp)
1000641c:	e0ffff03 	ldbu	r3,-4(fp)
10006420:	d8800015 	stw	r2,0(sp)
10006424:	e0800417 	ldw	r2,16(fp)
10006428:	d8800115 	stw	r2,4(sp)
1000642c:	e0800217 	ldw	r2,8(fp)
10006430:	d8800215 	stw	r2,8(sp)
10006434:	e0800317 	ldw	r2,12(fp)
10006438:	d8800315 	stw	r2,12(sp)
1000643c:	e0800517 	ldw	r2,20(fp)
10006440:	d8800415 	stw	r2,16(sp)
10006444:	d8000515 	stw	zero,20(sp)
10006448:	d8c00615 	stw	r3,24(sp)
1000644c:	e13ffb17 	ldw	r4,-20(fp)
10006450:	e17ffc17 	ldw	r5,-16(fp)
10006454:	e1bffd17 	ldw	r6,-12(fp)
10006458:	000f883a 	mov	r7,zero
1000645c:	00067f80 	call	100067f8 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
10006460:	e037883a 	mov	sp,fp
10006464:	dfc00117 	ldw	ra,4(sp)
10006468:	df000017 	ldw	fp,0(sp)
1000646c:	dec00204 	addi	sp,sp,8
10006470:	f800283a 	ret

10006474 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
10006474:	defffb04 	addi	sp,sp,-20
10006478:	df000415 	stw	fp,16(sp)
1000647c:	df000404 	addi	fp,sp,16
10006480:	e13ffc15 	stw	r4,-16(fp)
10006484:	e17ffd15 	stw	r5,-12(fp)
10006488:	e1bffe15 	stw	r6,-8(fp)
1000648c:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
10006490:	e0fffc17 	ldw	r3,-16(fp)
10006494:	e0bffd17 	ldw	r2,-12(fp)
10006498:	18800915 	stw	r2,36(r3)
  dev->callback_context = context;
1000649c:	e0fffc17 	ldw	r3,-16(fp)
100064a0:	e0bfff17 	ldw	r2,-4(fp)
100064a4:	18800a15 	stw	r2,40(r3)
  dev->chain_control    = chain_control;
100064a8:	e0fffc17 	ldw	r3,-16(fp)
100064ac:	e0bffe17 	ldw	r2,-8(fp)
100064b0:	18800b15 	stw	r2,44(r3)
}
100064b4:	e037883a 	mov	sp,fp
100064b8:	df000017 	ldw	fp,0(sp)
100064bc:	dec00104 	addi	sp,sp,4
100064c0:	f800283a 	ret

100064c4 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
100064c4:	defffd04 	addi	sp,sp,-12
100064c8:	df000215 	stw	fp,8(sp)
100064cc:	df000204 	addi	fp,sp,8
100064d0:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
100064d4:	e0bfff17 	ldw	r2,-4(fp)
100064d8:	10800317 	ldw	r2,12(r2)
100064dc:	10800404 	addi	r2,r2,16
100064e0:	10800037 	ldwio	r2,0(r2)
100064e4:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
100064e8:	e0bffe17 	ldw	r2,-8(fp)
100064ec:	10800814 	ori	r2,r2,32
100064f0:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
100064f4:	e0bfff17 	ldw	r2,-4(fp)
100064f8:	10800317 	ldw	r2,12(r2)
100064fc:	10800404 	addi	r2,r2,16
10006500:	e0fffe17 	ldw	r3,-8(fp)
10006504:	10c00035 	stwio	r3,0(r2)
}
10006508:	e037883a 	mov	sp,fp
1000650c:	df000017 	ldw	fp,0(sp)
10006510:	dec00104 	addi	sp,sp,4
10006514:	f800283a 	ret

10006518 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
10006518:	defffd04 	addi	sp,sp,-12
1000651c:	df000215 	stw	fp,8(sp)
10006520:	df000204 	addi	fp,sp,8
10006524:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
10006528:	e0bfff17 	ldw	r2,-4(fp)
1000652c:	10800317 	ldw	r2,12(r2)
10006530:	10800404 	addi	r2,r2,16
10006534:	10800037 	ldwio	r2,0(r2)
10006538:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
1000653c:	e0fffe17 	ldw	r3,-8(fp)
10006540:	00bff7c4 	movi	r2,-33
10006544:	1884703a 	and	r2,r3,r2
10006548:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
1000654c:	e0bfff17 	ldw	r2,-4(fp)
10006550:	10800317 	ldw	r2,12(r2)
10006554:	10800404 	addi	r2,r2,16
10006558:	e0fffe17 	ldw	r3,-8(fp)
1000655c:	10c00035 	stwio	r3,0(r2)
}
10006560:	e037883a 	mov	sp,fp
10006564:	df000017 	ldw	fp,0(sp)
10006568:	dec00104 	addi	sp,sp,4
1000656c:	f800283a 	ret

10006570 <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
10006570:	defffd04 	addi	sp,sp,-12
10006574:	df000215 	stw	fp,8(sp)
10006578:	df000204 	addi	fp,sp,8
1000657c:	e13ffe15 	stw	r4,-8(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
10006580:	e0bffe17 	ldw	r2,-8(fp)
10006584:	10800784 	addi	r2,r2,30
10006588:	10800023 	ldbuio	r2,0(r2)
1000658c:	10801fcc 	andi	r2,r2,127
10006590:	1005003a 	cmpeq	r2,r2,zero
10006594:	1000031e 	bne	r2,zero,100065a4 <alt_avalon_sgdma_check_descriptor_status+0x34>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
10006598:	00bffec4 	movi	r2,-5
1000659c:	e0bfff15 	stw	r2,-4(fp)
100065a0:	00000a06 	br	100065cc <alt_avalon_sgdma_check_descriptor_status+0x5c>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
100065a4:	e0bffe17 	ldw	r2,-8(fp)
100065a8:	108007c4 	addi	r2,r2,31
100065ac:	10800023 	ldbuio	r2,0(r2)
100065b0:	1080200c 	andi	r2,r2,128
100065b4:	1005003a 	cmpeq	r2,r2,zero
100065b8:	1000031e 	bne	r2,zero,100065c8 <alt_avalon_sgdma_check_descriptor_status+0x58>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
100065bc:	00bfe244 	movi	r2,-119
100065c0:	e0bfff15 	stw	r2,-4(fp)
100065c4:	00000106 	br	100065cc <alt_avalon_sgdma_check_descriptor_status+0x5c>
  }

    return 0;
100065c8:	e03fff15 	stw	zero,-4(fp)
100065cc:	e0bfff17 	ldw	r2,-4(fp)
}
100065d0:	e037883a 	mov	sp,fp
100065d4:	df000017 	ldw	fp,0(sp)
100065d8:	dec00104 	addi	sp,sp,4
100065dc:	f800283a 	ret

100065e0 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
100065e0:	defffc04 	addi	sp,sp,-16
100065e4:	dfc00315 	stw	ra,12(sp)
100065e8:	df000215 	stw	fp,8(sp)
100065ec:	df000204 	addi	fp,sp,8
100065f0:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
100065f4:	e13fff17 	ldw	r4,-4(fp)
100065f8:	d1600b04 	addi	r5,gp,-32724
100065fc:	00071f40 	call	100071f4 <alt_find_dev>
10006600:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
10006604:	e0bffe17 	ldw	r2,-8(fp)
10006608:	1004c03a 	cmpne	r2,r2,zero
1000660c:	1000041e 	bne	r2,zero,10006620 <alt_avalon_sgdma_open+0x40>
    ALT_ERRNO = ENODEV;
10006610:	00066380 	call	10006638 <alt_get_errno>
10006614:	1007883a 	mov	r3,r2
10006618:	008004c4 	movi	r2,19
1000661c:	18800015 	stw	r2,0(r3)
  }

  return dev;
10006620:	e0bffe17 	ldw	r2,-8(fp)
}
10006624:	e037883a 	mov	sp,fp
10006628:	dfc00117 	ldw	ra,4(sp)
1000662c:	df000017 	ldw	fp,0(sp)
10006630:	dec00204 	addi	sp,sp,8
10006634:	f800283a 	ret

10006638 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
10006638:	defffd04 	addi	sp,sp,-12
1000663c:	dfc00215 	stw	ra,8(sp)
10006640:	df000115 	stw	fp,4(sp)
10006644:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
10006648:	00840074 	movhi	r2,4097
1000664c:	10aa1704 	addi	r2,r2,-22436
10006650:	10800017 	ldw	r2,0(r2)
10006654:	1005003a 	cmpeq	r2,r2,zero
10006658:	1000061e 	bne	r2,zero,10006674 <alt_get_errno+0x3c>
1000665c:	00840074 	movhi	r2,4097
10006660:	10aa1704 	addi	r2,r2,-22436
10006664:	10800017 	ldw	r2,0(r2)
10006668:	103ee83a 	callr	r2
1000666c:	e0bfff15 	stw	r2,-4(fp)
10006670:	00000306 	br	10006680 <alt_get_errno+0x48>
10006674:	00840074 	movhi	r2,4097
10006678:	10aa2304 	addi	r2,r2,-22388
1000667c:	e0bfff15 	stw	r2,-4(fp)
10006680:	e0bfff17 	ldw	r2,-4(fp)
}
10006684:	e037883a 	mov	sp,fp
10006688:	dfc00117 	ldw	ra,4(sp)
1000668c:	df000017 	ldw	fp,0(sp)
10006690:	dec00204 	addi	sp,sp,8
10006694:	f800283a 	ret

10006698 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
10006698:	defff104 	addi	sp,sp,-60
1000669c:	dfc00e15 	stw	ra,56(sp)
100066a0:	df000d15 	stw	fp,52(sp)
100066a4:	df000d04 	addi	fp,sp,52
100066a8:	e13ffa15 	stw	r4,-24(fp)
100066ac:	e17ffb15 	stw	r5,-20(fp)
100066b0:	e1bffc15 	stw	r6,-16(fp)
100066b4:	e1fffd15 	stw	r7,-12(fp)
100066b8:	e0800217 	ldw	r2,8(fp)
100066bc:	e0c00617 	ldw	r3,24(fp)
100066c0:	e0bffe0d 	sth	r2,-8(fp)
100066c4:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
100066c8:	e0bffe0b 	ldhu	r2,-8(fp)
100066cc:	e0ffff03 	ldbu	r3,-4(fp)
100066d0:	d8800015 	stw	r2,0(sp)
100066d4:	e0800317 	ldw	r2,12(fp)
100066d8:	d8800115 	stw	r2,4(sp)
100066dc:	e0800417 	ldw	r2,16(fp)
100066e0:	d8800215 	stw	r2,8(sp)
100066e4:	e0800517 	ldw	r2,20(fp)
100066e8:	d8800315 	stw	r2,12(sp)
100066ec:	d8000415 	stw	zero,16(sp)
100066f0:	d8000515 	stw	zero,20(sp)
100066f4:	d8c00615 	stw	r3,24(sp)
100066f8:	e13ffa17 	ldw	r4,-24(fp)
100066fc:	e17ffb17 	ldw	r5,-20(fp)
10006700:	e1bffc17 	ldw	r6,-16(fp)
10006704:	e1fffd17 	ldw	r7,-12(fp)
10006708:	00067f80 	call	100067f8 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
1000670c:	e037883a 	mov	sp,fp
10006710:	dfc00117 	ldw	ra,4(sp)
10006714:	df000017 	ldw	fp,0(sp)
10006718:	dec00204 	addi	sp,sp,8
1000671c:	f800283a 	ret

10006720 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
10006720:	defffc04 	addi	sp,sp,-16
10006724:	df000315 	stw	fp,12(sp)
10006728:	df000304 	addi	fp,sp,12
1000672c:	e13ffe15 	stw	r4,-8(fp)
10006730:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
10006734:	e0bffe17 	ldw	r2,-8(fp)
10006738:	10800317 	ldw	r2,12(r2)
1000673c:	10800404 	addi	r2,r2,16
10006740:	10800037 	ldwio	r2,0(r2)
10006744:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
10006748:	e0fffd17 	ldw	r3,-12(fp)
1000674c:	00a00434 	movhi	r2,32784
10006750:	10bfffc4 	addi	r2,r2,-1
10006754:	1884703a 	and	r2,r3,r2
10006758:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
1000675c:	e0bfff17 	ldw	r2,-4(fp)
10006760:	1004953a 	slli	r2,r2,20
10006764:	10dffc2c 	andhi	r3,r2,32752
10006768:	e0bffd17 	ldw	r2,-12(fp)
1000676c:	1884b03a 	or	r2,r3,r2
10006770:	10800134 	orhi	r2,r2,4
10006774:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
10006778:	e0bffe17 	ldw	r2,-8(fp)
1000677c:	10800317 	ldw	r2,12(r2)
10006780:	10800404 	addi	r2,r2,16
10006784:	e0fffd17 	ldw	r3,-12(fp)
10006788:	10c00035 	stwio	r3,0(r2)
  
  return;
}
1000678c:	e037883a 	mov	sp,fp
10006790:	df000017 	ldw	fp,0(sp)
10006794:	dec00104 	addi	sp,sp,4
10006798:	f800283a 	ret

1000679c <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
1000679c:	defffd04 	addi	sp,sp,-12
100067a0:	df000215 	stw	fp,8(sp)
100067a4:	df000204 	addi	fp,sp,8
100067a8:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
100067ac:	e0bfff17 	ldw	r2,-4(fp)
100067b0:	10800317 	ldw	r2,12(r2)
100067b4:	10800404 	addi	r2,r2,16
100067b8:	10800037 	ldwio	r2,0(r2)
100067bc:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
100067c0:	e0fffe17 	ldw	r3,-8(fp)
100067c4:	00bfff34 	movhi	r2,65532
100067c8:	10bfffc4 	addi	r2,r2,-1
100067cc:	1884703a 	and	r2,r3,r2
100067d0:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
100067d4:	e0bfff17 	ldw	r2,-4(fp)
100067d8:	10800317 	ldw	r2,12(r2)
100067dc:	10800404 	addi	r2,r2,16
100067e0:	e0fffe17 	ldw	r3,-8(fp)
100067e4:	10c00035 	stwio	r3,0(r2)
  
  return;
}
100067e8:	e037883a 	mov	sp,fp
100067ec:	df000017 	ldw	fp,0(sp)
100067f0:	dec00104 	addi	sp,sp,4
100067f4:	f800283a 	ret

100067f8 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
100067f8:	defff204 	addi	sp,sp,-56
100067fc:	dfc00d15 	stw	ra,52(sp)
10006800:	df000c15 	stw	fp,48(sp)
10006804:	df000c04 	addi	fp,sp,48
10006808:	e13ff415 	stw	r4,-48(fp)
1000680c:	e17ff515 	stw	r5,-44(fp)
10006810:	e1bff615 	stw	r6,-40(fp)
10006814:	e1fff715 	stw	r7,-36(fp)
10006818:	e0800217 	ldw	r2,8(fp)
1000681c:	e0c00817 	ldw	r3,32(fp)
10006820:	e0bff80d 	sth	r2,-32(fp)
10006824:	e0fff905 	stb	r3,-28(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10006828:	e0bff517 	ldw	r2,-44(fp)
1000682c:	110007c4 	addi	r4,r2,31
10006830:	e0bff517 	ldw	r2,-44(fp)
10006834:	108007c3 	ldbu	r2,31(r2)
10006838:	10c03fcc 	andi	r3,r2,255
1000683c:	00bfdfc4 	movi	r2,-129
10006840:	1886703a 	and	r3,r3,r2
10006844:	2005883a 	mov	r2,r4
10006848:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
1000684c:	e13ff417 	ldw	r4,-48(fp)
10006850:	e0bff617 	ldw	r2,-40(fp)
10006854:	11403fcc 	andi	r5,r2,255
10006858:	20800003 	ldbu	r2,0(r4)
1000685c:	1004703a 	and	r2,r2,zero
10006860:	1007883a 	mov	r3,r2
10006864:	2805883a 	mov	r2,r5
10006868:	1884b03a 	or	r2,r3,r2
1000686c:	20800005 	stb	r2,0(r4)
10006870:	e0bff617 	ldw	r2,-40(fp)
10006874:	1004d23a 	srli	r2,r2,8
10006878:	11403fcc 	andi	r5,r2,255
1000687c:	20800043 	ldbu	r2,1(r4)
10006880:	1004703a 	and	r2,r2,zero
10006884:	1007883a 	mov	r3,r2
10006888:	2805883a 	mov	r2,r5
1000688c:	1884b03a 	or	r2,r3,r2
10006890:	20800045 	stb	r2,1(r4)
10006894:	e0bff617 	ldw	r2,-40(fp)
10006898:	1004d43a 	srli	r2,r2,16
1000689c:	11403fcc 	andi	r5,r2,255
100068a0:	20800083 	ldbu	r2,2(r4)
100068a4:	1004703a 	and	r2,r2,zero
100068a8:	1007883a 	mov	r3,r2
100068ac:	2805883a 	mov	r2,r5
100068b0:	1884b03a 	or	r2,r3,r2
100068b4:	20800085 	stb	r2,2(r4)
100068b8:	e0bff617 	ldw	r2,-40(fp)
100068bc:	100ad63a 	srli	r5,r2,24
100068c0:	208000c3 	ldbu	r2,3(r4)
100068c4:	1004703a 	and	r2,r2,zero
100068c8:	1007883a 	mov	r3,r2
100068cc:	2805883a 	mov	r2,r5
100068d0:	1884b03a 	or	r2,r3,r2
100068d4:	208000c5 	stb	r2,3(r4)
  desc->write_addr               = write_addr;
100068d8:	e13ff417 	ldw	r4,-48(fp)
100068dc:	e0bff717 	ldw	r2,-36(fp)
100068e0:	11403fcc 	andi	r5,r2,255
100068e4:	20800203 	ldbu	r2,8(r4)
100068e8:	1004703a 	and	r2,r2,zero
100068ec:	1007883a 	mov	r3,r2
100068f0:	2805883a 	mov	r2,r5
100068f4:	1884b03a 	or	r2,r3,r2
100068f8:	20800205 	stb	r2,8(r4)
100068fc:	e0bff717 	ldw	r2,-36(fp)
10006900:	1004d23a 	srli	r2,r2,8
10006904:	11403fcc 	andi	r5,r2,255
10006908:	20800243 	ldbu	r2,9(r4)
1000690c:	1004703a 	and	r2,r2,zero
10006910:	1007883a 	mov	r3,r2
10006914:	2805883a 	mov	r2,r5
10006918:	1884b03a 	or	r2,r3,r2
1000691c:	20800245 	stb	r2,9(r4)
10006920:	e0bff717 	ldw	r2,-36(fp)
10006924:	1004d43a 	srli	r2,r2,16
10006928:	11403fcc 	andi	r5,r2,255
1000692c:	20800283 	ldbu	r2,10(r4)
10006930:	1004703a 	and	r2,r2,zero
10006934:	1007883a 	mov	r3,r2
10006938:	2805883a 	mov	r2,r5
1000693c:	1884b03a 	or	r2,r3,r2
10006940:	20800285 	stb	r2,10(r4)
10006944:	e0bff717 	ldw	r2,-36(fp)
10006948:	100ad63a 	srli	r5,r2,24
1000694c:	208002c3 	ldbu	r2,11(r4)
10006950:	1004703a 	and	r2,r2,zero
10006954:	1007883a 	mov	r3,r2
10006958:	2805883a 	mov	r2,r5
1000695c:	1884b03a 	or	r2,r3,r2
10006960:	208002c5 	stb	r2,11(r4)
  desc->next                     = (alt_u32 *) next;
10006964:	e1bff517 	ldw	r6,-44(fp)
10006968:	e13ff417 	ldw	r4,-48(fp)
1000696c:	31403fcc 	andi	r5,r6,255
10006970:	20800403 	ldbu	r2,16(r4)
10006974:	1004703a 	and	r2,r2,zero
10006978:	1007883a 	mov	r3,r2
1000697c:	2805883a 	mov	r2,r5
10006980:	1884b03a 	or	r2,r3,r2
10006984:	20800405 	stb	r2,16(r4)
10006988:	3004d23a 	srli	r2,r6,8
1000698c:	11403fcc 	andi	r5,r2,255
10006990:	20800443 	ldbu	r2,17(r4)
10006994:	1004703a 	and	r2,r2,zero
10006998:	1007883a 	mov	r3,r2
1000699c:	2805883a 	mov	r2,r5
100069a0:	1884b03a 	or	r2,r3,r2
100069a4:	20800445 	stb	r2,17(r4)
100069a8:	3004d43a 	srli	r2,r6,16
100069ac:	11403fcc 	andi	r5,r2,255
100069b0:	20800483 	ldbu	r2,18(r4)
100069b4:	1004703a 	and	r2,r2,zero
100069b8:	1007883a 	mov	r3,r2
100069bc:	2805883a 	mov	r2,r5
100069c0:	1884b03a 	or	r2,r3,r2
100069c4:	20800485 	stb	r2,18(r4)
100069c8:	300ad63a 	srli	r5,r6,24
100069cc:	208004c3 	ldbu	r2,19(r4)
100069d0:	1004703a 	and	r2,r2,zero
100069d4:	1007883a 	mov	r3,r2
100069d8:	2805883a 	mov	r2,r5
100069dc:	1884b03a 	or	r2,r3,r2
100069e0:	208004c5 	stb	r2,19(r4)
  desc->read_addr_pad            = 0x0;
100069e4:	e0fff417 	ldw	r3,-48(fp)
100069e8:	18800103 	ldbu	r2,4(r3)
100069ec:	1004703a 	and	r2,r2,zero
100069f0:	18800105 	stb	r2,4(r3)
100069f4:	18800143 	ldbu	r2,5(r3)
100069f8:	1004703a 	and	r2,r2,zero
100069fc:	18800145 	stb	r2,5(r3)
10006a00:	18800183 	ldbu	r2,6(r3)
10006a04:	1004703a 	and	r2,r2,zero
10006a08:	18800185 	stb	r2,6(r3)
10006a0c:	188001c3 	ldbu	r2,7(r3)
10006a10:	1004703a 	and	r2,r2,zero
10006a14:	188001c5 	stb	r2,7(r3)
  desc->write_addr_pad           = 0x0;
10006a18:	e0fff417 	ldw	r3,-48(fp)
10006a1c:	18800303 	ldbu	r2,12(r3)
10006a20:	1004703a 	and	r2,r2,zero
10006a24:	18800305 	stb	r2,12(r3)
10006a28:	18800343 	ldbu	r2,13(r3)
10006a2c:	1004703a 	and	r2,r2,zero
10006a30:	18800345 	stb	r2,13(r3)
10006a34:	18800383 	ldbu	r2,14(r3)
10006a38:	1004703a 	and	r2,r2,zero
10006a3c:	18800385 	stb	r2,14(r3)
10006a40:	188003c3 	ldbu	r2,15(r3)
10006a44:	1004703a 	and	r2,r2,zero
10006a48:	188003c5 	stb	r2,15(r3)
  desc->next_pad                 = 0x0;
10006a4c:	e0fff417 	ldw	r3,-48(fp)
10006a50:	18800503 	ldbu	r2,20(r3)
10006a54:	1004703a 	and	r2,r2,zero
10006a58:	18800505 	stb	r2,20(r3)
10006a5c:	18800543 	ldbu	r2,21(r3)
10006a60:	1004703a 	and	r2,r2,zero
10006a64:	18800545 	stb	r2,21(r3)
10006a68:	18800583 	ldbu	r2,22(r3)
10006a6c:	1004703a 	and	r2,r2,zero
10006a70:	18800585 	stb	r2,22(r3)
10006a74:	188005c3 	ldbu	r2,23(r3)
10006a78:	1004703a 	and	r2,r2,zero
10006a7c:	188005c5 	stb	r2,23(r3)
  desc->bytes_to_transfer        = length_or_eop;
10006a80:	e13ff417 	ldw	r4,-48(fp)
10006a84:	e0bff80b 	ldhu	r2,-32(fp)
10006a88:	11403fcc 	andi	r5,r2,255
10006a8c:	20800603 	ldbu	r2,24(r4)
10006a90:	1004703a 	and	r2,r2,zero
10006a94:	1007883a 	mov	r3,r2
10006a98:	2805883a 	mov	r2,r5
10006a9c:	1884b03a 	or	r2,r3,r2
10006aa0:	20800605 	stb	r2,24(r4)
10006aa4:	e0bff80b 	ldhu	r2,-32(fp)
10006aa8:	1004d23a 	srli	r2,r2,8
10006aac:	117fffcc 	andi	r5,r2,65535
10006ab0:	20800643 	ldbu	r2,25(r4)
10006ab4:	1004703a 	and	r2,r2,zero
10006ab8:	1007883a 	mov	r3,r2
10006abc:	2805883a 	mov	r2,r5
10006ac0:	1884b03a 	or	r2,r3,r2
10006ac4:	20800645 	stb	r2,25(r4)
  desc->actual_bytes_transferred = 0;
10006ac8:	e0fff417 	ldw	r3,-48(fp)
10006acc:	18800703 	ldbu	r2,28(r3)
10006ad0:	1004703a 	and	r2,r2,zero
10006ad4:	18800705 	stb	r2,28(r3)
10006ad8:	18800743 	ldbu	r2,29(r3)
10006adc:	1004703a 	and	r2,r2,zero
10006ae0:	18800745 	stb	r2,29(r3)
  desc->status                   = 0x0;
10006ae4:	e0bff417 	ldw	r2,-48(fp)
10006ae8:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
10006aec:	e0800617 	ldw	r2,24(fp)
10006af0:	1007883a 	mov	r3,r2
10006af4:	e0bff417 	ldw	r2,-48(fp)
10006af8:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
10006afc:	e0800717 	ldw	r2,28(fp)
10006b00:	1007883a 	mov	r3,r2
10006b04:	e0bff417 	ldw	r2,-48(fp)
10006b08:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10006b0c:	e0800317 	ldw	r2,12(fp)
10006b10:	1005003a 	cmpeq	r2,r2,zero
10006b14:	1000031e 	bne	r2,zero,10006b24 <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
10006b18:	00bfe044 	movi	r2,-127
10006b1c:	e0bfff05 	stb	r2,-4(fp)
10006b20:	00000206 	br	10006b2c <alt_avalon_sgdma_construct_descriptor_burst+0x334>
10006b24:	00bfe004 	movi	r2,-128
10006b28:	e0bfff05 	stb	r2,-4(fp)
10006b2c:	e0800417 	ldw	r2,16(fp)
10006b30:	1005003a 	cmpeq	r2,r2,zero
10006b34:	1000031e 	bne	r2,zero,10006b44 <alt_avalon_sgdma_construct_descriptor_burst+0x34c>
10006b38:	00800084 	movi	r2,2
10006b3c:	e0bffe05 	stb	r2,-8(fp)
10006b40:	00000106 	br	10006b48 <alt_avalon_sgdma_construct_descriptor_burst+0x350>
10006b44:	e03ffe05 	stb	zero,-8(fp)
10006b48:	e0ffff03 	ldbu	r3,-4(fp)
10006b4c:	e13ffe03 	ldbu	r4,-8(fp)
10006b50:	1904b03a 	or	r2,r3,r4
10006b54:	e0bffd05 	stb	r2,-12(fp)
10006b58:	e0800517 	ldw	r2,20(fp)
10006b5c:	1005003a 	cmpeq	r2,r2,zero
10006b60:	1000031e 	bne	r2,zero,10006b70 <alt_avalon_sgdma_construct_descriptor_burst+0x378>
10006b64:	00800104 	movi	r2,4
10006b68:	e0bffc05 	stb	r2,-16(fp)
10006b6c:	00000106 	br	10006b74 <alt_avalon_sgdma_construct_descriptor_burst+0x37c>
10006b70:	e03ffc05 	stb	zero,-16(fp)
10006b74:	e0fffd03 	ldbu	r3,-12(fp)
10006b78:	e13ffc03 	ldbu	r4,-16(fp)
10006b7c:	1904b03a 	or	r2,r3,r4
10006b80:	e0bffb05 	stb	r2,-20(fp)
10006b84:	e0bff903 	ldbu	r2,-28(fp)
10006b88:	1005003a 	cmpeq	r2,r2,zero
10006b8c:	1000051e 	bne	r2,zero,10006ba4 <alt_avalon_sgdma_construct_descriptor_burst+0x3ac>
10006b90:	e0bff903 	ldbu	r2,-28(fp)
10006b94:	108003cc 	andi	r2,r2,15
10006b98:	100490fa 	slli	r2,r2,3
10006b9c:	e0bffa05 	stb	r2,-24(fp)
10006ba0:	00000106 	br	10006ba8 <alt_avalon_sgdma_construct_descriptor_burst+0x3b0>
10006ba4:	e03ffa05 	stb	zero,-24(fp)
10006ba8:	e0fffb03 	ldbu	r3,-20(fp)
10006bac:	e13ffa03 	ldbu	r4,-24(fp)
10006bb0:	1904b03a 	or	r2,r3,r4
10006bb4:	1007883a 	mov	r3,r2
10006bb8:	e0bff417 	ldw	r2,-48(fp)
10006bbc:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
10006bc0:	e13ff417 	ldw	r4,-48(fp)
10006bc4:	01400804 	movi	r5,32
10006bc8:	0007a240 	call	10007a24 <alt_remap_uncached>
}
10006bcc:	e037883a 	mov	sp,fp
10006bd0:	dfc00117 	ldw	ra,4(sp)
10006bd4:	df000017 	ldw	fp,0(sp)
10006bd8:	dec00204 	addi	sp,sp,8
10006bdc:	f800283a 	ret

10006be0 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
10006be0:	defff904 	addi	sp,sp,-28
10006be4:	dfc00615 	stw	ra,24(sp)
10006be8:	df000515 	stw	fp,20(sp)
10006bec:	df000504 	addi	fp,sp,20
10006bf0:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
10006bf4:	e0bfff17 	ldw	r2,-4(fp)
10006bf8:	e0bffe15 	stw	r2,-8(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
10006bfc:	e0bffe17 	ldw	r2,-8(fp)
10006c00:	10800317 	ldw	r2,12(r2)
10006c04:	11000404 	addi	r4,r2,16
10006c08:	e0bffe17 	ldw	r2,-8(fp)
10006c0c:	10800317 	ldw	r2,12(r2)
10006c10:	10800404 	addi	r2,r2,16
10006c14:	10800037 	ldwio	r2,0(r2)
10006c18:	10a00034 	orhi	r2,r2,32768
10006c1c:	1007883a 	mov	r3,r2
10006c20:	2005883a 	mov	r2,r4
10006c24:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
10006c28:	e0bffe17 	ldw	r2,-8(fp)
10006c2c:	10800317 	ldw	r2,12(r2)
10006c30:	10800404 	addi	r2,r2,16
10006c34:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
10006c38:	e0bffe17 	ldw	r2,-8(fp)
10006c3c:	10800917 	ldw	r2,36(r2)
10006c40:	1005003a 	cmpeq	r2,r2,zero
10006c44:	1000111e 	bne	r2,zero,10006c8c <alt_avalon_sgdma_irq+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10006c48:	0005303a 	rdctl	r2,status
10006c4c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10006c50:	e0fffc17 	ldw	r3,-16(fp)
10006c54:	00bfff84 	movi	r2,-2
10006c58:	1884703a 	and	r2,r3,r2
10006c5c:	1001703a 	wrctl	status,r2
  
  return context;
10006c60:	e0bffc17 	ldw	r2,-16(fp)
    cpu_sr = alt_irq_disable_all();
10006c64:	e0bffd15 	stw	r2,-12(fp)
    (dev->callback)(dev->callback_context);
10006c68:	e0bffe17 	ldw	r2,-8(fp)
10006c6c:	10c00917 	ldw	r3,36(r2)
10006c70:	e0bffe17 	ldw	r2,-8(fp)
10006c74:	11000a17 	ldw	r4,40(r2)
10006c78:	183ee83a 	callr	r3
10006c7c:	e0bffd17 	ldw	r2,-12(fp)
10006c80:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10006c84:	e0bffb17 	ldw	r2,-20(fp)
10006c88:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
10006c8c:	e037883a 	mov	sp,fp
10006c90:	dfc00117 	ldw	ra,4(sp)
10006c94:	df000017 	ldw	fp,0(sp)
10006c98:	dec00204 	addi	sp,sp,8
10006c9c:	f800283a 	ret

10006ca0 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
10006ca0:	defffa04 	addi	sp,sp,-24
10006ca4:	dfc00515 	stw	ra,20(sp)
10006ca8:	df000415 	stw	fp,16(sp)
10006cac:	df000404 	addi	fp,sp,16
10006cb0:	e13ffd15 	stw	r4,-12(fp)
10006cb4:	e17ffe15 	stw	r5,-8(fp)
10006cb8:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
10006cbc:	e0bffd17 	ldw	r2,-12(fp)
10006cc0:	10800317 	ldw	r2,12(r2)
10006cc4:	10800404 	addi	r2,r2,16
10006cc8:	1007883a 	mov	r3,r2
10006ccc:	00800074 	movhi	r2,1
10006cd0:	18800035 	stwio	r2,0(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
10006cd4:	e0bffd17 	ldw	r2,-12(fp)
10006cd8:	10800317 	ldw	r2,12(r2)
10006cdc:	10800404 	addi	r2,r2,16
10006ce0:	1007883a 	mov	r3,r2
10006ce4:	00800074 	movhi	r2,1
10006ce8:	18800035 	stwio	r2,0(r3)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
10006cec:	e0bffd17 	ldw	r2,-12(fp)
10006cf0:	10800317 	ldw	r2,12(r2)
10006cf4:	10800404 	addi	r2,r2,16
10006cf8:	10000035 	stwio	zero,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
10006cfc:	e0bffd17 	ldw	r2,-12(fp)
10006d00:	10800317 	ldw	r2,12(r2)
10006d04:	1007883a 	mov	r3,r2
10006d08:	00803fc4 	movi	r2,255
10006d0c:	18800035 	stwio	r2,0(r3)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
10006d10:	e13ffd17 	ldw	r4,-12(fp)
10006d14:	d1600b04 	addi	r5,gp,-32724
10006d18:	00070180 	call	10007018 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
10006d1c:	d8000015 	stw	zero,0(sp)
10006d20:	e13ffe17 	ldw	r4,-8(fp)
10006d24:	e17fff17 	ldw	r5,-4(fp)
10006d28:	01840034 	movhi	r6,4096
10006d2c:	319af804 	addi	r6,r6,27616
10006d30:	e1fffd17 	ldw	r7,-12(fp)
10006d34:	00073580 	call	10007358 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
10006d38:	e037883a 	mov	sp,fp
10006d3c:	dfc00117 	ldw	ra,4(sp)
10006d40:	df000017 	ldw	fp,0(sp)
10006d44:	dec00204 	addi	sp,sp,8
10006d48:	f800283a 	ret

10006d4c <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
10006d4c:	defffa04 	addi	sp,sp,-24
10006d50:	dfc00515 	stw	ra,20(sp)
10006d54:	df000415 	stw	fp,16(sp)
10006d58:	df000404 	addi	fp,sp,16
10006d5c:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
10006d60:	e0bfff17 	ldw	r2,-4(fp)
10006d64:	10000035 	stwio	zero,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
10006d68:	e0bfff17 	ldw	r2,-4(fp)
10006d6c:	10800104 	addi	r2,r2,4
10006d70:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10006d74:	0005303a 	rdctl	r2,status
10006d78:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10006d7c:	e0fffd17 	ldw	r3,-12(fp)
10006d80:	00bfff84 	movi	r2,-2
10006d84:	1884703a 	and	r2,r3,r2
10006d88:	1001703a 	wrctl	status,r2
  
  return context;
10006d8c:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
10006d90:	e0bffe15 	stw	r2,-8(fp)
  alt_tick ();
10006d94:	0007afc0 	call	10007afc <alt_tick>
10006d98:	e0bffe17 	ldw	r2,-8(fp)
10006d9c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10006da0:	e0bffc17 	ldw	r2,-16(fp)
10006da4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
10006da8:	e037883a 	mov	sp,fp
10006dac:	dfc00117 	ldw	ra,4(sp)
10006db0:	df000017 	ldw	fp,0(sp)
10006db4:	dec00204 	addi	sp,sp,8
10006db8:	f800283a 	ret

10006dbc <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
10006dbc:	defff804 	addi	sp,sp,-32
10006dc0:	dfc00715 	stw	ra,28(sp)
10006dc4:	df000615 	stw	fp,24(sp)
10006dc8:	df000604 	addi	fp,sp,24
10006dcc:	e13ffc15 	stw	r4,-16(fp)
10006dd0:	e17ffd15 	stw	r5,-12(fp)
10006dd4:	e1bffe15 	stw	r6,-8(fp)
10006dd8:	e1ffff15 	stw	r7,-4(fp)
10006ddc:	e0bfff17 	ldw	r2,-4(fp)
10006de0:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
10006de4:	00840074 	movhi	r2,4097
10006de8:	10aa2804 	addi	r2,r2,-22368
10006dec:	10800017 	ldw	r2,0(r2)
10006df0:	1004c03a 	cmpne	r2,r2,zero
10006df4:	1000041e 	bne	r2,zero,10006e08 <alt_avalon_timer_sc_init+0x4c>
  {
    _alt_tick_rate = nticks;
10006df8:	00c40074 	movhi	r3,4097
10006dfc:	18ea2804 	addi	r3,r3,-22368
10006e00:	e0bffb17 	ldw	r2,-20(fp)
10006e04:	18800015 	stw	r2,0(r3)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
10006e08:	e0bffc17 	ldw	r2,-16(fp)
10006e0c:	10800104 	addi	r2,r2,4
10006e10:	1007883a 	mov	r3,r2
10006e14:	008001c4 	movi	r2,7
10006e18:	18800035 	stwio	r2,0(r3)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
10006e1c:	d8000015 	stw	zero,0(sp)
10006e20:	e13ffd17 	ldw	r4,-12(fp)
10006e24:	e17ffe17 	ldw	r5,-8(fp)
10006e28:	01840034 	movhi	r6,4096
10006e2c:	319b5304 	addi	r6,r6,27980
10006e30:	e1fffc17 	ldw	r7,-16(fp)
10006e34:	00073580 	call	10007358 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
10006e38:	e037883a 	mov	sp,fp
10006e3c:	dfc00117 	ldw	ra,4(sp)
10006e40:	df000017 	ldw	fp,0(sp)
10006e44:	dec00204 	addi	sp,sp,8
10006e48:	f800283a 	ret

10006e4c <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
10006e4c:	defff404 	addi	sp,sp,-48
10006e50:	df000b15 	stw	fp,44(sp)
10006e54:	df000b04 	addi	fp,sp,44
10006e58:	e13ffb15 	stw	r4,-20(fp)
10006e5c:	e17ffc15 	stw	r5,-16(fp)
10006e60:	e1bffd15 	stw	r6,-12(fp)
10006e64:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
10006e68:	e03ff915 	stw	zero,-28(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
10006e6c:	00840074 	movhi	r2,4097
10006e70:	10aa2804 	addi	r2,r2,-22368
10006e74:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
10006e78:	1005003a 	cmpeq	r2,r2,zero
10006e7c:	1000411e 	bne	r2,zero,10006f84 <alt_alarm_start+0x138>
  {
    if (alarm)
10006e80:	e0bffb17 	ldw	r2,-20(fp)
10006e84:	1005003a 	cmpeq	r2,r2,zero
10006e88:	10003b1e 	bne	r2,zero,10006f78 <alt_alarm_start+0x12c>
    {
      alarm->callback = callback;
10006e8c:	e0fffb17 	ldw	r3,-20(fp)
10006e90:	e0bffd17 	ldw	r2,-12(fp)
10006e94:	18800315 	stw	r2,12(r3)
      alarm->context  = context;
10006e98:	e0fffb17 	ldw	r3,-20(fp)
10006e9c:	e0bffe17 	ldw	r2,-8(fp)
10006ea0:	18800515 	stw	r2,20(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10006ea4:	0005303a 	rdctl	r2,status
10006ea8:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10006eac:	e0fff817 	ldw	r3,-32(fp)
10006eb0:	00bfff84 	movi	r2,-2
10006eb4:	1884703a 	and	r2,r3,r2
10006eb8:	1001703a 	wrctl	status,r2
  
  return context;
10006ebc:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
10006ec0:	e0bffa15 	stw	r2,-24(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
10006ec4:	00840074 	movhi	r2,4097
10006ec8:	10aa2904 	addi	r2,r2,-22364
10006ecc:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
10006ed0:	e0bff915 	stw	r2,-28(fp)
      
      alarm->time = nticks + current_nticks + 1; 
10006ed4:	e0fffc17 	ldw	r3,-16(fp)
10006ed8:	e0bff917 	ldw	r2,-28(fp)
10006edc:	1885883a 	add	r2,r3,r2
10006ee0:	10c00044 	addi	r3,r2,1
10006ee4:	e0bffb17 	ldw	r2,-20(fp)
10006ee8:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
10006eec:	e0bffb17 	ldw	r2,-20(fp)
10006ef0:	10c00217 	ldw	r3,8(r2)
10006ef4:	e0bff917 	ldw	r2,-28(fp)
10006ef8:	1880042e 	bgeu	r3,r2,10006f0c <alt_alarm_start+0xc0>
      {
        alarm->rollover = 1;
10006efc:	e0fffb17 	ldw	r3,-20(fp)
10006f00:	00800044 	movi	r2,1
10006f04:	18800405 	stb	r2,16(r3)
10006f08:	00000206 	br	10006f14 <alt_alarm_start+0xc8>
      }
      else
      {
        alarm->rollover = 0;
10006f0c:	e0bffb17 	ldw	r2,-20(fp)
10006f10:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
10006f14:	e0fffb17 	ldw	r3,-20(fp)
10006f18:	00840074 	movhi	r2,4097
10006f1c:	10aa1e04 	addi	r2,r2,-22408
10006f20:	e0bff615 	stw	r2,-40(fp)
10006f24:	e0fff715 	stw	r3,-36(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
10006f28:	e0fff717 	ldw	r3,-36(fp)
10006f2c:	e0bff617 	ldw	r2,-40(fp)
10006f30:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
10006f34:	e0bff617 	ldw	r2,-40(fp)
10006f38:	10c00017 	ldw	r3,0(r2)
10006f3c:	e0bff717 	ldw	r2,-36(fp)
10006f40:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
10006f44:	e0bff617 	ldw	r2,-40(fp)
10006f48:	10c00017 	ldw	r3,0(r2)
10006f4c:	e0bff717 	ldw	r2,-36(fp)
10006f50:	18800115 	stw	r2,4(r3)
  list->next           = entry;
10006f54:	e0fff617 	ldw	r3,-40(fp)
10006f58:	e0bff717 	ldw	r2,-36(fp)
10006f5c:	18800015 	stw	r2,0(r3)
10006f60:	e0bffa17 	ldw	r2,-24(fp)
10006f64:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10006f68:	e0bff517 	ldw	r2,-44(fp)
10006f6c:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
10006f70:	e03fff15 	stw	zero,-4(fp)
10006f74:	00000506 	br	10006f8c <alt_alarm_start+0x140>
    }
    else
    {
      return -EINVAL;
10006f78:	00bffa84 	movi	r2,-22
10006f7c:	e0bfff15 	stw	r2,-4(fp)
10006f80:	00000206 	br	10006f8c <alt_alarm_start+0x140>
    }
  }
  else
  {
    return -ENOTSUP;
10006f84:	00bfde84 	movi	r2,-134
10006f88:	e0bfff15 	stw	r2,-4(fp)
10006f8c:	e0bfff17 	ldw	r2,-4(fp)
  }
}
10006f90:	e037883a 	mov	sp,fp
10006f94:	df000017 	ldw	fp,0(sp)
10006f98:	dec00104 	addi	sp,sp,4
10006f9c:	f800283a 	ret

10006fa0 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
10006fa0:	defffb04 	addi	sp,sp,-20
10006fa4:	df000415 	stw	fp,16(sp)
10006fa8:	df000404 	addi	fp,sp,16
10006fac:	e13ffe15 	stw	r4,-8(fp)
10006fb0:	e17fff15 	stw	r5,-4(fp)
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
10006fb4:	e0fffe17 	ldw	r3,-8(fp)
10006fb8:	e0bfff17 	ldw	r2,-4(fp)
10006fbc:	1885883a 	add	r2,r3,r2
10006fc0:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
10006fc4:	e0bffe17 	ldw	r2,-8(fp)
10006fc8:	e0bffd15 	stw	r2,-12(fp)
10006fcc:	00000506 	br	10006fe4 <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
10006fd0:	e0bffd17 	ldw	r2,-12(fp)
10006fd4:	1000001b 	flushda	0(r2)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
10006fd8:	e0bffd17 	ldw	r2,-12(fp)
10006fdc:	10800804 	addi	r2,r2,32
10006fe0:	e0bffd15 	stw	r2,-12(fp)
10006fe4:	e0fffd17 	ldw	r3,-12(fp)
10006fe8:	e0bffc17 	ldw	r2,-16(fp)
10006fec:	18bff836 	bltu	r3,r2,10006fd0 <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
10006ff0:	e0bffe17 	ldw	r2,-8(fp)
10006ff4:	108007cc 	andi	r2,r2,31
10006ff8:	1005003a 	cmpeq	r2,r2,zero
10006ffc:	1000021e 	bne	r2,zero,10007008 <alt_dcache_flush+0x68>
  {
    ALT_FLUSH_DATA(i);
10007000:	e0bffd17 	ldw	r2,-12(fp)
10007004:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
10007008:	e037883a 	mov	sp,fp
1000700c:	df000017 	ldw	fp,0(sp)
10007010:	dec00104 	addi	sp,sp,4
10007014:	f800283a 	ret

10007018 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
10007018:	defff904 	addi	sp,sp,-28
1000701c:	dfc00615 	stw	ra,24(sp)
10007020:	df000515 	stw	fp,20(sp)
10007024:	df000504 	addi	fp,sp,20
10007028:	e13ffd15 	stw	r4,-12(fp)
1000702c:	e17ffe15 	stw	r5,-8(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
10007030:	e0bffd17 	ldw	r2,-12(fp)
10007034:	1005003a 	cmpeq	r2,r2,zero
10007038:	1000041e 	bne	r2,zero,1000704c <alt_dev_llist_insert+0x34>
1000703c:	e0bffd17 	ldw	r2,-12(fp)
10007040:	10800217 	ldw	r2,8(r2)
10007044:	1004c03a 	cmpne	r2,r2,zero
10007048:	1000071e 	bne	r2,zero,10007068 <alt_dev_llist_insert+0x50>
  {
    ALT_ERRNO = EINVAL;
1000704c:	00070cc0 	call	100070cc <alt_get_errno>
10007050:	1007883a 	mov	r3,r2
10007054:	00800584 	movi	r2,22
10007058:	18800015 	stw	r2,0(r3)
    return -EINVAL;
1000705c:	00bffa84 	movi	r2,-22
10007060:	e0bfff15 	stw	r2,-4(fp)
10007064:	00001306 	br	100070b4 <alt_dev_llist_insert+0x9c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
10007068:	e0fffd17 	ldw	r3,-12(fp)
1000706c:	e0bffe17 	ldw	r2,-8(fp)
10007070:	e0bffb15 	stw	r2,-20(fp)
10007074:	e0fffc15 	stw	r3,-16(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
10007078:	e0fffc17 	ldw	r3,-16(fp)
1000707c:	e0bffb17 	ldw	r2,-20(fp)
10007080:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
10007084:	e0bffb17 	ldw	r2,-20(fp)
10007088:	10c00017 	ldw	r3,0(r2)
1000708c:	e0bffc17 	ldw	r2,-16(fp)
10007090:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
10007094:	e0bffb17 	ldw	r2,-20(fp)
10007098:	10c00017 	ldw	r3,0(r2)
1000709c:	e0bffc17 	ldw	r2,-16(fp)
100070a0:	18800115 	stw	r2,4(r3)
  list->next           = entry;
100070a4:	e0fffb17 	ldw	r3,-20(fp)
100070a8:	e0bffc17 	ldw	r2,-16(fp)
100070ac:	18800015 	stw	r2,0(r3)

  return 0;  
100070b0:	e03fff15 	stw	zero,-4(fp)
100070b4:	e0bfff17 	ldw	r2,-4(fp)
}
100070b8:	e037883a 	mov	sp,fp
100070bc:	dfc00117 	ldw	ra,4(sp)
100070c0:	df000017 	ldw	fp,0(sp)
100070c4:	dec00204 	addi	sp,sp,8
100070c8:	f800283a 	ret

100070cc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
100070cc:	defffd04 	addi	sp,sp,-12
100070d0:	dfc00215 	stw	ra,8(sp)
100070d4:	df000115 	stw	fp,4(sp)
100070d8:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
100070dc:	00840074 	movhi	r2,4097
100070e0:	10aa1704 	addi	r2,r2,-22436
100070e4:	10800017 	ldw	r2,0(r2)
100070e8:	1005003a 	cmpeq	r2,r2,zero
100070ec:	1000061e 	bne	r2,zero,10007108 <alt_get_errno+0x3c>
100070f0:	00840074 	movhi	r2,4097
100070f4:	10aa1704 	addi	r2,r2,-22436
100070f8:	10800017 	ldw	r2,0(r2)
100070fc:	103ee83a 	callr	r2
10007100:	e0bfff15 	stw	r2,-4(fp)
10007104:	00000306 	br	10007114 <alt_get_errno+0x48>
10007108:	00840074 	movhi	r2,4097
1000710c:	10aa2304 	addi	r2,r2,-22388
10007110:	e0bfff15 	stw	r2,-4(fp)
10007114:	e0bfff17 	ldw	r2,-4(fp)
}
10007118:	e037883a 	mov	sp,fp
1000711c:	dfc00117 	ldw	ra,4(sp)
10007120:	df000017 	ldw	fp,0(sp)
10007124:	dec00204 	addi	sp,sp,8
10007128:	f800283a 	ret

1000712c <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
1000712c:	defffd04 	addi	sp,sp,-12
10007130:	dfc00215 	stw	ra,8(sp)
10007134:	df000115 	stw	fp,4(sp)
10007138:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
1000713c:	00bfff04 	movi	r2,-4
10007140:	00c40074 	movhi	r3,4097
10007144:	18e30a04 	addi	r3,r3,-29656
10007148:	1885883a 	add	r2,r3,r2
1000714c:	e0bfff15 	stw	r2,-4(fp)
10007150:	00000606 	br	1000716c <_do_ctors+0x40>
        (*ctor) (); 
10007154:	e0bfff17 	ldw	r2,-4(fp)
10007158:	10800017 	ldw	r2,0(r2)
1000715c:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
10007160:	e0bfff17 	ldw	r2,-4(fp)
10007164:	10bfff04 	addi	r2,r2,-4
10007168:	e0bfff15 	stw	r2,-4(fp)
1000716c:	e0ffff17 	ldw	r3,-4(fp)
10007170:	00840074 	movhi	r2,4097
10007174:	10a30904 	addi	r2,r2,-29660
10007178:	18bff62e 	bgeu	r3,r2,10007154 <_do_ctors+0x28>
        (*ctor) (); 
}
1000717c:	e037883a 	mov	sp,fp
10007180:	dfc00117 	ldw	ra,4(sp)
10007184:	df000017 	ldw	fp,0(sp)
10007188:	dec00204 	addi	sp,sp,8
1000718c:	f800283a 	ret

10007190 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
10007190:	defffd04 	addi	sp,sp,-12
10007194:	dfc00215 	stw	ra,8(sp)
10007198:	df000115 	stw	fp,4(sp)
1000719c:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
100071a0:	00bfff04 	movi	r2,-4
100071a4:	00c40074 	movhi	r3,4097
100071a8:	18e30a04 	addi	r3,r3,-29656
100071ac:	1885883a 	add	r2,r3,r2
100071b0:	e0bfff15 	stw	r2,-4(fp)
100071b4:	00000606 	br	100071d0 <_do_dtors+0x40>
        (*dtor) (); 
100071b8:	e0bfff17 	ldw	r2,-4(fp)
100071bc:	10800017 	ldw	r2,0(r2)
100071c0:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
100071c4:	e0bfff17 	ldw	r2,-4(fp)
100071c8:	10bfff04 	addi	r2,r2,-4
100071cc:	e0bfff15 	stw	r2,-4(fp)
100071d0:	e0ffff17 	ldw	r3,-4(fp)
100071d4:	00840074 	movhi	r2,4097
100071d8:	10a30a04 	addi	r2,r2,-29656
100071dc:	18bff62e 	bgeu	r3,r2,100071b8 <_do_dtors+0x28>
        (*dtor) (); 
}
100071e0:	e037883a 	mov	sp,fp
100071e4:	dfc00117 	ldw	ra,4(sp)
100071e8:	df000017 	ldw	fp,0(sp)
100071ec:	dec00204 	addi	sp,sp,8
100071f0:	f800283a 	ret

100071f4 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
100071f4:	defff904 	addi	sp,sp,-28
100071f8:	dfc00615 	stw	ra,24(sp)
100071fc:	df000515 	stw	fp,20(sp)
10007200:	df000504 	addi	fp,sp,20
10007204:	e13ffd15 	stw	r4,-12(fp)
10007208:	e17ffe15 	stw	r5,-8(fp)
  alt_dev* next = (alt_dev*) llist->next;
1000720c:	e0bffe17 	ldw	r2,-8(fp)
10007210:	10800017 	ldw	r2,0(r2)
10007214:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
10007218:	e13ffd17 	ldw	r4,-12(fp)
1000721c:	00003e40 	call	100003e4 <strlen>
10007220:	10800044 	addi	r2,r2,1
10007224:	e0bffb15 	stw	r2,-20(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
10007228:	00000d06 	br	10007260 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
1000722c:	e0bffc17 	ldw	r2,-16(fp)
10007230:	11000217 	ldw	r4,8(r2)
10007234:	e1bffb17 	ldw	r6,-20(fp)
10007238:	e17ffd17 	ldw	r5,-12(fp)
1000723c:	00088680 	call	10008868 <memcmp>
10007240:	1004c03a 	cmpne	r2,r2,zero
10007244:	1000031e 	bne	r2,zero,10007254 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
10007248:	e0bffc17 	ldw	r2,-16(fp)
1000724c:	e0bfff15 	stw	r2,-4(fp)
10007250:	00000706 	br	10007270 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
10007254:	e0bffc17 	ldw	r2,-16(fp)
10007258:	10800017 	ldw	r2,0(r2)
1000725c:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
10007260:	e0fffe17 	ldw	r3,-8(fp)
10007264:	e0bffc17 	ldw	r2,-16(fp)
10007268:	10fff01e 	bne	r2,r3,1000722c <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
1000726c:	e03fff15 	stw	zero,-4(fp)
10007270:	e0bfff17 	ldw	r2,-4(fp)
}
10007274:	e037883a 	mov	sp,fp
10007278:	dfc00117 	ldw	ra,4(sp)
1000727c:	df000017 	ldw	fp,0(sp)
10007280:	dec00204 	addi	sp,sp,8
10007284:	f800283a 	ret

10007288 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
10007288:	defffb04 	addi	sp,sp,-20
1000728c:	dfc00415 	stw	ra,16(sp)
10007290:	df000315 	stw	fp,12(sp)
10007294:	df000304 	addi	fp,sp,12
10007298:	e13ffe15 	stw	r4,-8(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
1000729c:	e13ffe17 	ldw	r4,-8(fp)
100072a0:	d1600d04 	addi	r5,gp,-32716
100072a4:	00071f40 	call	100071f4 <alt_find_dev>
100072a8:	e0bffd15 	stw	r2,-12(fp)

  if ((dev) && dev->open)
100072ac:	e0bffd17 	ldw	r2,-12(fp)
100072b0:	1005003a 	cmpeq	r2,r2,zero
100072b4:	10000b1e 	bne	r2,zero,100072e4 <alt_flash_open_dev+0x5c>
100072b8:	e0bffd17 	ldw	r2,-12(fp)
100072bc:	10800317 	ldw	r2,12(r2)
100072c0:	1005003a 	cmpeq	r2,r2,zero
100072c4:	1000071e 	bne	r2,zero,100072e4 <alt_flash_open_dev+0x5c>
  {
    return dev->open(dev, name);
100072c8:	e0bffd17 	ldw	r2,-12(fp)
100072cc:	10800317 	ldw	r2,12(r2)
100072d0:	e13ffd17 	ldw	r4,-12(fp)
100072d4:	e17ffe17 	ldw	r5,-8(fp)
100072d8:	103ee83a 	callr	r2
100072dc:	e0bfff15 	stw	r2,-4(fp)
100072e0:	00000206 	br	100072ec <alt_flash_open_dev+0x64>
  }

  return dev;
100072e4:	e0bffd17 	ldw	r2,-12(fp)
100072e8:	e0bfff15 	stw	r2,-4(fp)
100072ec:	e0bfff17 	ldw	r2,-4(fp)
}
100072f0:	e037883a 	mov	sp,fp
100072f4:	dfc00117 	ldw	ra,4(sp)
100072f8:	df000017 	ldw	fp,0(sp)
100072fc:	dec00204 	addi	sp,sp,8
10007300:	f800283a 	ret

10007304 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
10007304:	defffd04 	addi	sp,sp,-12
10007308:	dfc00215 	stw	ra,8(sp)
1000730c:	df000115 	stw	fp,4(sp)
10007310:	df000104 	addi	fp,sp,4
10007314:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
10007318:	e0bfff17 	ldw	r2,-4(fp)
1000731c:	1005003a 	cmpeq	r2,r2,zero
10007320:	1000081e 	bne	r2,zero,10007344 <alt_flash_close_dev+0x40>
10007324:	e0bfff17 	ldw	r2,-4(fp)
10007328:	10800417 	ldw	r2,16(r2)
1000732c:	1005003a 	cmpeq	r2,r2,zero
10007330:	1000041e 	bne	r2,zero,10007344 <alt_flash_close_dev+0x40>
  {
    fd->close(fd);
10007334:	e0bfff17 	ldw	r2,-4(fp)
10007338:	10800417 	ldw	r2,16(r2)
1000733c:	e13fff17 	ldw	r4,-4(fp)
10007340:	103ee83a 	callr	r2
  }
  return;
}
10007344:	e037883a 	mov	sp,fp
10007348:	dfc00117 	ldw	ra,4(sp)
1000734c:	df000017 	ldw	fp,0(sp)
10007350:	dec00204 	addi	sp,sp,8
10007354:	f800283a 	ret

10007358 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
10007358:	defff904 	addi	sp,sp,-28
1000735c:	dfc00615 	stw	ra,24(sp)
10007360:	df000515 	stw	fp,20(sp)
10007364:	df000504 	addi	fp,sp,20
10007368:	e13ffc15 	stw	r4,-16(fp)
1000736c:	e17ffd15 	stw	r5,-12(fp)
10007370:	e1bffe15 	stw	r6,-8(fp)
10007374:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
10007378:	e0800217 	ldw	r2,8(fp)
1000737c:	d8800015 	stw	r2,0(sp)
10007380:	e13ffc17 	ldw	r4,-16(fp)
10007384:	e17ffd17 	ldw	r5,-12(fp)
10007388:	e1bffe17 	ldw	r6,-8(fp)
1000738c:	e1ffff17 	ldw	r7,-4(fp)
10007390:	000752c0 	call	1000752c <alt_iic_isr_register>
}  
10007394:	e037883a 	mov	sp,fp
10007398:	dfc00117 	ldw	ra,4(sp)
1000739c:	df000017 	ldw	fp,0(sp)
100073a0:	dec00204 	addi	sp,sp,8
100073a4:	f800283a 	ret

100073a8 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
100073a8:	defff904 	addi	sp,sp,-28
100073ac:	df000615 	stw	fp,24(sp)
100073b0:	df000604 	addi	fp,sp,24
100073b4:	e13ffe15 	stw	r4,-8(fp)
100073b8:	e17fff15 	stw	r5,-4(fp)
100073bc:	e0bfff17 	ldw	r2,-4(fp)
100073c0:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
100073c4:	0005303a 	rdctl	r2,status
100073c8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
100073cc:	e0fffb17 	ldw	r3,-20(fp)
100073d0:	00bfff84 	movi	r2,-2
100073d4:	1884703a 	and	r2,r3,r2
100073d8:	1001703a 	wrctl	status,r2
  
  return context;
100073dc:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
100073e0:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
100073e4:	e0fffc17 	ldw	r3,-16(fp)
100073e8:	00800044 	movi	r2,1
100073ec:	10c4983a 	sll	r2,r2,r3
100073f0:	1007883a 	mov	r3,r2
100073f4:	00840074 	movhi	r2,4097
100073f8:	10aa2704 	addi	r2,r2,-22372
100073fc:	10800017 	ldw	r2,0(r2)
10007400:	1886b03a 	or	r3,r3,r2
10007404:	00840074 	movhi	r2,4097
10007408:	10aa2704 	addi	r2,r2,-22372
1000740c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
10007410:	00840074 	movhi	r2,4097
10007414:	10aa2704 	addi	r2,r2,-22372
10007418:	10800017 	ldw	r2,0(r2)
1000741c:	100170fa 	wrctl	ienable,r2
10007420:	e0bffd17 	ldw	r2,-12(fp)
10007424:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10007428:	e0bffa17 	ldw	r2,-24(fp)
1000742c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
10007430:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
10007434:	e037883a 	mov	sp,fp
10007438:	df000017 	ldw	fp,0(sp)
1000743c:	dec00104 	addi	sp,sp,4
10007440:	f800283a 	ret

10007444 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
10007444:	defff904 	addi	sp,sp,-28
10007448:	df000615 	stw	fp,24(sp)
1000744c:	df000604 	addi	fp,sp,24
10007450:	e13ffe15 	stw	r4,-8(fp)
10007454:	e17fff15 	stw	r5,-4(fp)
10007458:	e0bfff17 	ldw	r2,-4(fp)
1000745c:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10007460:	0005303a 	rdctl	r2,status
10007464:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10007468:	e0fffb17 	ldw	r3,-20(fp)
1000746c:	00bfff84 	movi	r2,-2
10007470:	1884703a 	and	r2,r3,r2
10007474:	1001703a 	wrctl	status,r2
  
  return context;
10007478:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
1000747c:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active &= ~(1 << id);
10007480:	e0fffc17 	ldw	r3,-16(fp)
10007484:	00800044 	movi	r2,1
10007488:	10c4983a 	sll	r2,r2,r3
1000748c:	0084303a 	nor	r2,zero,r2
10007490:	1007883a 	mov	r3,r2
10007494:	00840074 	movhi	r2,4097
10007498:	10aa2704 	addi	r2,r2,-22372
1000749c:	10800017 	ldw	r2,0(r2)
100074a0:	1886703a 	and	r3,r3,r2
100074a4:	00840074 	movhi	r2,4097
100074a8:	10aa2704 	addi	r2,r2,-22372
100074ac:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
100074b0:	00840074 	movhi	r2,4097
100074b4:	10aa2704 	addi	r2,r2,-22372
100074b8:	10800017 	ldw	r2,0(r2)
100074bc:	100170fa 	wrctl	ienable,r2
100074c0:	e0bffd17 	ldw	r2,-12(fp)
100074c4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
100074c8:	e0bffa17 	ldw	r2,-24(fp)
100074cc:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
100074d0:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
100074d4:	e037883a 	mov	sp,fp
100074d8:	df000017 	ldw	fp,0(sp)
100074dc:	dec00104 	addi	sp,sp,4
100074e0:	f800283a 	ret

100074e4 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
100074e4:	defffc04 	addi	sp,sp,-16
100074e8:	df000315 	stw	fp,12(sp)
100074ec:	df000304 	addi	fp,sp,12
100074f0:	e13ffe15 	stw	r4,-8(fp)
100074f4:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
100074f8:	000530fa 	rdctl	r2,ienable
100074fc:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
10007500:	e0ffff17 	ldw	r3,-4(fp)
10007504:	00800044 	movi	r2,1
10007508:	10c4983a 	sll	r2,r2,r3
1000750c:	1007883a 	mov	r3,r2
10007510:	e0bffd17 	ldw	r2,-12(fp)
10007514:	1884703a 	and	r2,r3,r2
10007518:	1004c03a 	cmpne	r2,r2,zero
}
1000751c:	e037883a 	mov	sp,fp
10007520:	df000017 	ldw	fp,0(sp)
10007524:	dec00104 	addi	sp,sp,4
10007528:	f800283a 	ret

1000752c <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
1000752c:	defff404 	addi	sp,sp,-48
10007530:	dfc00b15 	stw	ra,44(sp)
10007534:	df000a15 	stw	fp,40(sp)
10007538:	df000a04 	addi	fp,sp,40
1000753c:	e13ffb15 	stw	r4,-20(fp)
10007540:	e17ffc15 	stw	r5,-16(fp)
10007544:	e1bffd15 	stw	r6,-12(fp)
10007548:	e1fffe15 	stw	r7,-8(fp)
  int rc = -EINVAL;  
1000754c:	00bffa84 	movi	r2,-22
10007550:	e0bffa15 	stw	r2,-24(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
10007554:	e0bffc17 	ldw	r2,-16(fp)
10007558:	e0bff915 	stw	r2,-28(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
1000755c:	e0bff917 	ldw	r2,-28(fp)
10007560:	10800808 	cmpgei	r2,r2,32
10007564:	1000291e 	bne	r2,zero,1000760c <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10007568:	0005303a 	rdctl	r2,status
1000756c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10007570:	e0fff717 	ldw	r3,-36(fp)
10007574:	00bfff84 	movi	r2,-2
10007578:	1884703a 	and	r2,r3,r2
1000757c:	1001703a 	wrctl	status,r2
  
  return context;
10007580:	e0bff717 	ldw	r2,-36(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
10007584:	e0bff815 	stw	r2,-32(fp)

    alt_irq[id].handler = isr;
10007588:	e0bff917 	ldw	r2,-28(fp)
1000758c:	00c40074 	movhi	r3,4097
10007590:	18ea3404 	addi	r3,r3,-22320
10007594:	100490fa 	slli	r2,r2,3
10007598:	10c7883a 	add	r3,r2,r3
1000759c:	e0bffd17 	ldw	r2,-12(fp)
100075a0:	18800015 	stw	r2,0(r3)
    alt_irq[id].context = isr_context;
100075a4:	e0bff917 	ldw	r2,-28(fp)
100075a8:	00c40074 	movhi	r3,4097
100075ac:	18ea3404 	addi	r3,r3,-22320
100075b0:	100490fa 	slli	r2,r2,3
100075b4:	10c5883a 	add	r2,r2,r3
100075b8:	10c00104 	addi	r3,r2,4
100075bc:	e0bffe17 	ldw	r2,-8(fp)
100075c0:	18800015 	stw	r2,0(r3)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
100075c4:	e0bffd17 	ldw	r2,-12(fp)
100075c8:	1005003a 	cmpeq	r2,r2,zero
100075cc:	1000051e 	bne	r2,zero,100075e4 <alt_iic_isr_register+0xb8>
100075d0:	e17ff917 	ldw	r5,-28(fp)
100075d4:	e13ffb17 	ldw	r4,-20(fp)
100075d8:	00073a80 	call	100073a8 <alt_ic_irq_enable>
100075dc:	e0bfff15 	stw	r2,-4(fp)
100075e0:	00000406 	br	100075f4 <alt_iic_isr_register+0xc8>
100075e4:	e17ff917 	ldw	r5,-28(fp)
100075e8:	e13ffb17 	ldw	r4,-20(fp)
100075ec:	00074440 	call	10007444 <alt_ic_irq_disable>
100075f0:	e0bfff15 	stw	r2,-4(fp)
100075f4:	e0bfff17 	ldw	r2,-4(fp)
100075f8:	e0bffa15 	stw	r2,-24(fp)
100075fc:	e0bff817 	ldw	r2,-32(fp)
10007600:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10007604:	e0bff617 	ldw	r2,-40(fp)
10007608:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
1000760c:	e0bffa17 	ldw	r2,-24(fp)
}
10007610:	e037883a 	mov	sp,fp
10007614:	dfc00117 	ldw	ra,4(sp)
10007618:	df000017 	ldw	fp,0(sp)
1000761c:	dec00204 	addi	sp,sp,8
10007620:	f800283a 	ret

10007624 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
10007624:	defff904 	addi	sp,sp,-28
10007628:	dfc00615 	stw	ra,24(sp)
1000762c:	df000515 	stw	fp,20(sp)
10007630:	df000504 	addi	fp,sp,20
10007634:	e13ffc15 	stw	r4,-16(fp)
10007638:	e17ffd15 	stw	r5,-12(fp)
1000763c:	e1bffe15 	stw	r6,-8(fp)
10007640:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
10007644:	e13ffd17 	ldw	r4,-12(fp)
10007648:	e17ffe17 	ldw	r5,-8(fp)
1000764c:	e1bfff17 	ldw	r6,-4(fp)
10007650:	000783c0 	call	1000783c <open>
10007654:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
10007658:	e0bffb17 	ldw	r2,-20(fp)
1000765c:	1004803a 	cmplt	r2,r2,zero
10007660:	10001c1e 	bne	r2,zero,100076d4 <alt_open_fd+0xb0>
  {
    fd->dev      = alt_fd_list[old].dev;
10007664:	e0bffb17 	ldw	r2,-20(fp)
10007668:	00c40074 	movhi	r3,4097
1000766c:	18e54804 	addi	r3,r3,-27360
10007670:	10800324 	muli	r2,r2,12
10007674:	10c5883a 	add	r2,r2,r3
10007678:	10c00017 	ldw	r3,0(r2)
1000767c:	e0bffc17 	ldw	r2,-16(fp)
10007680:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
10007684:	e0bffb17 	ldw	r2,-20(fp)
10007688:	00c40074 	movhi	r3,4097
1000768c:	18e54804 	addi	r3,r3,-27360
10007690:	10800324 	muli	r2,r2,12
10007694:	10c5883a 	add	r2,r2,r3
10007698:	10800104 	addi	r2,r2,4
1000769c:	10c00017 	ldw	r3,0(r2)
100076a0:	e0bffc17 	ldw	r2,-16(fp)
100076a4:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
100076a8:	e0bffb17 	ldw	r2,-20(fp)
100076ac:	00c40074 	movhi	r3,4097
100076b0:	18e54804 	addi	r3,r3,-27360
100076b4:	10800324 	muli	r2,r2,12
100076b8:	10c5883a 	add	r2,r2,r3
100076bc:	10800204 	addi	r2,r2,8
100076c0:	10c00017 	ldw	r3,0(r2)
100076c4:	e0bffc17 	ldw	r2,-16(fp)
100076c8:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
100076cc:	e13ffb17 	ldw	r4,-20(fp)
100076d0:	00033980 	call	10003398 <alt_release_fd>
  }
} 
100076d4:	e037883a 	mov	sp,fp
100076d8:	dfc00117 	ldw	ra,4(sp)
100076dc:	df000017 	ldw	fp,0(sp)
100076e0:	dec00204 	addi	sp,sp,8
100076e4:	f800283a 	ret

100076e8 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
100076e8:	defffb04 	addi	sp,sp,-20
100076ec:	dfc00415 	stw	ra,16(sp)
100076f0:	df000315 	stw	fp,12(sp)
100076f4:	df000304 	addi	fp,sp,12
100076f8:	e13ffd15 	stw	r4,-12(fp)
100076fc:	e17ffe15 	stw	r5,-8(fp)
10007700:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
10007704:	01040074 	movhi	r4,4097
10007708:	21254b04 	addi	r4,r4,-27348
1000770c:	e17ffd17 	ldw	r5,-12(fp)
10007710:	01800044 	movi	r6,1
10007714:	01c07fc4 	movi	r7,511
10007718:	00076240 	call	10007624 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
1000771c:	01040074 	movhi	r4,4097
10007720:	21254804 	addi	r4,r4,-27360
10007724:	e17ffe17 	ldw	r5,-8(fp)
10007728:	000d883a 	mov	r6,zero
1000772c:	01c07fc4 	movi	r7,511
10007730:	00076240 	call	10007624 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
10007734:	01040074 	movhi	r4,4097
10007738:	21254e04 	addi	r4,r4,-27336
1000773c:	e17fff17 	ldw	r5,-4(fp)
10007740:	01800044 	movi	r6,1
10007744:	01c07fc4 	movi	r7,511
10007748:	00076240 	call	10007624 <alt_open_fd>
}  
1000774c:	e037883a 	mov	sp,fp
10007750:	dfc00117 	ldw	ra,4(sp)
10007754:	df000017 	ldw	fp,0(sp)
10007758:	dec00204 	addi	sp,sp,8
1000775c:	f800283a 	ret

10007760 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
10007760:	defffc04 	addi	sp,sp,-16
10007764:	df000315 	stw	fp,12(sp)
10007768:	df000304 	addi	fp,sp,12
1000776c:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
10007770:	e0bffe17 	ldw	r2,-8(fp)
10007774:	10800217 	ldw	r2,8(r2)
10007778:	10d00034 	orhi	r3,r2,16384
1000777c:	e0bffe17 	ldw	r2,-8(fp)
10007780:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
10007784:	e03ffd15 	stw	zero,-12(fp)
10007788:	00002006 	br	1000780c <alt_file_locked+0xac>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
1000778c:	e0bffd17 	ldw	r2,-12(fp)
10007790:	00c40074 	movhi	r3,4097
10007794:	18e54804 	addi	r3,r3,-27360
10007798:	10800324 	muli	r2,r2,12
1000779c:	10c5883a 	add	r2,r2,r3
100077a0:	10c00017 	ldw	r3,0(r2)
100077a4:	e0bffe17 	ldw	r2,-8(fp)
100077a8:	10800017 	ldw	r2,0(r2)
100077ac:	1880141e 	bne	r3,r2,10007800 <alt_file_locked+0xa0>
100077b0:	e0bffd17 	ldw	r2,-12(fp)
100077b4:	00c40074 	movhi	r3,4097
100077b8:	18e54804 	addi	r3,r3,-27360
100077bc:	10800324 	muli	r2,r2,12
100077c0:	10c5883a 	add	r2,r2,r3
100077c4:	10800204 	addi	r2,r2,8
100077c8:	10800017 	ldw	r2,0(r2)
100077cc:	1004403a 	cmpge	r2,r2,zero
100077d0:	10000b1e 	bne	r2,zero,10007800 <alt_file_locked+0xa0>
100077d4:	e0bffd17 	ldw	r2,-12(fp)
100077d8:	10800324 	muli	r2,r2,12
100077dc:	1007883a 	mov	r3,r2
100077e0:	00840074 	movhi	r2,4097
100077e4:	10a54804 	addi	r2,r2,-27360
100077e8:	1887883a 	add	r3,r3,r2
100077ec:	e0bffe17 	ldw	r2,-8(fp)
100077f0:	18800326 	beq	r3,r2,10007800 <alt_file_locked+0xa0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
100077f4:	00bffcc4 	movi	r2,-13
100077f8:	e0bfff15 	stw	r2,-4(fp)
100077fc:	00000a06 	br	10007828 <alt_file_locked+0xc8>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
10007800:	e0bffd17 	ldw	r2,-12(fp)
10007804:	10800044 	addi	r2,r2,1
10007808:	e0bffd15 	stw	r2,-12(fp)
1000780c:	00840074 	movhi	r2,4097
10007810:	10aa1604 	addi	r2,r2,-22440
10007814:	10800017 	ldw	r2,0(r2)
10007818:	1007883a 	mov	r3,r2
1000781c:	e0bffd17 	ldw	r2,-12(fp)
10007820:	18bfda2e 	bgeu	r3,r2,1000778c <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
10007824:	e03fff15 	stw	zero,-4(fp)
10007828:	e0bfff17 	ldw	r2,-4(fp)
}
1000782c:	e037883a 	mov	sp,fp
10007830:	df000017 	ldw	fp,0(sp)
10007834:	dec00104 	addi	sp,sp,4
10007838:	f800283a 	ret

1000783c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
1000783c:	defff404 	addi	sp,sp,-48
10007840:	dfc00b15 	stw	ra,44(sp)
10007844:	df000a15 	stw	fp,40(sp)
10007848:	df000a04 	addi	fp,sp,40
1000784c:	e13ffb15 	stw	r4,-20(fp)
10007850:	e17ffc15 	stw	r5,-16(fp)
10007854:	e1bffd15 	stw	r6,-12(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
10007858:	00bfffc4 	movi	r2,-1
1000785c:	e0bff815 	stw	r2,-32(fp)
  int status = -ENODEV;
10007860:	00bffb44 	movi	r2,-19
10007864:	e0bff715 	stw	r2,-36(fp)
  int isafs = 0;
10007868:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
1000786c:	e13ffb17 	ldw	r4,-20(fp)
10007870:	01440074 	movhi	r5,4097
10007874:	296a1404 	addi	r5,r5,-22448
10007878:	00071f40 	call	100071f4 <alt_find_dev>
1000787c:	e0bffa15 	stw	r2,-24(fp)
10007880:	e0bffa17 	ldw	r2,-24(fp)
10007884:	1004c03a 	cmpne	r2,r2,zero
10007888:	1000051e 	bne	r2,zero,100078a0 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
1000788c:	e13ffb17 	ldw	r4,-20(fp)
10007890:	00084e80 	call	100084e8 <alt_find_file>
10007894:	e0bffa15 	stw	r2,-24(fp)
    isafs = 1;
10007898:	00800044 	movi	r2,1
1000789c:	e0bff615 	stw	r2,-40(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
100078a0:	e0bffa17 	ldw	r2,-24(fp)
100078a4:	1005003a 	cmpeq	r2,r2,zero
100078a8:	1000301e 	bne	r2,zero,1000796c <open+0x130>
  {
    if ((index = alt_get_fd (dev)) < 0)
100078ac:	e13ffa17 	ldw	r4,-24(fp)
100078b0:	00086080 	call	10008608 <alt_get_fd>
100078b4:	e0bff815 	stw	r2,-32(fp)
100078b8:	e0bff817 	ldw	r2,-32(fp)
100078bc:	1004403a 	cmpge	r2,r2,zero
100078c0:	1000031e 	bne	r2,zero,100078d0 <open+0x94>
    {
      status = index;
100078c4:	e0bff817 	ldw	r2,-32(fp)
100078c8:	e0bff715 	stw	r2,-36(fp)
100078cc:	00002906 	br	10007974 <open+0x138>
    }
    else
    {
      fd = &alt_fd_list[index];
100078d0:	e0bff817 	ldw	r2,-32(fp)
100078d4:	10800324 	muli	r2,r2,12
100078d8:	1007883a 	mov	r3,r2
100078dc:	00840074 	movhi	r2,4097
100078e0:	10a54804 	addi	r2,r2,-27360
100078e4:	1885883a 	add	r2,r3,r2
100078e8:	e0bff915 	stw	r2,-28(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
100078ec:	e0fffc17 	ldw	r3,-16(fp)
100078f0:	00900034 	movhi	r2,16384
100078f4:	10bfffc4 	addi	r2,r2,-1
100078f8:	1886703a 	and	r3,r3,r2
100078fc:	e0bff917 	ldw	r2,-28(fp)
10007900:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
10007904:	e0bff617 	ldw	r2,-40(fp)
10007908:	1004c03a 	cmpne	r2,r2,zero
1000790c:	1000061e 	bne	r2,zero,10007928 <open+0xec>
10007910:	e13ff917 	ldw	r4,-28(fp)
10007914:	00077600 	call	10007760 <alt_file_locked>
10007918:	e0bff715 	stw	r2,-36(fp)
1000791c:	e0bff717 	ldw	r2,-36(fp)
10007920:	1004803a 	cmplt	r2,r2,zero
10007924:	1000131e 	bne	r2,zero,10007974 <open+0x138>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
10007928:	e0bffa17 	ldw	r2,-24(fp)
1000792c:	10800317 	ldw	r2,12(r2)
10007930:	1005003a 	cmpeq	r2,r2,zero
10007934:	1000091e 	bne	r2,zero,1000795c <open+0x120>
10007938:	e0bffa17 	ldw	r2,-24(fp)
1000793c:	10800317 	ldw	r2,12(r2)
10007940:	e13ff917 	ldw	r4,-28(fp)
10007944:	e17ffb17 	ldw	r5,-20(fp)
10007948:	e1bffc17 	ldw	r6,-16(fp)
1000794c:	e1fffd17 	ldw	r7,-12(fp)
10007950:	103ee83a 	callr	r2
10007954:	e0bfff15 	stw	r2,-4(fp)
10007958:	00000106 	br	10007960 <open+0x124>
1000795c:	e03fff15 	stw	zero,-4(fp)
10007960:	e0bfff17 	ldw	r2,-4(fp)
10007964:	e0bff715 	stw	r2,-36(fp)
10007968:	00000206 	br	10007974 <open+0x138>
      }
    }
  }
  else
  {
    status = -ENODEV;
1000796c:	00bffb44 	movi	r2,-19
10007970:	e0bff715 	stw	r2,-36(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
10007974:	e0bff717 	ldw	r2,-36(fp)
10007978:	1004403a 	cmpge	r2,r2,zero
1000797c:	1000091e 	bne	r2,zero,100079a4 <open+0x168>
  {
    alt_release_fd (index);  
10007980:	e13ff817 	ldw	r4,-32(fp)
10007984:	00033980 	call	10003398 <alt_release_fd>
    ALT_ERRNO = -status;
10007988:	00079c40 	call	100079c4 <alt_get_errno>
1000798c:	e0fff717 	ldw	r3,-36(fp)
10007990:	00c7c83a 	sub	r3,zero,r3
10007994:	10c00015 	stw	r3,0(r2)
    return -1;
10007998:	00bfffc4 	movi	r2,-1
1000799c:	e0bffe15 	stw	r2,-8(fp)
100079a0:	00000206 	br	100079ac <open+0x170>
  }
  
  /* return the reference upon success */

  return index;
100079a4:	e0bff817 	ldw	r2,-32(fp)
100079a8:	e0bffe15 	stw	r2,-8(fp)
100079ac:	e0bffe17 	ldw	r2,-8(fp)
}
100079b0:	e037883a 	mov	sp,fp
100079b4:	dfc00117 	ldw	ra,4(sp)
100079b8:	df000017 	ldw	fp,0(sp)
100079bc:	dec00204 	addi	sp,sp,8
100079c0:	f800283a 	ret

100079c4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
100079c4:	defffd04 	addi	sp,sp,-12
100079c8:	dfc00215 	stw	ra,8(sp)
100079cc:	df000115 	stw	fp,4(sp)
100079d0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
100079d4:	00840074 	movhi	r2,4097
100079d8:	10aa1704 	addi	r2,r2,-22436
100079dc:	10800017 	ldw	r2,0(r2)
100079e0:	1005003a 	cmpeq	r2,r2,zero
100079e4:	1000061e 	bne	r2,zero,10007a00 <alt_get_errno+0x3c>
100079e8:	00840074 	movhi	r2,4097
100079ec:	10aa1704 	addi	r2,r2,-22436
100079f0:	10800017 	ldw	r2,0(r2)
100079f4:	103ee83a 	callr	r2
100079f8:	e0bfff15 	stw	r2,-4(fp)
100079fc:	00000306 	br	10007a0c <alt_get_errno+0x48>
10007a00:	00840074 	movhi	r2,4097
10007a04:	10aa2304 	addi	r2,r2,-22388
10007a08:	e0bfff15 	stw	r2,-4(fp)
10007a0c:	e0bfff17 	ldw	r2,-4(fp)
}
10007a10:	e037883a 	mov	sp,fp
10007a14:	dfc00117 	ldw	ra,4(sp)
10007a18:	df000017 	ldw	fp,0(sp)
10007a1c:	dec00204 	addi	sp,sp,8
10007a20:	f800283a 	ret

10007a24 <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
10007a24:	defffc04 	addi	sp,sp,-16
10007a28:	dfc00315 	stw	ra,12(sp)
10007a2c:	df000215 	stw	fp,8(sp)
10007a30:	df000204 	addi	fp,sp,8
10007a34:	e13ffe15 	stw	r4,-8(fp)
10007a38:	e17fff15 	stw	r5,-4(fp)
  alt_dcache_flush (ptr, len);
10007a3c:	e13ffe17 	ldw	r4,-8(fp)
10007a40:	e17fff17 	ldw	r5,-4(fp)
10007a44:	0006fa00 	call	10006fa0 <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
10007a48:	e0bffe17 	ldw	r2,-8(fp)
10007a4c:	10a00034 	orhi	r2,r2,32768
}
10007a50:	e037883a 	mov	sp,fp
10007a54:	dfc00117 	ldw	ra,4(sp)
10007a58:	df000017 	ldw	fp,0(sp)
10007a5c:	dec00204 	addi	sp,sp,8
10007a60:	f800283a 	ret

10007a64 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
10007a64:	defffa04 	addi	sp,sp,-24
10007a68:	df000515 	stw	fp,20(sp)
10007a6c:	df000504 	addi	fp,sp,20
10007a70:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10007a74:	0005303a 	rdctl	r2,status
10007a78:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10007a7c:	e0fffd17 	ldw	r3,-12(fp)
10007a80:	00bfff84 	movi	r2,-2
10007a84:	1884703a 	and	r2,r3,r2
10007a88:	1001703a 	wrctl	status,r2
  
  return context;
10007a8c:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
10007a90:	e0bffe15 	stw	r2,-8(fp)
  alt_llist_remove (&alarm->llist);
10007a94:	e0bfff17 	ldw	r2,-4(fp)
10007a98:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
10007a9c:	e0bffc17 	ldw	r2,-16(fp)
10007aa0:	10c00017 	ldw	r3,0(r2)
10007aa4:	e0bffc17 	ldw	r2,-16(fp)
10007aa8:	10800117 	ldw	r2,4(r2)
10007aac:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
10007ab0:	e0bffc17 	ldw	r2,-16(fp)
10007ab4:	10c00117 	ldw	r3,4(r2)
10007ab8:	e0bffc17 	ldw	r2,-16(fp)
10007abc:	10800017 	ldw	r2,0(r2)
10007ac0:	18800015 	stw	r2,0(r3)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
10007ac4:	e0fffc17 	ldw	r3,-16(fp)
10007ac8:	e0bffc17 	ldw	r2,-16(fp)
10007acc:	18800115 	stw	r2,4(r3)
  entry->next     = entry;
10007ad0:	e0fffc17 	ldw	r3,-16(fp)
10007ad4:	e0bffc17 	ldw	r2,-16(fp)
10007ad8:	18800015 	stw	r2,0(r3)
10007adc:	e0bffe17 	ldw	r2,-8(fp)
10007ae0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10007ae4:	e0bffb17 	ldw	r2,-20(fp)
10007ae8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
10007aec:	e037883a 	mov	sp,fp
10007af0:	df000017 	ldw	fp,0(sp)
10007af4:	dec00104 	addi	sp,sp,4
10007af8:	f800283a 	ret

10007afc <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
10007afc:	defffb04 	addi	sp,sp,-20
10007b00:	dfc00415 	stw	ra,16(sp)
10007b04:	df000315 	stw	fp,12(sp)
10007b08:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
10007b0c:	d0a01017 	ldw	r2,-32704(gp)
10007b10:	e0bffe15 	stw	r2,-8(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
10007b14:	d0a01b17 	ldw	r2,-32660(gp)
10007b18:	10800044 	addi	r2,r2,1
10007b1c:	d0a01b15 	stw	r2,-32660(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
10007b20:	00003106 	br	10007be8 <alt_tick+0xec>
  {
    next = (alt_alarm*) alarm->llist.next;
10007b24:	e0bffe17 	ldw	r2,-8(fp)
10007b28:	10800017 	ldw	r2,0(r2)
10007b2c:	e0bfff15 	stw	r2,-4(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
10007b30:	e0bffe17 	ldw	r2,-8(fp)
10007b34:	10800403 	ldbu	r2,16(r2)
10007b38:	10803fcc 	andi	r2,r2,255
10007b3c:	1005003a 	cmpeq	r2,r2,zero
10007b40:	1000051e 	bne	r2,zero,10007b58 <alt_tick+0x5c>
10007b44:	d0a01b17 	ldw	r2,-32660(gp)
10007b48:	1004c03a 	cmpne	r2,r2,zero
10007b4c:	1000021e 	bne	r2,zero,10007b58 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
10007b50:	e0bffe17 	ldw	r2,-8(fp)
10007b54:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
10007b58:	e0bffe17 	ldw	r2,-8(fp)
10007b5c:	10c00217 	ldw	r3,8(r2)
10007b60:	d0a01b17 	ldw	r2,-32660(gp)
10007b64:	10c01e36 	bltu	r2,r3,10007be0 <alt_tick+0xe4>
10007b68:	e0bffe17 	ldw	r2,-8(fp)
10007b6c:	10800403 	ldbu	r2,16(r2)
10007b70:	10803fcc 	andi	r2,r2,255
10007b74:	1004c03a 	cmpne	r2,r2,zero
10007b78:	1000191e 	bne	r2,zero,10007be0 <alt_tick+0xe4>
    {
      next_callback = alarm->callback (alarm->context);
10007b7c:	e0bffe17 	ldw	r2,-8(fp)
10007b80:	10c00317 	ldw	r3,12(r2)
10007b84:	e0bffe17 	ldw	r2,-8(fp)
10007b88:	11000517 	ldw	r4,20(r2)
10007b8c:	183ee83a 	callr	r3
10007b90:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
10007b94:	e0bffd17 	ldw	r2,-12(fp)
10007b98:	1004c03a 	cmpne	r2,r2,zero
10007b9c:	1000031e 	bne	r2,zero,10007bac <alt_tick+0xb0>
      {
        alt_alarm_stop (alarm);
10007ba0:	e13ffe17 	ldw	r4,-8(fp)
10007ba4:	0007a640 	call	10007a64 <alt_alarm_stop>
10007ba8:	00000d06 	br	10007be0 <alt_tick+0xe4>
      }
      else
      {
        alarm->time += next_callback;
10007bac:	e0bffe17 	ldw	r2,-8(fp)
10007bb0:	10c00217 	ldw	r3,8(r2)
10007bb4:	e0bffd17 	ldw	r2,-12(fp)
10007bb8:	1887883a 	add	r3,r3,r2
10007bbc:	e0bffe17 	ldw	r2,-8(fp)
10007bc0:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
10007bc4:	e0bffe17 	ldw	r2,-8(fp)
10007bc8:	10c00217 	ldw	r3,8(r2)
10007bcc:	d0a01b17 	ldw	r2,-32660(gp)
10007bd0:	1880032e 	bgeu	r3,r2,10007be0 <alt_tick+0xe4>
        {
          alarm->rollover = 1;
10007bd4:	e0fffe17 	ldw	r3,-8(fp)
10007bd8:	00800044 	movi	r2,1
10007bdc:	18800405 	stb	r2,16(r3)
        }
      }
    }
    alarm = next;
10007be0:	e0bfff17 	ldw	r2,-4(fp)
10007be4:	e0bffe15 	stw	r2,-8(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
10007be8:	d0e01004 	addi	r3,gp,-32704
10007bec:	e0bffe17 	ldw	r2,-8(fp)
10007bf0:	10ffcc1e 	bne	r2,r3,10007b24 <alt_tick+0x28>
  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
}
10007bf4:	e037883a 	mov	sp,fp
10007bf8:	dfc00117 	ldw	ra,4(sp)
10007bfc:	df000017 	ldw	fp,0(sp)
10007c00:	dec00204 	addi	sp,sp,8
10007c04:	f800283a 	ret

10007c08 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
10007c08:	deffff04 	addi	sp,sp,-4
10007c0c:	df000015 	stw	fp,0(sp)
10007c10:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
10007c14:	000170fa 	wrctl	ienable,zero
}
10007c18:	e037883a 	mov	sp,fp
10007c1c:	df000017 	ldw	fp,0(sp)
10007c20:	dec00104 	addi	sp,sp,4
10007c24:	f800283a 	ret

10007c28 <alt_program_amd>:
 * then writes Addr, Data Addr, Data etc.
 */
int alt_program_amd(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
10007c28:	defff704 	addi	sp,sp,-36
10007c2c:	dfc00815 	stw	ra,32(sp)
10007c30:	df000715 	stw	fp,28(sp)
10007c34:	df000704 	addi	fp,sp,28
10007c38:	e13ffc15 	stw	r4,-16(fp)
10007c3c:	e17ffd15 	stw	r5,-12(fp)
10007c40:	e1bffe15 	stw	r6,-8(fp)
10007c44:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
10007c48:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
10007c4c:	e0bffc17 	ldw	r2,-16(fp)
10007c50:	e0bffa15 	stw	r2,-24(fp)
  
  
  ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
10007c54:	e1bfff17 	ldw	r6,-4(fp)
10007c58:	00840034 	movhi	r2,4096
10007c5c:	109ff304 	addi	r2,r2,32716
10007c60:	d8800015 	stw	r2,0(sp)
10007c64:	e13ffa17 	ldw	r4,-24(fp)
10007c68:	e17ffe17 	ldw	r5,-8(fp)
10007c6c:	e1c00217 	ldw	r7,8(fp)
10007c70:	0003d2c0 	call	10003d2c <alt_flash_program_block>
10007c74:	e0bffb15 	stw	r2,-20(fp)
                                    alt_write_word_amd);
  return ret_code;
10007c78:	e0bffb17 	ldw	r2,-20(fp)
}
10007c7c:	e037883a 	mov	sp,fp
10007c80:	dfc00117 	ldw	ra,4(sp)
10007c84:	df000017 	ldw	fp,0(sp)
10007c88:	dec00204 	addi	sp,sp,8
10007c8c:	f800283a 	ret

10007c90 <alt_erase_block_amd>:
 * alt_erase_block_amd
 * 
 * Erase the selected erase block
 */
int alt_erase_block_amd(alt_flash_dev* flash_info, int block_offset)
{
10007c90:	defff804 	addi	sp,sp,-32
10007c94:	dfc00715 	stw	ra,28(sp)
10007c98:	df000615 	stw	fp,24(sp)
10007c9c:	df000604 	addi	fp,sp,24
10007ca0:	e13ffe15 	stw	r4,-8(fp)
10007ca4:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
10007ca8:	e03ffc15 	stw	zero,-16(fp)
  int   timeout;
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
10007cac:	e0bffe17 	ldw	r2,-8(fp)
10007cb0:	e0bffa15 	stw	r2,-24(fp)
  volatile alt_u8  value;

  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
10007cb4:	e0bffa17 	ldw	r2,-24(fp)
10007cb8:	10c03317 	ldw	r3,204(r2)
10007cbc:	e0bffa17 	ldw	r2,-24(fp)
10007cc0:	11000a17 	ldw	r4,40(r2)
10007cc4:	01415544 	movi	r5,1365
10007cc8:	01802a84 	movi	r6,170
10007ccc:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
10007cd0:	e0bffa17 	ldw	r2,-24(fp)
10007cd4:	10c03317 	ldw	r3,204(r2)
10007cd8:	e0bffa17 	ldw	r2,-24(fp)
10007cdc:	11000a17 	ldw	r4,40(r2)
10007ce0:	0140aa84 	movi	r5,682
10007ce4:	01801544 	movi	r6,85
10007ce8:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0x80);
10007cec:	e0bffa17 	ldw	r2,-24(fp)
10007cf0:	10c03317 	ldw	r3,204(r2)
10007cf4:	e0bffa17 	ldw	r2,-24(fp)
10007cf8:	11000a17 	ldw	r4,40(r2)
10007cfc:	01415544 	movi	r5,1365
10007d00:	01802004 	movi	r6,128
10007d04:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
10007d08:	e0bffa17 	ldw	r2,-24(fp)
10007d0c:	10c03317 	ldw	r3,204(r2)
10007d10:	e0bffa17 	ldw	r2,-24(fp)
10007d14:	11000a17 	ldw	r4,40(r2)
10007d18:	01415544 	movi	r5,1365
10007d1c:	01802a84 	movi	r6,170
10007d20:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
10007d24:	e0bffa17 	ldw	r2,-24(fp)
10007d28:	10c03317 	ldw	r3,204(r2)
10007d2c:	e0bffa17 	ldw	r2,-24(fp)
10007d30:	11000a17 	ldw	r4,40(r2)
10007d34:	0140aa84 	movi	r5,682
10007d38:	01801544 	movi	r6,85
10007d3c:	183ee83a 	callr	r3

  (*flash->write_native)((alt_u8*)flash->dev.base_addr+block_offset, 0x30);
10007d40:	e0bffa17 	ldw	r2,-24(fp)
10007d44:	11803517 	ldw	r6,212(r2)
10007d48:	e0bffa17 	ldw	r2,-24(fp)
10007d4c:	10800a17 	ldw	r2,40(r2)
10007d50:	1007883a 	mov	r3,r2
10007d54:	e0bfff17 	ldw	r2,-4(fp)
10007d58:	1889883a 	add	r4,r3,r2
10007d5c:	01400c04 	movi	r5,48
10007d60:	303ee83a 	callr	r6

  /*
   * Delay to meet AM29LV065D timing requirements
   */
  usleep(10000);
10007d64:	0109c404 	movi	r4,10000
10007d68:	00086c00 	call	100086c0 <usleep>
  
  /*
   * Bit 3 indicates that the erase command has been accepted
   * this last 50S
   */
  timeout = 50;   
10007d6c:	00800c84 	movi	r2,50
10007d70:	e0bffb15 	stw	r2,-20(fp)
  do 
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
10007d74:	e0bffa17 	ldw	r2,-24(fp)
10007d78:	10800a17 	ldw	r2,40(r2)
10007d7c:	1007883a 	mov	r3,r2
10007d80:	e0bfff17 	ldw	r2,-4(fp)
10007d84:	1885883a 	add	r2,r3,r2
10007d88:	10800023 	ldbuio	r2,0(r2)
10007d8c:	e0bffd05 	stb	r2,-12(fp)
    usleep(1000);
10007d90:	0100fa04 	movi	r4,1000
10007d94:	00086c00 	call	100086c0 <usleep>
    timeout--;
10007d98:	e0bffb17 	ldw	r2,-20(fp)
10007d9c:	10bfffc4 	addi	r2,r2,-1
10007da0:	e0bffb15 	stw	r2,-20(fp)
  }while(!(value & 0x8) && (timeout > 0));
10007da4:	e0bffd03 	ldbu	r2,-12(fp)
10007da8:	10803fcc 	andi	r2,r2,255
10007dac:	1080020c 	andi	r2,r2,8
10007db0:	1004c03a 	cmpne	r2,r2,zero
10007db4:	1000031e 	bne	r2,zero,10007dc4 <alt_erase_block_amd+0x134>
10007db8:	e0bffb17 	ldw	r2,-20(fp)
10007dbc:	10800048 	cmpgei	r2,r2,1
10007dc0:	103fec1e 	bne	r2,zero,10007d74 <alt_erase_block_amd+0xe4>


  timeout = flash->erase_timeout;
10007dc4:	e0bffa17 	ldw	r2,-24(fp)
10007dc8:	10803117 	ldw	r2,196(r2)
10007dcc:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
10007dd0:	00001706 	br	10007e30 <alt_erase_block_amd+0x1a0>
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
10007dd4:	e0bffa17 	ldw	r2,-24(fp)
10007dd8:	10800a17 	ldw	r2,40(r2)
10007ddc:	1007883a 	mov	r3,r2
10007de0:	e0bfff17 	ldw	r2,-4(fp)
10007de4:	1885883a 	add	r2,r3,r2
10007de8:	10800023 	ldbuio	r2,0(r2)
10007dec:	e0bffd05 	stb	r2,-12(fp)
    if ((value & 0x80) || (value &0x20))
10007df0:	e0bffd03 	ldbu	r2,-12(fp)
10007df4:	10803fcc 	andi	r2,r2,255
10007df8:	1080201c 	xori	r2,r2,128
10007dfc:	10bfe004 	addi	r2,r2,-128
10007e00:	1004803a 	cmplt	r2,r2,zero
10007e04:	10000d1e 	bne	r2,zero,10007e3c <alt_erase_block_amd+0x1ac>
10007e08:	e0bffd03 	ldbu	r2,-12(fp)
10007e0c:	10803fcc 	andi	r2,r2,255
10007e10:	1080080c 	andi	r2,r2,32
10007e14:	1004c03a 	cmpne	r2,r2,zero
10007e18:	1000081e 	bne	r2,zero,10007e3c <alt_erase_block_amd+0x1ac>
    {
      break;
    }
    usleep(1000);
10007e1c:	0100fa04 	movi	r4,1000
10007e20:	00086c00 	call	100086c0 <usleep>
    timeout -= 1000;
10007e24:	e0bffb17 	ldw	r2,-20(fp)
10007e28:	10bf0604 	addi	r2,r2,-1000
10007e2c:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
10007e30:	e0bffb17 	ldw	r2,-20(fp)
10007e34:	10800048 	cmpgei	r2,r2,1
10007e38:	103fe61e 	bne	r2,zero,10007dd4 <alt_erase_block_amd+0x144>
    }
    usleep(1000);
    timeout -= 1000;
  }
  
  if (timeout <= 0)
10007e3c:	e0bffb17 	ldw	r2,-20(fp)
10007e40:	10800048 	cmpgei	r2,r2,1
10007e44:	1000031e 	bne	r2,zero,10007e54 <alt_erase_block_amd+0x1c4>
  {
    ret_code = -ETIMEDOUT;
10007e48:	00bfe304 	movi	r2,-116
10007e4c:	e0bffc15 	stw	r2,-16(fp)
10007e50:	00000f06 	br	10007e90 <alt_erase_block_amd+0x200>
  }
  else
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
10007e54:	e0bffa17 	ldw	r2,-24(fp)
10007e58:	10800a17 	ldw	r2,40(r2)
10007e5c:	1007883a 	mov	r3,r2
10007e60:	e0bfff17 	ldw	r2,-4(fp)
10007e64:	1885883a 	add	r2,r3,r2
10007e68:	10800023 	ldbuio	r2,0(r2)
10007e6c:	e0bffd05 	stb	r2,-12(fp)
    if (!(value & 0x80))
10007e70:	e0bffd03 	ldbu	r2,-12(fp)
10007e74:	10803fcc 	andi	r2,r2,255
10007e78:	1080201c 	xori	r2,r2,128
10007e7c:	10bfe004 	addi	r2,r2,-128
10007e80:	1004803a 	cmplt	r2,r2,zero
10007e84:	1000021e 	bne	r2,zero,10007e90 <alt_erase_block_amd+0x200>
    {
      ret_code = -EIO;
10007e88:	00bffec4 	movi	r2,-5
10007e8c:	e0bffc15 	stw	r2,-16(fp)
    }
  }    
  
  return ret_code;
10007e90:	e0bffc17 	ldw	r2,-16(fp)
}
10007e94:	e037883a 	mov	sp,fp
10007e98:	dfc00117 	ldw	ra,4(sp)
10007e9c:	df000017 	ldw	fp,0(sp)
10007ea0:	dec00204 	addi	sp,sp,8
10007ea4:	f800283a 	ret

10007ea8 <alt_wait_for_command_to_complete_amd>:
 */
 
int alt_wait_for_command_to_complete_amd(alt_flash_cfi_dev* flash,
                                         int offset, 
                                          alt_u8 data)
{
10007ea8:	defff804 	addi	sp,sp,-32
10007eac:	dfc00715 	stw	ra,28(sp)
10007eb0:	df000615 	stw	fp,24(sp)
10007eb4:	df000604 	addi	fp,sp,24
10007eb8:	e13ffd15 	stw	r4,-12(fp)
10007ebc:	e17ffe15 	stw	r5,-8(fp)
10007ec0:	e1bfff05 	stb	r6,-4(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
10007ec4:	e0bffd17 	ldw	r2,-12(fp)
10007ec8:	10803017 	ldw	r2,192(r2)
10007ecc:	10801924 	muli	r2,r2,100
10007ed0:	e0bffb15 	stw	r2,-20(fp)
  int ret_code = 0;
10007ed4:	e03ffa15 	stw	zero,-24(fp)
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
10007ed8:	e0bffd17 	ldw	r2,-12(fp)
10007edc:	10800a17 	ldw	r2,40(r2)
10007ee0:	1007883a 	mov	r3,r2
10007ee4:	e0bffe17 	ldw	r2,-8(fp)
10007ee8:	1885883a 	add	r2,r3,r2
10007eec:	10800023 	ldbuio	r2,0(r2)
10007ef0:	e0bffc05 	stb	r2,-16(fp)
  while (timeout > 0)
10007ef4:	00001706 	br	10007f54 <alt_wait_for_command_to_complete_amd+0xac>
  {
    if (((value & 0x80 ) == (data &0x80)) ||
10007ef8:	e0bffc03 	ldbu	r2,-16(fp)
10007efc:	10803fcc 	andi	r2,r2,255
10007f00:	10c0200c 	andi	r3,r2,128
10007f04:	e0bfff03 	ldbu	r2,-4(fp)
10007f08:	1080200c 	andi	r2,r2,128
10007f0c:	18801426 	beq	r3,r2,10007f60 <alt_wait_for_command_to_complete_amd+0xb8>
10007f10:	e0bffc03 	ldbu	r2,-16(fp)
10007f14:	10803fcc 	andi	r2,r2,255
10007f18:	1080080c 	andi	r2,r2,32
10007f1c:	1004c03a 	cmpne	r2,r2,zero
10007f20:	10000f1e 	bne	r2,zero,10007f60 <alt_wait_for_command_to_complete_amd+0xb8>
        (value & 0x20))
    {
      break;
    }
    usleep (1);
10007f24:	01000044 	movi	r4,1
10007f28:	00086c00 	call	100086c0 <usleep>
    timeout--;
10007f2c:	e0bffb17 	ldw	r2,-20(fp)
10007f30:	10bfffc4 	addi	r2,r2,-1
10007f34:	e0bffb15 	stw	r2,-20(fp)
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
10007f38:	e0bffd17 	ldw	r2,-12(fp)
10007f3c:	10800a17 	ldw	r2,40(r2)
10007f40:	1007883a 	mov	r3,r2
10007f44:	e0bffe17 	ldw	r2,-8(fp)
10007f48:	1885883a 	add	r2,r3,r2
10007f4c:	10800023 	ldbuio	r2,0(r2)
10007f50:	e0bffc05 	stb	r2,-16(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
  int ret_code = 0;
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
  while (timeout > 0)
10007f54:	e0bffb17 	ldw	r2,-20(fp)
10007f58:	10800048 	cmpgei	r2,r2,1
10007f5c:	103fe61e 	bne	r2,zero,10007ef8 <alt_wait_for_command_to_complete_amd+0x50>
    usleep (1);
    timeout--;
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
  }
  
  if (timeout == 0)
10007f60:	e0bffb17 	ldw	r2,-20(fp)
10007f64:	1004c03a 	cmpne	r2,r2,zero
10007f68:	1000031e 	bne	r2,zero,10007f78 <alt_wait_for_command_to_complete_amd+0xd0>
  {
    ret_code = -ETIMEDOUT;
10007f6c:	00bfe304 	movi	r2,-116
10007f70:	e0bffa15 	stw	r2,-24(fp)
10007f74:	00000f06 	br	10007fb4 <alt_wait_for_command_to_complete_amd+0x10c>
  }
  else
  {
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
10007f78:	e0bffd17 	ldw	r2,-12(fp)
10007f7c:	10800a17 	ldw	r2,40(r2)
10007f80:	1007883a 	mov	r3,r2
10007f84:	e0bffe17 	ldw	r2,-8(fp)
10007f88:	1885883a 	add	r2,r3,r2
10007f8c:	10800023 	ldbuio	r2,0(r2)
10007f90:	e0bffc05 	stb	r2,-16(fp)
    if ((value & 0x80) != (data&0x80))
10007f94:	e0bffc03 	ldbu	r2,-16(fp)
10007f98:	10803fcc 	andi	r2,r2,255
10007f9c:	10c0200c 	andi	r3,r2,128
10007fa0:	e0bfff03 	ldbu	r2,-4(fp)
10007fa4:	1080200c 	andi	r2,r2,128
10007fa8:	18800226 	beq	r3,r2,10007fb4 <alt_wait_for_command_to_complete_amd+0x10c>
    {
      ret_code = -EIO;
10007fac:	00bffec4 	movi	r2,-5
10007fb0:	e0bffa15 	stw	r2,-24(fp)
    }
  }    
  return ret_code;
10007fb4:	e0bffa17 	ldw	r2,-24(fp)
}
10007fb8:	e037883a 	mov	sp,fp
10007fbc:	dfc00117 	ldw	ra,4(sp)
10007fc0:	df000017 	ldw	fp,0(sp)
10007fc4:	dec00204 	addi	sp,sp,8
10007fc8:	f800283a 	ret

10007fcc <alt_write_word_amd>:

static int alt_write_word_amd(  alt_flash_cfi_dev* flash, 
                                const int offset, 
                                const alt_u8* src_addr)
{
10007fcc:	defff904 	addi	sp,sp,-28
10007fd0:	dfc00615 	stw	ra,24(sp)
10007fd4:	df000515 	stw	fp,20(sp)
10007fd8:	df000504 	addi	fp,sp,20
10007fdc:	e13ffd15 	stw	r4,-12(fp)
10007fe0:	e17ffe15 	stw	r5,-8(fp)
10007fe4:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
10007fe8:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 value;
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
10007fec:	e0bffd17 	ldw	r2,-12(fp)
10007ff0:	10c03317 	ldw	r3,204(r2)
10007ff4:	e0bffd17 	ldw	r2,-12(fp)
10007ff8:	11000a17 	ldw	r4,40(r2)
10007ffc:	01415544 	movi	r5,1365
10008000:	01802a84 	movi	r6,170
10008004:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
10008008:	e0bffd17 	ldw	r2,-12(fp)
1000800c:	10c03317 	ldw	r3,204(r2)
10008010:	e0bffd17 	ldw	r2,-12(fp)
10008014:	11000a17 	ldw	r4,40(r2)
10008018:	0140aa84 	movi	r5,682
1000801c:	01801544 	movi	r6,85
10008020:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xA0);
10008024:	e0bffd17 	ldw	r2,-12(fp)
10008028:	10c03317 	ldw	r3,204(r2)
1000802c:	e0bffd17 	ldw	r2,-12(fp)
10008030:	11000a17 	ldw	r4,40(r2)
10008034:	01415544 	movi	r5,1365
10008038:	01802804 	movi	r6,160
1000803c:	183ee83a 	callr	r3
  
  value = *src_addr;
10008040:	e0bfff17 	ldw	r2,-4(fp)
10008044:	10800003 	ldbu	r2,0(r2)
10008048:	e0bffb05 	stb	r2,-20(fp)

  alt_write_value_to_flash(flash, offset, src_addr);
1000804c:	e13ffd17 	ldw	r4,-12(fp)
10008050:	e17ffe17 	ldw	r5,-8(fp)
10008054:	e1bfff17 	ldw	r6,-4(fp)
10008058:	0003bc80 	call	10003bc8 <alt_write_value_to_flash>
  
  ret_code = alt_wait_for_command_to_complete_amd(flash, 
1000805c:	e1bffb03 	ldbu	r6,-20(fp)
10008060:	e13ffd17 	ldw	r4,-12(fp)
10008064:	e17ffe17 	ldw	r5,-8(fp)
10008068:	0007ea80 	call	10007ea8 <alt_wait_for_command_to_complete_amd>
1000806c:	e0bffc15 	stw	r2,-16(fp)
                                                  offset,
                                                  value);
  return ret_code;
10008070:	e0bffc17 	ldw	r2,-16(fp)
  
}
10008074:	e037883a 	mov	sp,fp
10008078:	dfc00117 	ldw	ra,4(sp)
1000807c:	df000017 	ldw	fp,0(sp)
10008080:	dec00204 	addi	sp,sp,8
10008084:	f800283a 	ret

10008088 <alt_program_intel>:
 * Program a block (or part of one)
 */
int alt_program_intel(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
10008088:	defff704 	addi	sp,sp,-36
1000808c:	dfc00815 	stw	ra,32(sp)
10008090:	df000715 	stw	fp,28(sp)
10008094:	df000704 	addi	fp,sp,28
10008098:	e13ffc15 	stw	r4,-16(fp)
1000809c:	e17ffd15 	stw	r5,-12(fp)
100080a0:	e1bffe15 	stw	r6,-8(fp)
100080a4:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
100080a8:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
100080ac:	e0bffc17 	ldw	r2,-16(fp)
100080b0:	e0bffa15 	stw	r2,-24(fp)
  
   /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
100080b4:	e13ffa17 	ldw	r4,-24(fp)
100080b8:	e17ffd17 	ldw	r5,-12(fp)
100080bc:	00082800 	call	10008280 <alt_unlock_block_intel>
100080c0:	e0bffb15 	stw	r2,-20(fp)

  if (!ret_code)
100080c4:	e0bffb17 	ldw	r2,-20(fp)
100080c8:	1004c03a 	cmpne	r2,r2,zero
100080cc:	1000091e 	bne	r2,zero,100080f4 <alt_program_intel+0x6c>
  {

    ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
100080d0:	e1bfff17 	ldw	r6,-4(fp)
100080d4:	00840074 	movhi	r2,4097
100080d8:	10a10304 	addi	r2,r2,-31732
100080dc:	d8800015 	stw	r2,0(sp)
100080e0:	e13ffa17 	ldw	r4,-24(fp)
100080e4:	e17ffe17 	ldw	r5,-8(fp)
100080e8:	e1c00217 	ldw	r7,8(fp)
100080ec:	0003d2c0 	call	10003d2c <alt_flash_program_block>
100080f0:	e0bffb15 	stw	r2,-20(fp)
                                        alt_write_word_intel);
  }
  
  return ret_code;
100080f4:	e0bffb17 	ldw	r2,-20(fp)
}
100080f8:	e037883a 	mov	sp,fp
100080fc:	dfc00117 	ldw	ra,4(sp)
10008100:	df000017 	ldw	fp,0(sp)
10008104:	dec00204 	addi	sp,sp,8
10008108:	f800283a 	ret

1000810c <alt_erase_block_intel>:
 * alt_erase_block_intel
 * 
 * Erase the selected erase block
 */
int alt_erase_block_intel(alt_flash_dev* flash_info, int block_offset)
{
1000810c:	defff804 	addi	sp,sp,-32
10008110:	dfc00715 	stw	ra,28(sp)
10008114:	df000615 	stw	fp,24(sp)
10008118:	df000604 	addi	fp,sp,24
1000811c:	e13ffe15 	stw	r4,-8(fp)
10008120:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
10008124:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
10008128:	e0bffe17 	ldw	r2,-8(fp)
1000812c:	e0bffb15 	stw	r2,-20(fp)
  volatile alt_u8  status;
  int   timeout = flash->erase_timeout;
10008130:	e0bffb17 	ldw	r2,-20(fp)
10008134:	10803117 	ldw	r2,196(r2)
10008138:	e0bffa15 	stw	r2,-24(fp)

  /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
1000813c:	e13ffb17 	ldw	r4,-20(fp)
10008140:	e17fff17 	ldw	r5,-4(fp)
10008144:	00082800 	call	10008280 <alt_unlock_block_intel>
10008148:	e0bffc15 	stw	r2,-16(fp)

  if (!ret_code)
1000814c:	e0bffc17 	ldw	r2,-16(fp)
10008150:	1004c03a 	cmpne	r2,r2,zero
10008154:	1000441e 	bne	r2,zero,10008268 <alt_erase_block_intel+0x15c>
  {

    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x20);
10008158:	e0bffb17 	ldw	r2,-20(fp)
1000815c:	11803517 	ldw	r6,212(r2)
10008160:	e0bffb17 	ldw	r2,-20(fp)
10008164:	10800a17 	ldw	r2,40(r2)
10008168:	1007883a 	mov	r3,r2
1000816c:	e0bfff17 	ldw	r2,-4(fp)
10008170:	1889883a 	add	r4,r3,r2
10008174:	01400804 	movi	r5,32
10008178:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
1000817c:	e0bffb17 	ldw	r2,-20(fp)
10008180:	11803517 	ldw	r6,212(r2)
10008184:	e0bffb17 	ldw	r2,-20(fp)
10008188:	10800a17 	ldw	r2,40(r2)
1000818c:	1007883a 	mov	r3,r2
10008190:	e0bfff17 	ldw	r2,-4(fp)
10008194:	1889883a 	add	r4,r3,r2
10008198:	01403404 	movi	r5,208
1000819c:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
100081a0:	e0bffb17 	ldw	r2,-20(fp)
100081a4:	10800a17 	ldw	r2,40(r2)
100081a8:	1007883a 	mov	r3,r2
100081ac:	e0bfff17 	ldw	r2,-4(fp)
100081b0:	1885883a 	add	r2,r3,r2
100081b4:	10800023 	ldbuio	r2,0(r2)
100081b8:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
100081bc:	e0bffd03 	ldbu	r2,-12(fp)
100081c0:	10803fcc 	andi	r2,r2,255
100081c4:	1080201c 	xori	r2,r2,128
100081c8:	10bfe004 	addi	r2,r2,-128
100081cc:	1004803a 	cmplt	r2,r2,zero
100081d0:	1000081e 	bne	r2,zero,100081f4 <alt_erase_block_intel+0xe8>
      {
        break;
      }
      usleep(1000);
100081d4:	0100fa04 	movi	r4,1000
100081d8:	00086c00 	call	100086c0 <usleep>
      timeout -= 1000;
100081dc:	e0bffa17 	ldw	r2,-24(fp)
100081e0:	10bf0604 	addi	r2,r2,-1000
100081e4:	e0bffa15 	stw	r2,-24(fp)
    }while(timeout > 0);
100081e8:	e0bffa17 	ldw	r2,-24(fp)
100081ec:	10800048 	cmpgei	r2,r2,1
100081f0:	103feb1e 	bne	r2,zero,100081a0 <alt_erase_block_intel+0x94>
    
    if (timeout <= 0)
100081f4:	e0bffa17 	ldw	r2,-24(fp)
100081f8:	10800048 	cmpgei	r2,r2,1
100081fc:	1000031e 	bne	r2,zero,1000820c <alt_erase_block_intel+0x100>
    {
      ret_code = -ETIMEDOUT;
10008200:	00bfe304 	movi	r2,-116
10008204:	e0bffc15 	stw	r2,-16(fp)
10008208:	00000e06 	br	10008244 <alt_erase_block_intel+0x138>
    }
    else if (status & 0x7f)
1000820c:	e0bffd03 	ldbu	r2,-12(fp)
10008210:	10803fcc 	andi	r2,r2,255
10008214:	10801fcc 	andi	r2,r2,127
10008218:	1005003a 	cmpeq	r2,r2,zero
1000821c:	1000091e 	bne	r2,zero,10008244 <alt_erase_block_intel+0x138>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
10008220:	00bffec4 	movi	r2,-5
10008224:	e0bffc15 	stw	r2,-16(fp)
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
10008228:	e0bffb17 	ldw	r2,-20(fp)
1000822c:	10800a17 	ldw	r2,40(r2)
10008230:	1007883a 	mov	r3,r2
10008234:	e0bfff17 	ldw	r2,-4(fp)
10008238:	1885883a 	add	r2,r3,r2
1000823c:	10800023 	ldbuio	r2,0(r2)
10008240:	e0bffd05 	stb	r2,-12(fp)
    }

    /* Put the device back into read array mode */
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
10008244:	e0bffb17 	ldw	r2,-20(fp)
10008248:	11803517 	ldw	r6,212(r2)
1000824c:	e0bffb17 	ldw	r2,-20(fp)
10008250:	10800a17 	ldw	r2,40(r2)
10008254:	1007883a 	mov	r3,r2
10008258:	e0bfff17 	ldw	r2,-4(fp)
1000825c:	1889883a 	add	r4,r3,r2
10008260:	01403fc4 	movi	r5,255
10008264:	303ee83a 	callr	r6
  }
  
  return ret_code;
10008268:	e0bffc17 	ldw	r2,-16(fp)
}
1000826c:	e037883a 	mov	sp,fp
10008270:	dfc00117 	ldw	ra,4(sp)
10008274:	df000017 	ldw	fp,0(sp)
10008278:	dec00204 	addi	sp,sp,8
1000827c:	f800283a 	ret

10008280 <alt_unlock_block_intel>:
/*
* Private Intel specific functions
*/

static int alt_unlock_block_intel(alt_flash_cfi_dev* flash, int block_offset)
{
10008280:	defff904 	addi	sp,sp,-28
10008284:	dfc00615 	stw	ra,24(sp)
10008288:	df000515 	stw	fp,20(sp)
1000828c:	df000504 	addi	fp,sp,20
10008290:	e13ffe15 	stw	r4,-8(fp)
10008294:	e17fff15 	stw	r5,-4(fp)
  alt_u8  locked;
  alt_u8  status;
  int ret_code = 0;
10008298:	e03ffc15 	stw	zero,-16(fp)
  int timeout = flash->write_timeout * 100;
1000829c:	e0bffe17 	ldw	r2,-8(fp)
100082a0:	10803017 	ldw	r2,192(r2)
100082a4:	10801924 	muli	r2,r2,100
100082a8:	e0bffb15 	stw	r2,-20(fp)


  /*
  * Is this block locked?
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x90);
100082ac:	e0bffe17 	ldw	r2,-8(fp)
100082b0:	11803517 	ldw	r6,212(r2)
100082b4:	e0bffe17 	ldw	r2,-8(fp)
100082b8:	10800a17 	ldw	r2,40(r2)
100082bc:	1007883a 	mov	r3,r2
100082c0:	e0bfff17 	ldw	r2,-4(fp)
100082c4:	1889883a 	add	r4,r3,r2
100082c8:	01402404 	movi	r5,144
100082cc:	303ee83a 	callr	r6
  locked = IORD_8DIRECT(flash->dev.base_addr, block_offset + 4);
100082d0:	e0bffe17 	ldw	r2,-8(fp)
100082d4:	10800a17 	ldw	r2,40(r2)
100082d8:	1007883a 	mov	r3,r2
100082dc:	e0bfff17 	ldw	r2,-4(fp)
100082e0:	1885883a 	add	r2,r3,r2
100082e4:	10800104 	addi	r2,r2,4
100082e8:	10800023 	ldbuio	r2,0(r2)
100082ec:	e0bffd45 	stb	r2,-11(fp)
  if (locked & 0x1)
100082f0:	e0bffd43 	ldbu	r2,-11(fp)
100082f4:	1080004c 	andi	r2,r2,1
100082f8:	10803fcc 	andi	r2,r2,255
100082fc:	1005003a 	cmpeq	r2,r2,zero
10008300:	1000331e 	bne	r2,zero,100083d0 <alt_unlock_block_intel+0x150>
  {
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x60);
10008304:	e0bffe17 	ldw	r2,-8(fp)
10008308:	11803517 	ldw	r6,212(r2)
1000830c:	e0bffe17 	ldw	r2,-8(fp)
10008310:	10800a17 	ldw	r2,40(r2)
10008314:	1007883a 	mov	r3,r2
10008318:	e0bfff17 	ldw	r2,-4(fp)
1000831c:	1889883a 	add	r4,r3,r2
10008320:	01401804 	movi	r5,96
10008324:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
10008328:	e0bffe17 	ldw	r2,-8(fp)
1000832c:	11803517 	ldw	r6,212(r2)
10008330:	e0bffe17 	ldw	r2,-8(fp)
10008334:	10800a17 	ldw	r2,40(r2)
10008338:	1007883a 	mov	r3,r2
1000833c:	e0bfff17 	ldw	r2,-4(fp)
10008340:	1889883a 	add	r4,r3,r2
10008344:	01403404 	movi	r5,208
10008348:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
1000834c:	e0bffe17 	ldw	r2,-8(fp)
10008350:	10800a17 	ldw	r2,40(r2)
10008354:	1007883a 	mov	r3,r2
10008358:	e0bfff17 	ldw	r2,-4(fp)
1000835c:	1885883a 	add	r2,r3,r2
10008360:	10800023 	ldbuio	r2,0(r2)
10008364:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
10008368:	e0bffd03 	ldbu	r2,-12(fp)
1000836c:	10803fcc 	andi	r2,r2,255
10008370:	1080201c 	xori	r2,r2,128
10008374:	10bfe004 	addi	r2,r2,-128
10008378:	1004803a 	cmplt	r2,r2,zero
1000837c:	1000081e 	bne	r2,zero,100083a0 <alt_unlock_block_intel+0x120>
      {
        break;
      }
      timeout--;
10008380:	e0bffb17 	ldw	r2,-20(fp)
10008384:	10bfffc4 	addi	r2,r2,-1
10008388:	e0bffb15 	stw	r2,-20(fp)
      usleep(1);
1000838c:	01000044 	movi	r4,1
10008390:	00086c00 	call	100086c0 <usleep>
    }while(timeout > 0);
10008394:	e0bffb17 	ldw	r2,-20(fp)
10008398:	10800048 	cmpgei	r2,r2,1
1000839c:	103feb1e 	bne	r2,zero,1000834c <alt_unlock_block_intel+0xcc>

    if (timeout == 0)
100083a0:	e0bffb17 	ldw	r2,-20(fp)
100083a4:	1004c03a 	cmpne	r2,r2,zero
100083a8:	1000031e 	bne	r2,zero,100083b8 <alt_unlock_block_intel+0x138>
    {
      ret_code = -ETIMEDOUT;
100083ac:	00bfe304 	movi	r2,-116
100083b0:	e0bffc15 	stw	r2,-16(fp)
100083b4:	00000606 	br	100083d0 <alt_unlock_block_intel+0x150>
    }
    else if (status & 0x7f)
100083b8:	e0bffd03 	ldbu	r2,-12(fp)
100083bc:	10801fcc 	andi	r2,r2,127
100083c0:	1005003a 	cmpeq	r2,r2,zero
100083c4:	1000021e 	bne	r2,zero,100083d0 <alt_unlock_block_intel+0x150>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
100083c8:	00bffec4 	movi	r2,-5
100083cc:	e0bffc15 	stw	r2,-16(fp)
  }

  /*
  * Back to Read Array mode
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
100083d0:	e0bffe17 	ldw	r2,-8(fp)
100083d4:	11803517 	ldw	r6,212(r2)
100083d8:	e0bffe17 	ldw	r2,-8(fp)
100083dc:	10800a17 	ldw	r2,40(r2)
100083e0:	1007883a 	mov	r3,r2
100083e4:	e0bfff17 	ldw	r2,-4(fp)
100083e8:	1889883a 	add	r4,r3,r2
100083ec:	01403fc4 	movi	r5,255
100083f0:	303ee83a 	callr	r6

  return ret_code;
100083f4:	e0bffc17 	ldw	r2,-16(fp)
}
100083f8:	e037883a 	mov	sp,fp
100083fc:	dfc00117 	ldw	ra,4(sp)
10008400:	df000017 	ldw	fp,0(sp)
10008404:	dec00204 	addi	sp,sp,8
10008408:	f800283a 	ret

1000840c <alt_write_word_intel>:
 * offset bytes into the flash
 */
 
int alt_write_word_intel( alt_flash_cfi_dev* flash, 
                                  const int offset, const alt_u8* src_addr)
{ 
1000840c:	defff904 	addi	sp,sp,-28
10008410:	dfc00615 	stw	ra,24(sp)
10008414:	df000515 	stw	fp,20(sp)
10008418:	df000504 	addi	fp,sp,20
1000841c:	e13ffd15 	stw	r4,-12(fp)
10008420:	e17ffe15 	stw	r5,-8(fp)
10008424:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
10008428:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 status;
  (*flash->write_native)((alt_u8*)flash->dev.base_addr+offset, 0x40);
1000842c:	e0bffd17 	ldw	r2,-12(fp)
10008430:	11803517 	ldw	r6,212(r2)
10008434:	e0bffd17 	ldw	r2,-12(fp)
10008438:	10800a17 	ldw	r2,40(r2)
1000843c:	1007883a 	mov	r3,r2
10008440:	e0bffe17 	ldw	r2,-8(fp)
10008444:	1889883a 	add	r4,r3,r2
10008448:	01401004 	movi	r5,64
1000844c:	303ee83a 	callr	r6
  alt_write_value_to_flash(flash, offset, src_addr);
10008450:	e13ffd17 	ldw	r4,-12(fp)
10008454:	e17ffe17 	ldw	r5,-8(fp)
10008458:	e1bfff17 	ldw	r6,-4(fp)
1000845c:	0003bc80 	call	10003bc8 <alt_write_value_to_flash>

  do
  {
    status = IORD_8DIRECT(flash->dev.base_addr, offset);
10008460:	e0bffd17 	ldw	r2,-12(fp)
10008464:	10800a17 	ldw	r2,40(r2)
10008468:	1007883a 	mov	r3,r2
1000846c:	e0bffe17 	ldw	r2,-8(fp)
10008470:	1885883a 	add	r2,r3,r2
10008474:	10800023 	ldbuio	r2,0(r2)
10008478:	e0bffb05 	stb	r2,-20(fp)
  }while(!(status & 0x80));
1000847c:	e0bffb03 	ldbu	r2,-20(fp)
10008480:	10803fcc 	andi	r2,r2,255
10008484:	1080201c 	xori	r2,r2,128
10008488:	10bfe004 	addi	r2,r2,-128
1000848c:	1004403a 	cmpge	r2,r2,zero
10008490:	103ff31e 	bne	r2,zero,10008460 <alt_write_word_intel+0x54>

  /* If we have an error of some kind bomb out */
  if (status & 0x7f)
10008494:	e0bffb03 	ldbu	r2,-20(fp)
10008498:	10801fcc 	andi	r2,r2,127
1000849c:	1005003a 	cmpeq	r2,r2,zero
100084a0:	1000021e 	bne	r2,zero,100084ac <alt_write_word_intel+0xa0>
  {
    ret_code = -EIO;
100084a4:	00bffec4 	movi	r2,-5
100084a8:	e0bffc15 	stw	r2,-16(fp)
  }

  /* Put the device back into read array mode */
  flash->write_native((alt_u8*)flash->dev.base_addr + offset, 0xFF);
100084ac:	e0bffd17 	ldw	r2,-12(fp)
100084b0:	11803517 	ldw	r6,212(r2)
100084b4:	e0bffd17 	ldw	r2,-12(fp)
100084b8:	10800a17 	ldw	r2,40(r2)
100084bc:	1007883a 	mov	r3,r2
100084c0:	e0bffe17 	ldw	r2,-8(fp)
100084c4:	1889883a 	add	r4,r3,r2
100084c8:	01403fc4 	movi	r5,255
100084cc:	303ee83a 	callr	r6
  
  return ret_code;
100084d0:	e0bffc17 	ldw	r2,-16(fp)
}
100084d4:	e037883a 	mov	sp,fp
100084d8:	dfc00117 	ldw	ra,4(sp)
100084dc:	df000017 	ldw	fp,0(sp)
100084e0:	dec00204 	addi	sp,sp,8
100084e4:	f800283a 	ret

100084e8 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
100084e8:	defffa04 	addi	sp,sp,-24
100084ec:	dfc00515 	stw	ra,20(sp)
100084f0:	df000415 	stw	fp,16(sp)
100084f4:	df000404 	addi	fp,sp,16
100084f8:	e13ffe15 	stw	r4,-8(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
100084fc:	00840074 	movhi	r2,4097
10008500:	10aa1204 	addi	r2,r2,-22456
10008504:	10800017 	ldw	r2,0(r2)
10008508:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
1000850c:	00003306 	br	100085dc <alt_find_file+0xf4>
  {
    len = strlen(next->name);
10008510:	e0bffd17 	ldw	r2,-12(fp)
10008514:	11000217 	ldw	r4,8(r2)
10008518:	00003e40 	call	100003e4 <strlen>
1000851c:	e0bffc15 	stw	r2,-16(fp)
    
    if (next->name[len-1] == '/')
10008520:	e0bffd17 	ldw	r2,-12(fp)
10008524:	10c00217 	ldw	r3,8(r2)
10008528:	e0bffc17 	ldw	r2,-16(fp)
1000852c:	1885883a 	add	r2,r3,r2
10008530:	10bfffc4 	addi	r2,r2,-1
10008534:	10800003 	ldbu	r2,0(r2)
10008538:	10803fcc 	andi	r2,r2,255
1000853c:	1080201c 	xori	r2,r2,128
10008540:	10bfe004 	addi	r2,r2,-128
10008544:	10800bd8 	cmpnei	r2,r2,47
10008548:	1000031e 	bne	r2,zero,10008558 <alt_find_file+0x70>
    {
      len -= 1;
1000854c:	e0bffc17 	ldw	r2,-16(fp)
10008550:	10bfffc4 	addi	r2,r2,-1
10008554:	e0bffc15 	stw	r2,-16(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
10008558:	e0bffc17 	ldw	r2,-16(fp)
1000855c:	1007883a 	mov	r3,r2
10008560:	e0bffe17 	ldw	r2,-8(fp)
10008564:	1885883a 	add	r2,r3,r2
10008568:	10800003 	ldbu	r2,0(r2)
1000856c:	10803fcc 	andi	r2,r2,255
10008570:	1080201c 	xori	r2,r2,128
10008574:	10bfe004 	addi	r2,r2,-128
10008578:	10800be0 	cmpeqi	r2,r2,47
1000857c:	10000a1e 	bne	r2,zero,100085a8 <alt_find_file+0xc0>
10008580:	e0bffc17 	ldw	r2,-16(fp)
10008584:	1007883a 	mov	r3,r2
10008588:	e0bffe17 	ldw	r2,-8(fp)
1000858c:	1885883a 	add	r2,r3,r2
10008590:	10800003 	ldbu	r2,0(r2)
10008594:	10803fcc 	andi	r2,r2,255
10008598:	1080201c 	xori	r2,r2,128
1000859c:	10bfe004 	addi	r2,r2,-128
100085a0:	1004c03a 	cmpne	r2,r2,zero
100085a4:	10000a1e 	bne	r2,zero,100085d0 <alt_find_file+0xe8>
100085a8:	e0bffd17 	ldw	r2,-12(fp)
100085ac:	11000217 	ldw	r4,8(r2)
100085b0:	e1bffc17 	ldw	r6,-16(fp)
100085b4:	e17ffe17 	ldw	r5,-8(fp)
100085b8:	00088680 	call	10008868 <memcmp>
100085bc:	1004c03a 	cmpne	r2,r2,zero
100085c0:	1000031e 	bne	r2,zero,100085d0 <alt_find_file+0xe8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
100085c4:	e0bffd17 	ldw	r2,-12(fp)
100085c8:	e0bfff15 	stw	r2,-4(fp)
100085cc:	00000806 	br	100085f0 <alt_find_file+0x108>
    }
    next = (alt_dev*) next->llist.next;
100085d0:	e0bffd17 	ldw	r2,-12(fp)
100085d4:	10800017 	ldw	r2,0(r2)
100085d8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
100085dc:	00c40074 	movhi	r3,4097
100085e0:	18ea1204 	addi	r3,r3,-22456
100085e4:	e0bffd17 	ldw	r2,-12(fp)
100085e8:	10ffc91e 	bne	r2,r3,10008510 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
100085ec:	e03fff15 	stw	zero,-4(fp)
100085f0:	e0bfff17 	ldw	r2,-4(fp)
}
100085f4:	e037883a 	mov	sp,fp
100085f8:	dfc00117 	ldw	ra,4(sp)
100085fc:	df000017 	ldw	fp,0(sp)
10008600:	dec00204 	addi	sp,sp,8
10008604:	f800283a 	ret

10008608 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
10008608:	defffc04 	addi	sp,sp,-16
1000860c:	df000315 	stw	fp,12(sp)
10008610:	df000304 	addi	fp,sp,12
10008614:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
10008618:	00bffa04 	movi	r2,-24
1000861c:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
10008620:	e03ffe15 	stw	zero,-8(fp)
10008624:	00001e06 	br	100086a0 <alt_get_fd+0x98>
  {
    if (!alt_fd_list[i].dev)
10008628:	e0bffe17 	ldw	r2,-8(fp)
1000862c:	00c40074 	movhi	r3,4097
10008630:	18e54804 	addi	r3,r3,-27360
10008634:	10800324 	muli	r2,r2,12
10008638:	10c5883a 	add	r2,r2,r3
1000863c:	10800017 	ldw	r2,0(r2)
10008640:	1004c03a 	cmpne	r2,r2,zero
10008644:	1000131e 	bne	r2,zero,10008694 <alt_get_fd+0x8c>
    {
      alt_fd_list[i].dev = dev;
10008648:	e0bffe17 	ldw	r2,-8(fp)
1000864c:	00c40074 	movhi	r3,4097
10008650:	18e54804 	addi	r3,r3,-27360
10008654:	10800324 	muli	r2,r2,12
10008658:	10c7883a 	add	r3,r2,r3
1000865c:	e0bfff17 	ldw	r2,-4(fp)
10008660:	18800015 	stw	r2,0(r3)
      if (i > alt_max_fd)
10008664:	00840074 	movhi	r2,4097
10008668:	10aa1604 	addi	r2,r2,-22440
1000866c:	10c00017 	ldw	r3,0(r2)
10008670:	e0bffe17 	ldw	r2,-8(fp)
10008674:	1880040e 	bge	r3,r2,10008688 <alt_get_fd+0x80>
      {
        alt_max_fd = i;
10008678:	00c40074 	movhi	r3,4097
1000867c:	18ea1604 	addi	r3,r3,-22440
10008680:	e0bffe17 	ldw	r2,-8(fp)
10008684:	18800015 	stw	r2,0(r3)
      }
      rc = i;
10008688:	e0bffe17 	ldw	r2,-8(fp)
1000868c:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
10008690:	00000606 	br	100086ac <alt_get_fd+0xa4>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
10008694:	e0bffe17 	ldw	r2,-8(fp)
10008698:	10800044 	addi	r2,r2,1
1000869c:	e0bffe15 	stw	r2,-8(fp)
100086a0:	e0bffe17 	ldw	r2,-8(fp)
100086a4:	10800810 	cmplti	r2,r2,32
100086a8:	103fdf1e 	bne	r2,zero,10008628 <alt_get_fd+0x20>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
100086ac:	e0bffd17 	ldw	r2,-12(fp)
}
100086b0:	e037883a 	mov	sp,fp
100086b4:	df000017 	ldw	fp,0(sp)
100086b8:	dec00104 	addi	sp,sp,4
100086bc:	f800283a 	ret

100086c0 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
100086c0:	defffd04 	addi	sp,sp,-12
100086c4:	dfc00215 	stw	ra,8(sp)
100086c8:	df000115 	stw	fp,4(sp)
100086cc:	df000104 	addi	fp,sp,4
100086d0:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
100086d4:	e13fff17 	ldw	r4,-4(fp)
100086d8:	00086f00 	call	100086f0 <alt_busy_sleep>
}
100086dc:	e037883a 	mov	sp,fp
100086e0:	dfc00117 	ldw	ra,4(sp)
100086e4:	df000017 	ldw	fp,0(sp)
100086e8:	dec00204 	addi	sp,sp,8
100086ec:	f800283a 	ret

100086f0 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
100086f0:	defffb04 	addi	sp,sp,-20
100086f4:	df000415 	stw	fp,16(sp)
100086f8:	df000404 	addi	fp,sp,16
100086fc:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
10008700:	008000c4 	movi	r2,3
10008704:	e0bffc15 	stw	r2,-16(fp)
  }
  

  big_loops = us / (INT_MAX/
10008708:	e0fffc17 	ldw	r3,-16(fp)
1000870c:	008003f4 	movhi	r2,15
10008710:	10909004 	addi	r2,r2,16960
10008714:	1887383a 	mul	r3,r3,r2
10008718:	0080eeb4 	movhi	r2,954
1000871c:	10ab2804 	addi	r2,r2,-21344
10008720:	10c7203a 	divu	r3,r2,r3
10008724:	00a00034 	movhi	r2,32768
10008728:	10bfffc4 	addi	r2,r2,-1
1000872c:	10c7203a 	divu	r3,r2,r3
10008730:	e0bfff17 	ldw	r2,-4(fp)
10008734:	10c5203a 	divu	r2,r2,r3
10008738:	e0bffd15 	stw	r2,-12(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
1000873c:	e0bffd17 	ldw	r2,-12(fp)
10008740:	1005003a 	cmpeq	r2,r2,zero
10008744:	1000251e 	bne	r2,zero,100087dc <alt_busy_sleep+0xec>
  {
    for(i=0;i<big_loops;i++)
10008748:	e03ffe15 	stw	zero,-8(fp)
1000874c:	00001406 	br	100087a0 <alt_busy_sleep+0xb0>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
10008750:	00a00034 	movhi	r2,32768
10008754:	10bfffc4 	addi	r2,r2,-1
10008758:	10bfffc4 	addi	r2,r2,-1
1000875c:	103ffe1e 	bne	r2,zero,10008758 <alt_busy_sleep+0x68>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
10008760:	e0fffc17 	ldw	r3,-16(fp)
10008764:	008003f4 	movhi	r2,15
10008768:	10909004 	addi	r2,r2,16960
1000876c:	1887383a 	mul	r3,r3,r2
10008770:	0080eeb4 	movhi	r2,954
10008774:	10ab2804 	addi	r2,r2,-21344
10008778:	10c7203a 	divu	r3,r2,r3
1000877c:	00a00034 	movhi	r2,32768
10008780:	10bfffc4 	addi	r2,r2,-1
10008784:	10c7203a 	divu	r3,r2,r3
10008788:	e0bfff17 	ldw	r2,-4(fp)
1000878c:	10c5c83a 	sub	r2,r2,r3
10008790:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
10008794:	e0bffe17 	ldw	r2,-8(fp)
10008798:	10800044 	addi	r2,r2,1
1000879c:	e0bffe15 	stw	r2,-8(fp)
100087a0:	e0fffe17 	ldw	r3,-8(fp)
100087a4:	e0bffd17 	ldw	r2,-12(fp)
100087a8:	18bfe916 	blt	r3,r2,10008750 <alt_busy_sleep+0x60>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
100087ac:	e0fffc17 	ldw	r3,-16(fp)
100087b0:	008003f4 	movhi	r2,15
100087b4:	10909004 	addi	r2,r2,16960
100087b8:	1887383a 	mul	r3,r3,r2
100087bc:	0080eeb4 	movhi	r2,954
100087c0:	10ab2804 	addi	r2,r2,-21344
100087c4:	10c7203a 	divu	r3,r2,r3
100087c8:	e0bfff17 	ldw	r2,-4(fp)
100087cc:	1885383a 	mul	r2,r3,r2
100087d0:	10bfffc4 	addi	r2,r2,-1
100087d4:	103ffe1e 	bne	r2,zero,100087d0 <alt_busy_sleep+0xe0>
100087d8:	00000b06 	br	10008808 <alt_busy_sleep+0x118>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
100087dc:	e0fffc17 	ldw	r3,-16(fp)
100087e0:	008003f4 	movhi	r2,15
100087e4:	10909004 	addi	r2,r2,16960
100087e8:	1887383a 	mul	r3,r3,r2
100087ec:	0080eeb4 	movhi	r2,954
100087f0:	10ab2804 	addi	r2,r2,-21344
100087f4:	10c7203a 	divu	r3,r2,r3
100087f8:	e0bfff17 	ldw	r2,-4(fp)
100087fc:	1885383a 	mul	r2,r3,r2
10008800:	10bfffc4 	addi	r2,r2,-1
10008804:	00bffe16 	blt	zero,r2,10008800 <alt_busy_sleep+0x110>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
10008808:	0005883a 	mov	r2,zero
}
1000880c:	e037883a 	mov	sp,fp
10008810:	df000017 	ldw	fp,0(sp)
10008814:	dec00104 	addi	sp,sp,4
10008818:	f800283a 	ret

1000881c <atexit>:
1000881c:	200b883a 	mov	r5,r4
10008820:	000d883a 	mov	r6,zero
10008824:	0009883a 	mov	r4,zero
10008828:	000f883a 	mov	r7,zero
1000882c:	00088dc1 	jmpi	100088dc <__register_exitproc>

10008830 <exit>:
10008830:	defffe04 	addi	sp,sp,-8
10008834:	000b883a 	mov	r5,zero
10008838:	dc000015 	stw	r16,0(sp)
1000883c:	dfc00115 	stw	ra,4(sp)
10008840:	2021883a 	mov	r16,r4
10008844:	0008a140 	call	10008a14 <__call_exitprocs>
10008848:	00840074 	movhi	r2,4097
1000884c:	10aa0f04 	addi	r2,r2,-22468
10008850:	11000017 	ldw	r4,0(r2)
10008854:	20800f17 	ldw	r2,60(r4)
10008858:	10000126 	beq	r2,zero,10008860 <exit+0x30>
1000885c:	103ee83a 	callr	r2
10008860:	8009883a 	mov	r4,r16
10008864:	0008c040 	call	10008c04 <_exit>

10008868 <memcmp>:
10008868:	00c000c4 	movi	r3,3
1000886c:	1980032e 	bgeu	r3,r6,1000887c <memcmp+0x14>
10008870:	2144b03a 	or	r2,r4,r5
10008874:	10c4703a 	and	r2,r2,r3
10008878:	10000f26 	beq	r2,zero,100088b8 <memcmp+0x50>
1000887c:	31ffffc4 	addi	r7,r6,-1
10008880:	3000061e 	bne	r6,zero,1000889c <memcmp+0x34>
10008884:	00000a06 	br	100088b0 <memcmp+0x48>
10008888:	39ffffc4 	addi	r7,r7,-1
1000888c:	00bfffc4 	movi	r2,-1
10008890:	21000044 	addi	r4,r4,1
10008894:	29400044 	addi	r5,r5,1
10008898:	38800526 	beq	r7,r2,100088b0 <memcmp+0x48>
1000889c:	20c00003 	ldbu	r3,0(r4)
100088a0:	28800003 	ldbu	r2,0(r5)
100088a4:	18bff826 	beq	r3,r2,10008888 <memcmp+0x20>
100088a8:	1885c83a 	sub	r2,r3,r2
100088ac:	f800283a 	ret
100088b0:	0005883a 	mov	r2,zero
100088b4:	f800283a 	ret
100088b8:	180f883a 	mov	r7,r3
100088bc:	20c00017 	ldw	r3,0(r4)
100088c0:	28800017 	ldw	r2,0(r5)
100088c4:	18bfed1e 	bne	r3,r2,1000887c <memcmp+0x14>
100088c8:	31bfff04 	addi	r6,r6,-4
100088cc:	21000104 	addi	r4,r4,4
100088d0:	29400104 	addi	r5,r5,4
100088d4:	39bff936 	bltu	r7,r6,100088bc <memcmp+0x54>
100088d8:	003fe806 	br	1000887c <memcmp+0x14>

100088dc <__register_exitproc>:
100088dc:	defffa04 	addi	sp,sp,-24
100088e0:	00840074 	movhi	r2,4097
100088e4:	10aa0f04 	addi	r2,r2,-22468
100088e8:	dc000015 	stw	r16,0(sp)
100088ec:	14000017 	ldw	r16,0(r2)
100088f0:	dd000415 	stw	r20,16(sp)
100088f4:	2829883a 	mov	r20,r5
100088f8:	81405217 	ldw	r5,328(r16)
100088fc:	dcc00315 	stw	r19,12(sp)
10008900:	dc800215 	stw	r18,8(sp)
10008904:	dc400115 	stw	r17,4(sp)
10008908:	dfc00515 	stw	ra,20(sp)
1000890c:	2023883a 	mov	r17,r4
10008910:	3027883a 	mov	r19,r6
10008914:	3825883a 	mov	r18,r7
10008918:	28002526 	beq	r5,zero,100089b0 <__register_exitproc+0xd4>
1000891c:	29000117 	ldw	r4,4(r5)
10008920:	008007c4 	movi	r2,31
10008924:	11002716 	blt	r2,r4,100089c4 <__register_exitproc+0xe8>
10008928:	8800101e 	bne	r17,zero,1000896c <__register_exitproc+0x90>
1000892c:	2105883a 	add	r2,r4,r4
10008930:	1085883a 	add	r2,r2,r2
10008934:	20c00044 	addi	r3,r4,1
10008938:	1145883a 	add	r2,r2,r5
1000893c:	0009883a 	mov	r4,zero
10008940:	15000215 	stw	r20,8(r2)
10008944:	28c00115 	stw	r3,4(r5)
10008948:	2005883a 	mov	r2,r4
1000894c:	dfc00517 	ldw	ra,20(sp)
10008950:	dd000417 	ldw	r20,16(sp)
10008954:	dcc00317 	ldw	r19,12(sp)
10008958:	dc800217 	ldw	r18,8(sp)
1000895c:	dc400117 	ldw	r17,4(sp)
10008960:	dc000017 	ldw	r16,0(sp)
10008964:	dec00604 	addi	sp,sp,24
10008968:	f800283a 	ret
1000896c:	29802204 	addi	r6,r5,136
10008970:	00800044 	movi	r2,1
10008974:	110e983a 	sll	r7,r2,r4
10008978:	30c04017 	ldw	r3,256(r6)
1000897c:	2105883a 	add	r2,r4,r4
10008980:	1085883a 	add	r2,r2,r2
10008984:	1185883a 	add	r2,r2,r6
10008988:	19c6b03a 	or	r3,r3,r7
1000898c:	14802015 	stw	r18,128(r2)
10008990:	14c00015 	stw	r19,0(r2)
10008994:	00800084 	movi	r2,2
10008998:	30c04015 	stw	r3,256(r6)
1000899c:	88bfe31e 	bne	r17,r2,1000892c <__register_exitproc+0x50>
100089a0:	30804117 	ldw	r2,260(r6)
100089a4:	11c4b03a 	or	r2,r2,r7
100089a8:	30804115 	stw	r2,260(r6)
100089ac:	003fdf06 	br	1000892c <__register_exitproc+0x50>
100089b0:	00840074 	movhi	r2,4097
100089b4:	10aa7404 	addi	r2,r2,-22064
100089b8:	100b883a 	mov	r5,r2
100089bc:	80805215 	stw	r2,328(r16)
100089c0:	003fd606 	br	1000891c <__register_exitproc+0x40>
100089c4:	00800034 	movhi	r2,0
100089c8:	10800004 	addi	r2,r2,0
100089cc:	1000021e 	bne	r2,zero,100089d8 <__register_exitproc+0xfc>
100089d0:	013fffc4 	movi	r4,-1
100089d4:	003fdc06 	br	10008948 <__register_exitproc+0x6c>
100089d8:	01006404 	movi	r4,400
100089dc:	103ee83a 	callr	r2
100089e0:	1007883a 	mov	r3,r2
100089e4:	103ffa26 	beq	r2,zero,100089d0 <__register_exitproc+0xf4>
100089e8:	80805217 	ldw	r2,328(r16)
100089ec:	180b883a 	mov	r5,r3
100089f0:	18000115 	stw	zero,4(r3)
100089f4:	18800015 	stw	r2,0(r3)
100089f8:	80c05215 	stw	r3,328(r16)
100089fc:	18006215 	stw	zero,392(r3)
10008a00:	18006315 	stw	zero,396(r3)
10008a04:	0009883a 	mov	r4,zero
10008a08:	883fc826 	beq	r17,zero,1000892c <__register_exitproc+0x50>
10008a0c:	003fd706 	br	1000896c <__register_exitproc+0x90>

10008a10 <register_fini>:
10008a10:	f800283a 	ret

10008a14 <__call_exitprocs>:
10008a14:	00840074 	movhi	r2,4097
10008a18:	10aa0f04 	addi	r2,r2,-22468
10008a1c:	10800017 	ldw	r2,0(r2)
10008a20:	defff304 	addi	sp,sp,-52
10008a24:	df000b15 	stw	fp,44(sp)
10008a28:	d8800115 	stw	r2,4(sp)
10008a2c:	00800034 	movhi	r2,0
10008a30:	10800004 	addi	r2,r2,0
10008a34:	1005003a 	cmpeq	r2,r2,zero
10008a38:	d8800215 	stw	r2,8(sp)
10008a3c:	d8800117 	ldw	r2,4(sp)
10008a40:	dd400815 	stw	r21,32(sp)
10008a44:	dd000715 	stw	r20,28(sp)
10008a48:	10805204 	addi	r2,r2,328
10008a4c:	dfc00c15 	stw	ra,48(sp)
10008a50:	ddc00a15 	stw	r23,40(sp)
10008a54:	dd800915 	stw	r22,36(sp)
10008a58:	dcc00615 	stw	r19,24(sp)
10008a5c:	dc800515 	stw	r18,20(sp)
10008a60:	dc400415 	stw	r17,16(sp)
10008a64:	dc000315 	stw	r16,12(sp)
10008a68:	282b883a 	mov	r21,r5
10008a6c:	2039883a 	mov	fp,r4
10008a70:	d8800015 	stw	r2,0(sp)
10008a74:	2829003a 	cmpeq	r20,r5,zero
10008a78:	d8800117 	ldw	r2,4(sp)
10008a7c:	14405217 	ldw	r17,328(r2)
10008a80:	88001026 	beq	r17,zero,10008ac4 <__call_exitprocs+0xb0>
10008a84:	ddc00017 	ldw	r23,0(sp)
10008a88:	88800117 	ldw	r2,4(r17)
10008a8c:	8c802204 	addi	r18,r17,136
10008a90:	143fffc4 	addi	r16,r2,-1
10008a94:	80000916 	blt	r16,zero,10008abc <__call_exitprocs+0xa8>
10008a98:	05bfffc4 	movi	r22,-1
10008a9c:	a000151e 	bne	r20,zero,10008af4 <__call_exitprocs+0xe0>
10008aa0:	8409883a 	add	r4,r16,r16
10008aa4:	2105883a 	add	r2,r4,r4
10008aa8:	1485883a 	add	r2,r2,r18
10008aac:	10c02017 	ldw	r3,128(r2)
10008ab0:	a8c01126 	beq	r21,r3,10008af8 <__call_exitprocs+0xe4>
10008ab4:	843fffc4 	addi	r16,r16,-1
10008ab8:	85bff81e 	bne	r16,r22,10008a9c <__call_exitprocs+0x88>
10008abc:	d8800217 	ldw	r2,8(sp)
10008ac0:	10003126 	beq	r2,zero,10008b88 <__call_exitprocs+0x174>
10008ac4:	dfc00c17 	ldw	ra,48(sp)
10008ac8:	df000b17 	ldw	fp,44(sp)
10008acc:	ddc00a17 	ldw	r23,40(sp)
10008ad0:	dd800917 	ldw	r22,36(sp)
10008ad4:	dd400817 	ldw	r21,32(sp)
10008ad8:	dd000717 	ldw	r20,28(sp)
10008adc:	dcc00617 	ldw	r19,24(sp)
10008ae0:	dc800517 	ldw	r18,20(sp)
10008ae4:	dc400417 	ldw	r17,16(sp)
10008ae8:	dc000317 	ldw	r16,12(sp)
10008aec:	dec00d04 	addi	sp,sp,52
10008af0:	f800283a 	ret
10008af4:	8409883a 	add	r4,r16,r16
10008af8:	88c00117 	ldw	r3,4(r17)
10008afc:	2105883a 	add	r2,r4,r4
10008b00:	1445883a 	add	r2,r2,r17
10008b04:	18ffffc4 	addi	r3,r3,-1
10008b08:	11800217 	ldw	r6,8(r2)
10008b0c:	1c001526 	beq	r3,r16,10008b64 <__call_exitprocs+0x150>
10008b10:	10000215 	stw	zero,8(r2)
10008b14:	303fe726 	beq	r6,zero,10008ab4 <__call_exitprocs+0xa0>
10008b18:	00c00044 	movi	r3,1
10008b1c:	1c06983a 	sll	r3,r3,r16
10008b20:	90804017 	ldw	r2,256(r18)
10008b24:	8cc00117 	ldw	r19,4(r17)
10008b28:	1884703a 	and	r2,r3,r2
10008b2c:	10001426 	beq	r2,zero,10008b80 <__call_exitprocs+0x16c>
10008b30:	90804117 	ldw	r2,260(r18)
10008b34:	1884703a 	and	r2,r3,r2
10008b38:	10000c1e 	bne	r2,zero,10008b6c <__call_exitprocs+0x158>
10008b3c:	2105883a 	add	r2,r4,r4
10008b40:	1485883a 	add	r2,r2,r18
10008b44:	11400017 	ldw	r5,0(r2)
10008b48:	e009883a 	mov	r4,fp
10008b4c:	303ee83a 	callr	r6
10008b50:	88800117 	ldw	r2,4(r17)
10008b54:	98bfc81e 	bne	r19,r2,10008a78 <__call_exitprocs+0x64>
10008b58:	b8800017 	ldw	r2,0(r23)
10008b5c:	147fd526 	beq	r2,r17,10008ab4 <__call_exitprocs+0xa0>
10008b60:	003fc506 	br	10008a78 <__call_exitprocs+0x64>
10008b64:	8c000115 	stw	r16,4(r17)
10008b68:	003fea06 	br	10008b14 <__call_exitprocs+0x100>
10008b6c:	2105883a 	add	r2,r4,r4
10008b70:	1485883a 	add	r2,r2,r18
10008b74:	11000017 	ldw	r4,0(r2)
10008b78:	303ee83a 	callr	r6
10008b7c:	003ff406 	br	10008b50 <__call_exitprocs+0x13c>
10008b80:	303ee83a 	callr	r6
10008b84:	003ff206 	br	10008b50 <__call_exitprocs+0x13c>
10008b88:	88800117 	ldw	r2,4(r17)
10008b8c:	1000081e 	bne	r2,zero,10008bb0 <__call_exitprocs+0x19c>
10008b90:	89000017 	ldw	r4,0(r17)
10008b94:	20000726 	beq	r4,zero,10008bb4 <__call_exitprocs+0x1a0>
10008b98:	b9000015 	stw	r4,0(r23)
10008b9c:	8809883a 	mov	r4,r17
10008ba0:	00000000 	call	10000000 <__alt_mem_sdram>
10008ba4:	bc400017 	ldw	r17,0(r23)
10008ba8:	883fb71e 	bne	r17,zero,10008a88 <__call_exitprocs+0x74>
10008bac:	003fc506 	br	10008ac4 <__call_exitprocs+0xb0>
10008bb0:	89000017 	ldw	r4,0(r17)
10008bb4:	882f883a 	mov	r23,r17
10008bb8:	2023883a 	mov	r17,r4
10008bbc:	883fb21e 	bne	r17,zero,10008a88 <__call_exitprocs+0x74>
10008bc0:	003fc006 	br	10008ac4 <__call_exitprocs+0xb0>

10008bc4 <alt_sim_halt>:

/*
 * Routine called on exit.
 */
static ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
10008bc4:	defffd04 	addi	sp,sp,-12
10008bc8:	df000215 	stw	fp,8(sp)
10008bcc:	df000204 	addi	fp,sp,8
10008bd0:	e13fff15 	stw	r4,-4(fp)
  int r2 = exit_code;
10008bd4:	e0bfff17 	ldw	r2,-4(fp)
10008bd8:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
10008bdc:	e0bffe17 	ldw	r2,-8(fp)
10008be0:	1005003a 	cmpeq	r2,r2,zero
10008be4:	1000021e 	bne	r2,zero,10008bf0 <alt_sim_halt+0x2c>
    ALT_SIM_FAIL();
10008be8:	002af070 	cmpltui	zero,zero,43969
10008bec:	00000106 	br	10008bf4 <alt_sim_halt+0x30>
  } else {
    ALT_SIM_PASS();
10008bf0:	002af0b0 	cmpltui	zero,zero,43970
  }
#endif /* DEBUG_STUB */
}
10008bf4:	e037883a 	mov	sp,fp
10008bf8:	df000017 	ldw	fp,0(sp)
10008bfc:	dec00104 	addi	sp,sp,4
10008c00:	f800283a 	ret

10008c04 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
10008c04:	defffd04 	addi	sp,sp,-12
10008c08:	dfc00215 	stw	ra,8(sp)
10008c0c:	df000115 	stw	fp,4(sp)
10008c10:	df000104 	addi	fp,sp,4
10008c14:	e13fff15 	stw	r4,-4(fp)
  ALT_OS_STOP();

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
  ALT_SIM_HALT(exit_code);
10008c18:	e13fff17 	ldw	r4,-4(fp)
10008c1c:	0008bc40 	call	10008bc4 <alt_sim_halt>

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
10008c20:	003fff06 	br	10008c20 <_exit+0x1c>
10008c24:	10008a10 	cmplti	zero,r2,552
